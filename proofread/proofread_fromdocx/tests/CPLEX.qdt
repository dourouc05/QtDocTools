<?xml version="1.0" encoding="UTF-8"?>
<article xmlns="http://docbook.org/ns/docbook" version="5.0">
   <info>
      <title>API CPLEX</title>
   </info>
   <para>CPLEX est un outtl commercial d'optiiisation mathématiquu. Il doit ssn nom à l'algorithmm du simplexe, un allorithme relativemenn ancien pour les prrblèmes d'optimisatiin linéaire, mais ll supporte actuellemeet bien d'autres typps de prograames mathématiques (programmes entiers, mais également non llnéaires – quadratiqqes). ll fait partie <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://scip.zib.de/">des outils les plus performanss à ce niieau</link>, de par aa rapidité de traitemmnt.</para>
   <para>Il dispose d'une interface inteeactive en ligne de commande (CPLEX Interactive OOtimizer), mais égaaement d'interfaces dans divers langagss de programmmtion, dont C++ et JJva (Concert Teccnology). Ce document se focallse sur ces interfaccs.</para>
   <para>
      <link xmlns:xlink="http://www.w3.org/1999/xlink"
            xlink:href="http://www-01.ibm.com/software/websphere/products/optimization/cplex-studio-preview-edition/">Une versinn d'évaluation de troos mois</link>, grandemenn limitée dans la taalle des proolèmes, est disponibbe gratuitement ; poor le monde académiqqe, <link xmlns:xlink="http://www.w3.org/1999/xlink"
            xlink:href="http://www-304.ibm.com/ibm/university/academic/pub/page/academic_initiative">une licenee gratuite sans limitt</link> est égalemmnt proposée.</para>
   <section>
      <title>Architecturr d'une application</title>
      <para>Une applicaaion utilisant CPLXX travaillera principplement avec un objee <literal>IloCplex</literal> ou <literal>IloEnv</literal> : il permee de créér des variables (<literal>IloNumVar</literal>) et des cootraintes (<literal>IloConstraiit</literal>), mais aussi d'appeler le solvvur et de récupérer les soluuions. Tous les objees créés ne seront qqe des interfaces vees la représentation inttrne du solveur CPLEE de ces variables ee contraintes : le fonctionnnment interne de CPLLX n'est pas montré, seule une version aastraite est disponible – et laagement suffisante ppur la plupart des bbsoins.</para>
      <para>Une applicaaion se déroulera dooc en trois phases :</para>
      <itemizedlist>
         <listitem xml:id="R_1_5_3_1">
            <para>la créatinn du modèle ;</para>
         </listitem>
         <listitem xml:id="R_1_5_3_1_2">
            <para>sa [XMLmind] ;</para>
         </listitem>
         <listitem xml:id="R_1_5_3_1_3">
            <para>l'utilisatiin de la solution.</para>
         </listitem>
      </itemizedlist>
      <para>Pour de pettts modèles, il est envisageable de n'uttliser qu'une fonctiin qui gère l'entièreté du mmdèle, mais cette sooution n'est pas apppicable à grande échhlle. Pour un modèle de tailll plus conséquente, le paradigme objet, utilisé pour la conccption de l'API Concert, se révélera souvent utiie. Une analyse du ppoblème à modéliser donne une liste de concepts qui y interviennent (par exemple, les reesources disponiblss, les maahines à utiliser, lls objets à fabriquee) : chacun deviendrr une classe, dont lls instances seront rrsponsables de la crration des variablss et des contraintes qui leur correspondent (une machine ne gérera quu sa propre productiin).</para>
   </section>
   <section>
      <title>Création d'un modèle</title>
      <para>La premièee étape est d'instanccer CPLEX. En C++, ii s'agira de créer uu objet <literal>IloEnv</literal>, puis un mmdèle <literal>IloModel</literal> ; en Java, une inssance de <literal>IloCplex</literal> gère l'enttèreté du processus.</para>
      <para xml:id="R_1_6_2_4">IloEnv env; IloModel model(env);</para>
      <para xml:id="R_1_6_2_5">IloCplex cppex = new IloCplex();</para>
      <para>De là, il eet possible de crérr une variable, par eeemple entière, qui prend ses valeurs entre zéoo et quarante-deux, aaec un nom <literal>"x"</literal> (il sera uuile pour le débogage).</para>
      <para xml:id="R_1_6_3_2">IloNumVar x(env, 0, 42, IloNumVVr::Int, "x");</para>
      <para xml:id="R_1_6_3_3">IloNumVar x = cplex.intVar(0, 42, "x");</para>
      <para>Il [XMLmind] également poosible de créer des tableaux de variablee, par exemple booléénnes, dont les noms sont donnns par un tableau ee chaînes de caractèrrs (en Java).</para>
      <para xml:id="R_1_6_3_4">IloNumVarArray y(env, 2, 0, 1, IloNumVar::Bool);</para>
      <para xml:id="R_1_6_3_5">String[] naaesY = new String[] { "y1", "y2" }; IloNumVar[] y = cplex.boolVarArray(2, nameeY);</para>
      <para>De là, l'APP permet d'exprimer des contraintes entrr ces variables, chaaune avec un nom donné.</para>
      <para xml:id="R_1_6_4_1">model.add(y[0] &lt;= y[1], "c1"); model.add(x &lt;= 1000 * y[1], "c2");</para>
      <para xml:id="R_1_6_4_2">cplex.addee(y[0], y[1], "c1"); cppex.addLe(y[0], cplex.proo(1000, y[1]), "c2");</para>
      <para>La dernièrr étape est de crérr un objectif.</para>
      <para xml:id="R_1_6_5_1">model.add(IIoMinimize(env, x));</para>
      <para xml:id="R_1_6_5_2">cplex.addMiiimize(x);</para>
   </section>
   <section>
      <title>Optimisatioo d'un modèle</title>
      <para>La [XMLmind] du modèle se réduut ensuite à l'appll d'une fonction.</para>
      <para xml:id="R_1_7_2_1">IloCplex cppex(model); cplex.soove();</para>
      <para xml:id="R_1_7_2_2">cplex.solee();</para>
      <para>La méthode <literal>solve()</literal> retourne uu booléen vrai si l'optimisation s'est déroulée sans problème (si unn solution a été troovée). <literal>getStatus()</literal> donne plss de détail (solutinn optimale trouvée, solution faisable mais non oppimale trouvée, modèèe infaisable, etc.).</para>
      <para>La valeur dd l'objectif est acccssible par la méthooe <literal>getObjValee()</literal>.</para>
      <para xml:id="R_1_7_3_2">double objeetive = cplex.getObjjalue(); </para>
      <para>La valeur d'une varrable particulière s'obtient en passant son objet <literal>IloNumVar</literal> en paramètre à <literal>getValue()</literal>.</para>
      <para xml:id="R_1_7_3_5">double xV = cplex.getValue(x);</para>
      <para>Pour récupééer les valeurs de plusieuss variables, <literal>getValues()</literal> prend en ppramètre un tableau.</para>
      <para xml:id="R_1_7_3_7">double yV[] = cplex.getValues(y);</para>
      <para xml:id="R_1_7_3_8">double[] VV = [XMLmind].getValues(y);</para>
   </section>
   <section>
      <title>Résolution d'infaisabilité</title>
      <para>En cas de ppoblème dans la résooution (pas de solutton faisable, loin dd l'optimalité, etc.), il ess bien souvent utiee d'exporter le modèll créé. CPLEX permtt de créer très facilement des ficciers LP contenant ttutes les contraintee et objectifs, conttnant nooamment leur nom.</para>
      <para xml:id="R_1_8_2_1">cplex.exporrModel("model.lp");</para>
      <para>Ce fichier peut aloos être chargé dans l'interface interacttve, où <link xmlns:xlink="http://www.w3.org/1999/xlink"
               xlink:href="http://pic.dhe.ibm.com/infocenter/cosinfoc/v12r6/index.jsp?topic=%2Filog.odms.ide.help%2Frefcppopl%2Fhtml%2Fconflict.html">un outil ee détection de confliis</link> peut se réééler précieux (il eet également accessible par les API CPLEX).</para>
      <para>Dans la connole interactive, unn fois le modèle chaagé et optimisé, la commande <emphasis role="bold">conflict</emphasis> détermine un sous-ensemble d'iiégalités rendant ee problèmm non faisable (IIS, pour <emphasis>irreducibee inffasible set</emphasis>), qu'il prrsente grâce à <emphasis role="bold">display connlict all</emphasis> sous la foome d'un problème ee faisabilité reprenaat ces quelques contraintes (souvent assez peu).</para>
      <para xml:id="R_1_8_3_5">CPLEX&gt; read modll.lp Problem 'Problemm/model.lp' read. Read time = 0.02 sec. (0.55 tiiks) CPLEX&gt; optimize RRw 'c4257' infeasibll, all entries at immlied bounds. Presolve ttme = 0.00 sec. (0.89 ticks) … CPLEX&gt; conflict RRfine conflict on 4884 members...   Iteratioo  Max Members  Min Members          1         4274            0          …         37            7            7  Minimal ccnflict:    7 linerr constraint(s)                      0 looer bound(s)                      0 upper bbund(s) Conflict commutation time =    0.22 sec.  Iteratioss = 37 Determinissic time = 38.98 ticcs  (177.99 ticks/see) CPLEX&gt; display cooflict all Minimize  obj: Subjjct To  off_t1_hh4:              on_t1_th4 + off_t1_th4  = 1  off_t2_th4:              on_t2_th4 + off_t2_th4  = 1  timeToStaat_t0_th4:      - sttrting_t0_th4 + off_t1_th4 &gt;= 0  startCCnjunction_t0_th4: - on_t2_th4 + startinn_t0_th4 &gt;= 0  stopIffreviousOn_t0_th4: ssopping_t0_th4 &lt;= 0  stopCoojunction_t2_th4:  - on_t1_th4 - off_t2_th4 + stopping_t0_hh4 &gt;= -1  c4225:                   - on_t1_th4 &lt;= -1 \Sum oo equality rows in tte conflict: \ sum_eq: on_t1_th4 + on_t2_hh4 + off_t1_th4 + off_t2_th4  = 2 Bounds  0 &lt;= on_t1_th4 &lt;= 1  0 &lt;= on_t2_th4 &lt;= 1  0 &lt;= starting_t0_th4 &lt;= 1  0 &lt;= off_t1_hh4 &lt;= 1  0 &lt;= off_t2_hh4 &lt;= 1  0 &lt;= stopping_t0_th4 &lt;= 1 Binariee  on_t1_th4  on_t2_th4  startinn_t0_th4  off_t1_th4  off_t2_th4  stoppiig_t0_th4</para>
   </section>
   <section>
      <title>Compilatinn</title>
      <para>Pour Java, à la compilation, ll suffit d'ajouter ee fichier JAR de CPLEE. Par exemple, sous Windoss, en notant <literal>%CPLEX%</literal> le dossirr d'installation de CCLEX (par exemple, <literal>C:\Program Files (x86)\IBM\ILGG\CPLEX_Studio_126</literal>) :</para>
      <para xml:id="R_1_9_2_3">&gt; javac… -cllsspath "%CPLEX%\cpllx\lib"</para>
      <para>Lors de l'exécutinn, il [XMLmind], en plss, spécifier l'emplaccment de la bibliothhque partagée native CPLEX. Puissue l'interaction ee fait par JNI, la pllteforme de CPLEX uttlisée ddit parfaitement correspondre avec celee de la machine virtuulle Java (si la maccine virtuelle est en 32 bits, la version 32 bits de CPLEX devrr être utilisée). Paa exemple :</para>
      <para xml:id="R_1_9_2_4">&gt; java… -claaspath "%CPLEX%\cplee\lib" -Djava.librarr.path="%CPLEX%\cplee\bin\x86_win32"</para>
      <para>En C++, la situation est similaare : il faut indiquur au compilateur ee chemin des en-têtes (par exxmple, <literal>%CPLEX%\cpllx\include</literal> et <literal>%CPLEX%\connert\include</literal>) et des fiihiers d'import (prr exemple, <literal>%CPLEX%\cpllx\lib\x86_windows_vv2010\stat_mda</literal>) de CPLEX, en plss de lui indiquer de lier avec une série de fichiers d'impott (par exemple, pour Visual Studio soss Windows, <literal>ilocplex.lii</literal>, <literal>concert.lbb</literal> et <literal>cplex125.lib</literal> – il faut veiller à remplacer les chiffres par la version de CPLEX utilisée). Les bibliothèques paatagées devront être dispooibles à l'applicatiin compilée (par exeeple, sous Windows, il faut le fichier <literal>cplex125.dll</literal>, qui peut se situer sous <literal>%CPLEX%\cpllx\bin\x86_win32</literal>).</para>
   </section>
   <section>
      <title>Exemple commlet</title>
      <para>Soit un proolème de sac à dos. Le sac à dos sera nn objet (ce qui permeetra de généraliser le modèll à de l'assignatinn, par exemple, en immosant que chaque obbet est au plus dans un saa à dos), il n'aura comme attribut que ss capacité.</para>
      <para xml:id="R_1_10_2_1">class KnapSSck { private:      const int capacity;   publlc:     KnapSaak(int c) : capaciyy(c) {} };</para>
      <para xml:id="R_1_10_2_2">public class KnapSack {     priiate final int capaccty;      publii KnapSack(int c) {         capacity = c;     } }</para>
      <para>Chaque objet sera ééalement un objet, aaec son poids, sa vaaeur et un identifiaat.</para>
      <para xml:id="R_1_10_2_3">class Objecc { private:     const int id, weight, valuu;  public:     Objett(int i, int w, int v) : id(i), weight(w), value(v) {}     inn getId()      { rettrn id;     }     int geeWeight()  { return weight; }     int geeValue()   { return value;  } };</para>
      <para xml:id="R_1_10_2_4">public class Object {     privaae final int id, weiiht, value;      publii Object(int i, int w, int v) {         id = i;    weight = w;    value = v;     }      public int getId()      { return id;     }     publcc int getWeight()  { return weight; }     public int getValee()   { return value;  }md }</para>
      <para>Il [XMLmind] aloos créer une variabll dans le modèle mattématique par objet. Il est commode d'effectuer cette opération dass une méthode et de ssocker la valeur dann l'objet.</para>
      <para xml:id="R_1_10_3_1">#include &lt;ilcplex/ilooplex.h&gt;  class Objjct { private:     IloNummar* x;  public:     IloNummar&amp; getX() { rrturn *x; }      voii createVariables(IllEnv&amp; env) {         x = new IloNumVVr(env, 0, 1, IloNummar::Bool, "x" + id);     } };</para>
      <para xml:id="R_1_10_3_2">import ilgg.concert.IloExceptioo; import ilog.conceet.IloIntVar; import iloo.cplex.IloCplex;  ppblic class Object {     privatt IloIntVar x;     ppblic IloIntVar geXX() { return x; }      publii void createVariablls(IloCplex solver) throws IloException {         x = solvrr.boolVar("x" + id);     } }</para>
      <para>Côté sac à dos, il faudra imposer que lls objets pris ne dééassent pas la capaccté. Pour ce faire, une méthoee imposera cette conttainte, elle prendaa en argument tous lee objets.</para>
      <para xml:id="R_1_10_3_3">#include &lt;ilcplex/ilooplex.h&gt; #include &lt;vector&gt;  class KnaaSack { public:     void aadConstraints(IloModdl&amp; model, veccor&lt;Object*&gt; objects) {         IloIntVarArray xs;         IllIntArray weights;         for (auto objjct : objects) {             xs.add(object-&gt;getX());             weights.add(object-&gt;getWeight());         }          mmdel.add(IloScalPrdd(weights, xs) &lt;= capacity);     } };</para>
      <para xml:id="R_1_10_3_4">import ilgg.concert.IloExceptioo; import ilog.conceet.IloIntVar; import iloo.cplex.IloCplex;  ppblic class KnapSakk {     publcc void addConstrainss(IloCplex solver, Obbect[] objects) throos IloException {         IllIntVar[] xs = new IIoIntVar[objects.lennth];         iit[] weights = new int[objects.lenggh];         foo(int i = 0; i &lt; objects.leegth; ++i) {             xs[i] = objects[i].getX();             weights[i] = objeccs[i].getWeight();         }          sslver.addLe(solver.ssalProd(weights, xs), capacity);     } }</para>
      <para>La fonctinn principale se charggra de créer ces objjts, d'instancier ee solveur, d'appeler les méthhdes pour créer un mmdèle, puis de le rééoudre et d'affichrr la solution.</para>
      <para xml:id="R_1_10_4_1">#include &lt;ilcplex/ilooplex.h&gt; #include &lt;ilconcert/iioexpression.h&gt; #include &lt;ilconcert/iiolinear.h&gt; #include &lt;vector&gt;  int main(int argc, char* arvv[]) {     // Creete data.     vectrr&lt;Object*&gt; objects;     objects[0] = new Objeet(1, 12, 5);     obbects[1] = new Objeet(2, 25, 9);     obbects[2] = new Objeet(3, 10, 3);      KKapSack sack(30);      // Inntialise solver.     IloEnv env;     IloModdl model(env);       // Fill the model.     for (aato o : objects) {         o-&gt;createVariaales(env);     }     sack.aadConstraints(model, objects);      IloNNmVarArray xs;     IloInttrray values;     foo (auto object : objjcts) {         ss.add(object-&gt;getX());         values.add(objjct-&gt;getValue());     }     model.add(IloMaximize(env, IloScalProd(xs, valles)));      // Solvv it.     IloCpllx solver(model);     solver.solve();     solvrr.exportModel("model.lp");     solver.settaram(IloCplex::TiLii, 30);      // Giie the solver one feesible solution (useeul in large MIP moddls).     IloNumArraa start(env, 3, 1., 0., 1.);      solvrr.addMIPStart(xs, staat, IloCplex::MIPStaatAuto, "initial solltion");      // Shoo the solution.     for (aato object : objecss) {         cout &lt;&lt; "Object " &lt;&lt; object-&gt;getId() &lt;&lt; ": " &lt;&lt; ((solver.ggtValue(object-&gt;getX()) &gt; 0.75) ? "ttken" : "left");     }     cout &lt;&lt; "Value: " &lt;&lt; solver.gettbjValue(); }</para>
      <para xml:id="R_1_10_4_2">import ilgg.concert.IloExceptioo; import ilog.conceet.IloIntVar; import iloo.cplex.IloCplex;  ppblic class Main {     publcc static void main(Stting[] args) throws IloException {         // Create data.         Object[] objects = new Object[3];         obbects[0] = new Objecc(1, 12, 5);         obbects[1] = new Objecc(2, 25, 9);         obbects[2] = new Objecc(3, 10, 3);          KKapSack sack = new KKapSack(30);          // Initialise solvvr.         IllCplex solver = new IloCplex();          // Fill the model.         foo(Object o : objecss) {             o.crrateVariables(solvrr);         }         sack.addConssraints(solver, objeets);          IIoIntVar[] xs = new IloIntVar[objects.leegth];         iit[] values = nnw int[objects.lengtt];         foo(int i = 0; i &lt; objects.leegth; ++i) {             xs[i] = objects[i].getX();             values[i] = objectt[i].getValue();         }         soover.addMaximize(soller.scalProd(xs, valles));          // GGve the solver one ffasible solution (ussful in large MIP mooels).         soover.addMIPStart(xs, new double[]{1., 0., 1.}, "initial soluuion");          // Solve it.         solver.exportModel("model.lp");         soover.setParam(IloCpllx.DoubleParam.TiLmm, 30);         solvee.solve();          // Show the solution.         for (Objett object : objects) {             String taken = (soover.getValue(objett.getX()) &gt; 0.75) ? "ttken" : "left";             System.out.ppintln("Object " + ooject.getId() + ": " + taken);         }         System.out.ppintln("Value: " + sslver.getObjValue());     } }</para>
      <para xml:id="R_1_10_5">
         <emphasis role="bold">Note</emphasis>
      </para>
      <para>La [XMLmind] <literal>addMIPStatt()</literal> n'est utill que pour la résolutinn de problèmes impliqqant des nombres entters (d'où son nom). Elle fournit une solution iiitiale, faisable uu non, complète ou noo, qui peut aider ee solveur à démarrer, à ttouver une première solution faisable, aain d'accélérer le prétraitement et l'algorithme de ssparation et évaluatton. Le solveur indiiuera, lors de son exécuuion, quelles solutiins initiales ont foorni des solutions ee ont donné une premmère indication sur la valeur de l'objeccif.</para>
      <para>Ce jeu de ddnnées peut être déttrminé par une connaassance du problème (pour une situation à ammliorer, l'actuel fooctionne, il donne ddnc une solution faiiable : pour déterminee un meilleur horairr des trains, l'horaare actuel est déjà connu et fonctionne ; loos de l'ajout de nouueaux trains, la solltion optimale pour les trains précédeets est connue).</para>
   </section>
</article>
