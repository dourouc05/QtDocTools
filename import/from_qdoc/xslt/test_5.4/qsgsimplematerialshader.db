<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            version="5.1"
            xml:lang="en">
   <db:title>QSGSimpleMaterialShader Class</db:title>
   <db:classsynopsis xlink:href="qsgsimplematerialshader.db">
      <db:ooclass>
         <db:classname>QSGSimpleMaterialShader</db:classname>
      </db:ooclass>
      <db:classsynopsisinfo role="header">#include &lt;QSGSimpleMaterialShader&gt;</db:classsynopsisinfo>
      <db:classsynopsisinfo role="qmake"> QT += quick</db:classsynopsisinfo>
      <db:classsynopsisinfo role="inherits">
         <db:link xlink:href="qsgmaterialshader.db">QSGMaterialShader</db:link>
      </db:classsynopsisinfo>
      <db:methodsynopsis xlink:href="#attributes">
         <db:type>QList&lt;QByteArray&gt;</db:type>
         <db:methodname>attributes</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#resolveUniforms">
         <db:void/>
         <db:methodname>resolveUniforms</db:methodname>
         <db:void/>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#uniformMatrixName">
         <db:type>char</db:type>
         <db:methodname>uniformMatrixName</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#uniformOpacityName">
         <db:type>char</db:type>
         <db:methodname>uniformOpacityName</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#updateState">
         <db:void/>
         <db:methodname>updateState</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  State  *  newState , const  State  *  oldState )</db:exceptionname>
      </db:methodsynopsis>
   </db:classsynopsis>
   <db:funcsynopsis xlink:href="#QSG_DECLARE_SIMPLE_COMPARABLE_SHADER">
      <db:funcsynopsisinfo>macro</db:funcsynopsisinfo>
      <db:funcprototype>
         <db:funcdef>
            <db:function>QSG_DECLARE_SIMPLE_COMPARABLE_SHADER</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:parameter>Shader</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:parameter>State</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#QSG_DECLARE_SIMPLE_SHADER">
      <db:funcsynopsisinfo>macro</db:funcsynopsisinfo>
      <db:funcprototype>
         <db:funcdef>
            <db:function>QSG_DECLARE_SIMPLE_SHADER</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:parameter>Shader</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:parameter>State</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:section xml:id="details">
      <db:title>Detailed Description</db:title>
      <db:para>The <db:code><db:link xlink:href="qsgsimplematerialshader.db">QSGSimpleMaterialShader</db:link></db:code> class provides a convenient way of building custom materials for the scene graph.</db:para>
      <db:para>Where the <db:code><db:link xlink:href="qsgmaterial.db">QSGMaterial</db:link></db:code> and <db:code><db:link xlink:href="qsgmaterialshader.db">QSGMaterialShader</db:link></db:code> API requires a bit of boilerplate code to create a functioning material, the <db:code><db:link xlink:href="qsgsimplematerialshader.db">QSGSimpleMaterialShader</db:link></db:code> tries to hide some of this through the use of templates.</db:para>
      <db:para>
         <db:code><db:link xlink:href="qsgmaterialshader.db#vertexShader">QSGSimpleMaterialShader::vertexShader</db:link>()</db:code> and <db:code><db:link xlink:href="qsgmaterialshader.db#fragmentShader">QSGSimpleMaterialShader::fragmentShader</db:link>()</db:code> are used to specify the actual shader source code. The names of the vertex attributes should be listed in the <db:code><db:link xlink:href="qsgsimplematerialshader.db#attributes">QSGSimpleMaterialShader::attributes</db:link>()</db:code>
      </db:para>
      <db:para>
         <db:code><db:link xlink:href="qsgsimplematerialshader.db#updateState">QSGSimpleMaterialShader::updateState</db:link>()</db:code> is used to push the material state to the OpenGL shader program.</db:para>
      <db:para>The actual OpenGL shader program is accessible through the <db:code><db:link xlink:href="qsgmaterialshader.db#program">QSGSimpleMaterialShader::program</db:link>()</db:code> function.</db:para>
      <db:para>Each <db:code><db:link xlink:href="qsgsimplematerialshader.db">QSGSimpleMaterialShader</db:link></db:code> implementation operates on a unique state struct. The state struct must be declared using the <db:code>QSG_DECLARE_SIMPLE_SHADER</db:code> macro.</db:para>
      <db:para>Here is a simple example of a custom solid-color:</db:para>
      <db:programlisting>struct Color
{
    float r, g, b, a;
};

class MinimalShader : publicQSGSimpleMaterialShader&lt;Color&gt;
{
    QSG_DECLARE_SIMPLE_SHADER(MinimalShader, Color)
public:

    constchar*vertexShader() const {
        return"attribute highp vec4 vertex;               \n""uniform highp mat4 qt_Matrix;              \n""void main() {                              \n""    gl_Position = qt_Matrix * vertex;      \n""}";
    }

    constchar*fragmentShader() const {
        return"uniform lowp float qt_Opacity;             \n""uniform lowp vec4 color;                   \n""void main() {                              \n""    gl_FragColor = color * qt_Opacity;     \n""}";
    }

    QList&lt;QByteArray&gt; attributes() const {
        returnQList&lt;QByteArray&gt;() &lt;&lt;"vertex";
    }

    void updateState(const Color *color,const Color *) {
        program()-&gt;setUniformValue("color", color-&gt;r, color-&gt;g, color-&gt;b, color-&gt;a);
    }

};</db:programlisting>
      <db:para>Instances of materials using this shader can be created using the createMaterial() function which will be defined by the <db:code><db:link xlink:href="qsgsimplematerialshader.db#QSG_DECLARE_SIMPLE_SHADER">QSG_DECLARE_SIMPLE_SHADER</db:link></db:code> macro.</db:para>
      <db:programlisting>QSGSimpleMaterial&lt;Color&gt;*material = MinimalShader::createMaterial();
    material-&gt;state()-&gt;r =1;
    material-&gt;state()-&gt;g =0;
    material-&gt;state()-&gt;b =0;
    material-&gt;state()-&gt;a =1;

    node-&gt;setMaterial(material);</db:programlisting>
      <db:para>The scene graph will often try to find materials that have the same or at least similar state so that these can be batched together inside the renderer, which gives better performance. To specify sortable material states, use <db:code><db:link xlink:href="qsgsimplematerialshader.db#QSG_DECLARE_SIMPLE_COMPARABLE_SHADER">QSG_DECLARE_SIMPLE_COMPARABLE_SHADER</db:link></db:code> instead of <db:code><db:link xlink:href="qsgsimplematerialshader.db#QSG_DECLARE_SIMPLE_SHADER">QSG_DECLARE_SIMPLE_SHADER</db:link></db:code>. The state struct must then also define the function:</db:para>
      <db:programlisting>int compare(const Type *other) const;</db:programlisting>
      <db:warning>
         <db:para> The <db:code><db:link xlink:href="qsgsimplematerialshader.db">QSGSimpleMaterialShader</db:link></db:code> relies on template instantiation to create a <db:code><db:link xlink:href="qsgmaterialtype.db">QSGMaterialType</db:link></db:code> which the scene graph renderer internally uses to identify this shader. For this reason, the unique <db:code><db:link xlink:href="qsgsimplematerialshader.db">QSGSimpleMaterialShader</db:link></db:code> implementation must be instantiated with a unique C++ type.</db:para>
      </db:warning>
      <db:note>
         <db:para>All classes with QSG prefix should be used solely on the scene graph's rendering thread. See <db:link xlink:href="qtquick-visualcanvas-scenegraph.db#scene-graph-and-rendering">Scene Graph and Rendering</db:link> for more information.</db:para>
      </db:note>
      <db:section>
         <db:title>See Also</db:title>
         <db:simplelist type="vert">
            <db:member>
               <db:link xlink:href="qtquick-scenegraph-simplematerial-example.db">Scene Graph - Simple Material</db:link>
            </db:member>
         </db:simplelist>
      </db:section>
   </db:section>
   <db:section xml:id="func">
      <db:title>Member Function Documentation</db:title>
      <db:section xml:id="attributes">
         <db:title>[pure virtual] <db:link xlink:href="qlist.db">QList</db:link><db:link xlink:href="qbytearray.db">QByteArray</db:link></db:title>
         <db:para>Returns a list of names, declaring the vertex attributes in the vertex shader.</db:para>
      </db:section>
      <db:section xml:id="resolveUniforms">
         <db:title>[virtual] void QSGSimpleMaterialShader::resolveUniforms()</db:title>
         <db:para>Reimplement this function to resolve the location of named uniforms in the shader program.</db:para>
         <db:para>This function is called when the material shader is initialized.</db:para>
      </db:section>
      <db:section xml:id="uniformMatrixName">
         <db:title>const char * QSGSimpleMaterialShader::uniformMatrixName() const</db:title>
         <db:para>Reimplement this function to give a different name to the uniform for item transformation. The default value is <db:code>qt_Matrix</db:code>.</db:para>
      </db:section>
      <db:section xml:id="uniformOpacityName">
         <db:title>const char * QSGSimpleMaterialShader::uniformOpacityName() const</db:title>
         <db:para>Reimplement this function to give a different name to the uniform for item opacity. The default value is <db:code>qt_Opacity</db:code>.</db:para>
         <db:para>If the shader program does not implement the item opacity, the implemented function should return a null pointer.</db:para>
      </db:section>
      <db:section xml:id="updateState">
         <db:title>[pure virtual] void QSGSimpleMaterialShader::updateState(const <db:link xlink:href="qml-qtquick-state.db">State</db:link><db:link xlink:href="qml-qtquick-state.db">State</db:link></db:title>
         <db:para>Called whenever the state of this shader should be updated from <db:emphasis>oldState</db:emphasis> to <db:emphasis>newState</db:emphasis>, typical for each new set of geometries being drawn.</db:para>
         <db:para>Both the old and the new state are passed in so that the implementation can compare and minimize the state changes when applicable.</db:para>
      </db:section>
   </db:section>
   <db:section xml:id="macros">
      <db:title>Macro Documentation</db:title>
      <db:section xml:id="QSG_DECLARE_SIMPLE_COMPARABLE_SHADER">
         <db:title>QSG_DECLARE_SIMPLE_COMPARABLE_SHADER( Shader, State)</db:title>
         <db:para>This macro is used to declare a <db:code><db:link xlink:href="qsgmaterialtype.db">QSGMaterialType</db:link></db:code> and a <db:code>createMaterial()</db:code> function for <db:emphasis>Shader</db:emphasis> with the given <db:emphasis>State</db:emphasis>, where the <db:emphasis>State</db:emphasis> class must define a compare function on the form:</db:para>
         <db:programlisting>int compare(const State *other) const;</db:programlisting>
      </db:section>
      <db:section xml:id="QSG_DECLARE_SIMPLE_SHADER">
         <db:title>QSG_DECLARE_SIMPLE_SHADER( Shader, State)</db:title>
         <db:para>This macro is used to declare a <db:code><db:link xlink:href="qsgmaterialtype.db">QSGMaterialType</db:link></db:code> and a <db:code>createMaterial()</db:code> function for <db:emphasis>Shader</db:emphasis> with the given <db:emphasis>State</db:emphasis>.</db:para>
      </db:section>
   </db:section>
</db:article>
