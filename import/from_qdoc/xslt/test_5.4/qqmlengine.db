<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            version="5.1"
            xml:lang="en">
   <db:title>QQmlEngine Class</db:title>
   <db:classsynopsis xlink:href="qqmlengine.db">
      <db:ooclass>
         <db:classname>QQmlEngine</db:classname>
      </db:ooclass>
      <db:classsynopsisinfo role="header">#include
                                                  &lt;QQmlEngine&gt;</db:classsynopsisinfo>
      <db:classsynopsisinfo role="qmake"> QT +=
                                                qml</db:classsynopsisinfo>
      <db:classsynopsisinfo role="inherits">
         <db:link xlink:href="qjsengine.db">QJSEngine</db:link>
      </db:classsynopsisinfo>
      <db:classsynopsisinfo role="inheritedBy">
         <db:link xlink:href="qqmlapplicationengine.db">QQmlApplicationEngine</db:link>
      </db:classsynopsisinfo>
      <db:classsynopsisinfo role="since"> Qt
                                                5.0</db:classsynopsisinfo>
      <db:fieldsynopsis xlink:href="#offlineStoragePath-prop">
         <db:modifier>(Qt property)</db:modifier>
         <db:type xlink:href="qtcore/qstring.html">QString</db:type>
         <db:varname>offlineStoragePath</db:varname>
      </db:fieldsynopsis>
      <db:constructorsynopsis xlink:href="#QQmlEngine">
         <db:methodname>QQmlEngine</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( QObject  *  parent  =
                                    0)</db:exceptionname>
      </db:constructorsynopsis>
      <db:destructorsynopsis xlink:href="#dtor.QQmlEngine">
         <db:methodname>~QQmlEngine</db:methodname>
         <db:void/>
      </db:destructorsynopsis>
      <db:methodsynopsis xlink:href="#addImageProvider">
         <db:void/>
         <db:methodname>addImageProvider</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString  &amp; 
                                        providerId ,  QQmlImageProviderBase  * 
                                        provider )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#addImportPath">
         <db:void/>
         <db:methodname>addImportPath</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString  &amp; 
                                    path )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#addNamedBundle">
         <db:type>bool</db:type>
         <db:methodname>addNamedBundle</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString  &amp;  name ,
                                    const  QString  &amp; 
                                        fileName )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#addPluginPath">
         <db:void/>
         <db:methodname>addPluginPath</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString  &amp; 
                                    path )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#baseUrl">
         <db:type xlink:href="qtcore/qurl.html">QUrl</db:type>
         <db:methodname>baseUrl</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#clearComponentCache">
         <db:void/>
         <db:methodname>clearComponentCache</db:methodname>
         <db:void/>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#contextForObject">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qqmlcontext.html">QQmlContext</db:type>
         <db:methodname>contextForObject</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QObject  * 
                                    object )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#event">
         <db:type>bool</db:type>
         <db:methodname>event</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( QEvent 
                                    *)</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#imageProvider">
         <db:type xlink:href="qqmlimageproviderbase.html">QQmlImageProviderBase</db:type>
         <db:methodname>imageProvider</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString  &amp; 
                                        providerId ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#importPathList">
         <db:type xlink:href="qtcore/qstringlist.html">QStringList</db:type>
         <db:methodname>importPathList</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#importPlugin">
         <db:type>bool</db:type>
         <db:methodname>importPlugin</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString 
                                        &amp;  filePath , const  QString  &amp; 
                                    uri ,  QList &lt; QQmlError &gt; * 
                                        errors )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#incubationController">
         <db:type xlink:href="qqmlincubationcontroller.html">QQmlIncubationController</db:type>
         <db:methodname>incubationController</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#networkAccessManager">
         <db:type>QNetworkAccessManager</db:type>
         <db:methodname>networkAccessManager</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#networkAccessManagerFactory">
         <db:type xlink:href="qqmlnetworkaccessmanagerfactory.html">QQmlNetworkAccessManagerFactory</db:type>
         <db:methodname>networkAccessManagerFactory</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#objectOwnership">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qqmlengine.html#ObjectOwnership-enum">ObjectOwnership</db:type>
         <db:methodname>objectOwnership</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( QObject  * 
                                    object )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#outputWarningsToStandardError">
         <db:type>bool</db:type>
         <db:methodname>outputWarningsToStandardError</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#pluginPathList">
         <db:type xlink:href="qtcore/qstringlist.html">QStringList</db:type>
         <db:methodname>pluginPathList</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#quit">
         <db:void/>
         <db:methodname>quit</db:methodname>
         <db:void/>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#removeImageProvider">
         <db:void/>
         <db:methodname>removeImageProvider</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString  &amp; 
                                        providerId )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#rootContext">
         <db:type xlink:href="qqmlcontext.html">QQmlContext</db:type>
         <db:methodname>rootContext</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setBaseUrl">
         <db:void/>
         <db:methodname>setBaseUrl</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QUrl 
                                        &amp;  url )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setContextForObject">
         <db:modifier>static</db:modifier>
         <db:void/>
         <db:methodname>setContextForObject</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( QObject  *  object ,
                                         QQmlContext  * 
                                        context )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setImportPathList">
         <db:void/>
         <db:methodname>setImportPathList</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QStringList  &amp; 
                                        paths )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setIncubationController">
         <db:void/>
         <db:methodname>setIncubationController</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( QQmlIncubationController  * 
                                        controller )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setNetworkAccessManagerFactory">
         <db:void/>
         <db:methodname>setNetworkAccessManagerFactory</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( QQmlNetworkAccessManagerFactory 
                                        *  factory )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setObjectOwnership">
         <db:modifier>static</db:modifier>
         <db:void/>
         <db:methodname>setObjectOwnership</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( QObject  *  object ,
                                         ObjectOwnership 
                                        ownership )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setOutputWarningsToStandardError">
         <db:void/>
         <db:methodname>setOutputWarningsToStandardError</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( bool 
                                    enabled )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setPluginPathList">
         <db:void/>
         <db:methodname>setPluginPathList</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QStringList  &amp; 
                                        paths )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#trimComponentCache">
         <db:void/>
         <db:methodname>trimComponentCache</db:methodname>
         <db:void/>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#warnings">
         <db:void/>
         <db:methodname>warnings</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QList &lt; QQmlError &gt; &amp; 
                                        warnings )</db:exceptionname>
      </db:methodsynopsis>
   </db:classsynopsis>
   <db:funcsynopsis xlink:href="#QML_DECLARE_TYPE">
      <db:funcsynopsisinfo>macro</db:funcsynopsisinfo>
      <db:funcprototype>
         <db:funcdef>
            <db:function>QML_DECLARE_TYPE</db:function>
         </db:funcdef>
         <db:void/>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#QML_DECLARE_TYPEINFO">
      <db:funcsynopsisinfo>macro</db:funcsynopsisinfo>
      <db:funcprototype>
         <db:funcdef>
            <db:function>QML_DECLARE_TYPEINFO</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:parameter>Type</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:parameter>Flags</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlAttachedPropertiesObject">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qtcore/qobject.html#QObject">QObject</db:type>
            <db:function>qmlAttachedPropertiesObject</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QObject&lt;bool&gt;</db:type>
            <db:parameter>attachee</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>bool</db:type>
            <db:parameter>create</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlClearTypeRegistrations">
      <db:funcprototype>
         <db:funcdef>
            <db:type>void</db:type>
            <db:function>qmlClearTypeRegistrations</db:function>
         </db:funcdef>
         <db:void/>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlContext">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qqmlcontext.html">QQmlContext</db:type>
            <db:function>qmlContext</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qtcore/qobject.html#QObject">QObject</db:type>
            <db:parameter>object</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlEngine">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qqmlengine.html#QQmlEngine">QQmlEngine</db:type>
            <db:function>qmlEngine</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qtcore/qobject.html#QObject">QObject</db:type>
            <db:parameter>object</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlProtectModule">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>qmlProtectModule</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;int&gt;</db:type>
            <db:parameter>uri</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int</db:type>
            <db:parameter>majVersion</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlRegisterExtendedType">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qmlRegisterExtendedType</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;int&lt;int&lt;char&gt;&gt;&gt;</db:type>
            <db:parameter>uri</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;int&lt;char&gt;&gt;</db:type>
            <db:parameter>versionMajor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;char&gt;</db:type>
            <db:parameter>versionMinor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>qmlName</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlRegisterExtendedUncreatableType">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qmlRegisterExtendedUncreatableType</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;int&lt;int&lt;char&lt;QString&gt;&gt;&gt;&gt;</db:type>
            <db:parameter>uri</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;int&lt;char&lt;QString&gt;&gt;&gt;</db:type>
            <db:parameter>versionMajor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;char&lt;QString&gt;&gt;</db:type>
            <db:parameter>versionMinor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;QString&gt;</db:type>
            <db:parameter>qmlName</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qtcore/qstring.html">QString</db:type>
            <db:parameter>reason</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlRegisterInterface">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qmlRegisterInterface</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>typeName</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlRegisterRevision">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qmlRegisterRevision</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;int&lt;int&gt;&gt;</db:type>
            <db:parameter>uri</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;int&gt;</db:type>
            <db:parameter>versionMajor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int</db:type>
            <db:parameter>versionMinor</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlRegisterSingletonType">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qmlRegisterSingletonType</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;int&lt;int&lt;char&lt;QJSValue&lt;QQmlEngine&lt;QJSEngine&gt;&gt;&gt;&gt;&gt;&gt;</db:type>
            <db:parameter>uri</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;int&lt;char&lt;QJSValue&lt;QQmlEngine&lt;QJSEngine&gt;&gt;&gt;&gt;&gt;</db:type>
            <db:parameter>versionMajor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;char&lt;QJSValue&lt;QQmlEngine&lt;QJSEngine&gt;&gt;&gt;&gt;</db:type>
            <db:parameter>versionMinor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;QJSValue&lt;QQmlEngine&lt;QJSEngine&gt;&gt;&gt;</db:type>
            <db:parameter>typeName</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QJSValue&lt;QQmlEngine&lt;QJSEngine&gt;&gt;</db:type>
            <db:parameter>callback</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qjsengine.html#QJSEngine">QJSEngine</db:type>
            <db:parameter>callback</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlRegisterSingletonType-2">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qmlRegisterSingletonType</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;int&lt;int&lt;char&lt;QObject&lt;QQmlEngine&lt;QJSEngine&gt;&gt;&gt;&gt;&gt;&gt;</db:type>
            <db:parameter>uri</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;int&lt;char&lt;QObject&lt;QQmlEngine&lt;QJSEngine&gt;&gt;&gt;&gt;&gt;</db:type>
            <db:parameter>versionMajor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;char&lt;QObject&lt;QQmlEngine&lt;QJSEngine&gt;&gt;&gt;&gt;</db:type>
            <db:parameter>versionMinor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;QObject&lt;QQmlEngine&lt;QJSEngine&gt;&gt;&gt;</db:type>
            <db:parameter>typeName</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QObject&lt;QQmlEngine&lt;QJSEngine&gt;&gt;</db:type>
            <db:parameter>callback</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qjsengine.html#QJSEngine">QJSEngine</db:type>
            <db:parameter>callback</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlRegisterSingletonType-3">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qmlRegisterSingletonType</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QUrl&lt;char&lt;int&lt;int&lt;char&gt;&gt;&gt;&gt;</db:type>
            <db:parameter>url</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;int&lt;int&lt;char&gt;&gt;&gt;</db:type>
            <db:parameter>uri</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;int&lt;char&gt;&gt;</db:type>
            <db:parameter>versionMajor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;char&gt;</db:type>
            <db:parameter>versionMinor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>qmlName</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlRegisterType">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qmlRegisterType</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;int&lt;int&lt;char&gt;&gt;&gt;</db:type>
            <db:parameter>uri</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;int&lt;char&gt;&gt;</db:type>
            <db:parameter>versionMajor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;char&gt;</db:type>
            <db:parameter>versionMinor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>qmlName</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlRegisterType-3">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qmlRegisterType</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QUrl&lt;char&lt;int&lt;int&lt;char&gt;&gt;&gt;&gt;</db:type>
            <db:parameter>url</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;int&lt;int&lt;char&gt;&gt;&gt;</db:type>
            <db:parameter>uri</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;int&lt;char&gt;&gt;</db:type>
            <db:parameter>versionMajor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;char&gt;</db:type>
            <db:parameter>versionMinor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>qmlName</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlRegisterType-4">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qmlRegisterType</db:function>
         </db:funcdef>
         <db:void/>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlRegisterTypeNotAvailable">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qmlRegisterTypeNotAvailable</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;int&lt;int&lt;char&lt;QString&gt;&gt;&gt;&gt;</db:type>
            <db:parameter>uri</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;int&lt;char&lt;QString&gt;&gt;&gt;</db:type>
            <db:parameter>versionMajor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;char&lt;QString&gt;&gt;</db:type>
            <db:parameter>versionMinor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;QString&gt;</db:type>
            <db:parameter>qmlName</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qtcore/qstring.html">QString</db:type>
            <db:parameter>message</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qmlRegisterUncreatableType">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qmlRegisterUncreatableType</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;int&lt;int&lt;char&lt;QString&gt;&gt;&gt;&gt;</db:type>
            <db:parameter>uri</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;int&lt;char&lt;QString&gt;&gt;&gt;</db:type>
            <db:parameter>versionMajor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;char&lt;QString&gt;&gt;</db:type>
            <db:parameter>versionMinor</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;QString&gt;</db:type>
            <db:parameter>qmlName</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qtcore/qstring.html">QString</db:type>
            <db:parameter>message</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:section xml:id="details">
      <db:title>Detailed Description</db:title>
      <db:para>The <db:code><db:link xlink:href="qqmlengine.db">QQmlEngine</db:link></db:code> class
                                    provides an environment for instantiating QML
                                    components.</db:para>
      <db:para>Each QML component is instantiated in a <db:code><db:link xlink:href="qqmlcontext.db">QQmlContext</db:link></db:code>. <db:code><db:link xlink:href="qqmlcontext.db">QQmlContext</db:link></db:code>'s are essential
                                    for passing data to QML components. In QML, contexts are
                                    arranged hierarchically and this hierarchy is managed by the
                                        <db:code><db:link xlink:href="qqmlengine.db">QQmlEngine</db:link></db:code>.</db:para>
      <db:para>Prior to creating any QML components, an application must
                                    have created a <db:code><db:link xlink:href="qqmlengine.db">QQmlEngine</db:link></db:code> to gain access to a QML context. The
                                    following example shows how to create a simple Text
                                    item.</db:para>
      <db:programlisting>QQmlEngine engine; QQmlComponent component(&amp;engine);
                                        component.setData("import
                                        QtQuick 2.0\nText { text: \"Hello world!\"
                                        }",QUrl()); QQuickItem*item = qobject_cast&lt;QQuickItem*&gt;(component.create()); //add item to view, etc...</db:programlisting>
      <db:para>In this case, the Text item will be created in the engine's
                                        <db:link xlink:href="qqmlengine.db#rootContext">root
                                        context</db:link>.</db:para>
      <db:para>Note that the <db:link xlink:href="qtquick-porting-qt5.db#qt-quick-1">Qt Quick
                                        1</db:link> version is called QDeclarativeEngine.</db:para>
      <db:section>
         <db:title>See Also</db:title>
         <db:simplelist type="vert">
            <db:member>
               <db:code><db:link xlink:href="qqmlcomponent.db">QQmlComponent</db:link></db:code>
            </db:member>
            <db:member>
               <db:code><db:link xlink:href="qqmlcontext.db">QQmlContext</db:link></db:code>
            </db:member>
         </db:simplelist>
      </db:section>
   </db:section>
   <db:section xml:id="types">
      <db:title>Member Type Documentation</db:title>
      <db:section xml:id="ObjectOwnership-enum">
         <db:title>enum QQmlEngine::ObjectOwnership</db:title>
         <db:para>ObjectOwnership controls whether or not QML automatically
                                    destroys the <db:code><db:link xlink:href="qobject.db">QObject</db:link></db:code>
                                    when the corresponding JavaScript object is garbage collected by
                                    the engine. The two ownership options are:</db:para>
         <db:informaltable>
            <db:tbody>
               <db:tr>
                  <db:th>
                     <db:para>Constant</db:para>
                  </db:th>
                  <db:th>
                     <db:para>Value</db:para>
                  </db:th>
                  <db:th>
                     <db:para>Description</db:para>
                  </db:th>
               </db:tr>
               <db:tr>
                  <db:td>
                     <db:para>
                        <db:code>QQmlEngine::CppOwnership</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>
                        <db:code>0</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>The object is owned by C++
                                                  code and QML will never delete it. The JavaScript
                                                  destroy() method cannot be used on these objects.
                                                  This option is similar to <db:code><db:link xlink:href="qscriptengine.db#ValueOwnership-enum">QScriptEngine::QtOwnership</db:link></db:code>.</db:para>
                  </db:td>
               </db:tr>
               <db:tr>
                  <db:td>
                     <db:para>
                        <db:code>QQmlEngine::JavaScriptOwnership</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>
                        <db:code>1</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>The object is owned by
                                                  JavaScript. When the object is returned to QML as
                                                  the return value of a method call, QML will track
                                                  it and delete it if there are no remaining
                                                  JavaScript references to it and it has no <db:code><db:link xlink:href="qobject.db#parent">QObject::parent</db:link>()</db:code>. An object tracked by
                                                  one <db:code><db:link xlink:href="qqmlengine.db">QQmlEngine</db:link></db:code> will be deleted during that
                                                  <db:code><db:link xlink:href="qqmlengine.db">QQmlEngine</db:link></db:code>'s destructor. Thus,
                                                  JavaScript references between objects with
                                                  JavaScriptOwnership from two different engines
                                                  will not be valid if one of these engines is
                                                  deleted. This option is similar to <db:code><db:link xlink:href="qscriptengine.db#ValueOwnership-enum">QScriptEngine::ScriptOwnership</db:link></db:code>.</db:para>
                  </db:td>
               </db:tr>
            </db:tbody>
         </db:informaltable>
         <db:para>Generally an application doesn't need to set an object's
                                    ownership explicitly. QML uses a heuristic to set the default
                                    ownership. By default, an object that is created by QML has
                                    JavaScriptOwnership. The exception to this are the root objects
                                    created by calling <db:code><db:link xlink:href="qqmlcomponent.db#create">QQmlComponent::create</db:link>()</db:code> or <db:code><db:link xlink:href="qqmlcomponent.db#beginCreate">QQmlComponent::beginCreate</db:link>()</db:code>, which have
                                    CppOwnership by default. The ownership of these root-level
                                    objects is considered to have been transferred to the C++
                                    caller.</db:para>
         <db:para>Objects not-created by QML have CppOwnership by default. The
                                    exception to this are objects returned from C++ method calls;
                                    their ownership will be set to JavaScriptOwnership. This applies
                                    only to explicit invocations of <db:code><db:link xlink:href="qobject.db#Q_INVOKABLE">Q_INVOKABLE</db:link></db:code>
                                    methods or slots, but not to property getter
                                    invocations.</db:para>
         <db:para>Calling <db:code><db:link xlink:href="qqmlengine.db#setObjectOwnership">setObjectOwnership</db:link>()</db:code> overrides the default
                                    ownership heuristic used by QML.</db:para>
      </db:section>
   </db:section>
   <db:section xml:id="prop">
      <db:title>Property Documentation</db:title>
      <db:section xml:id="offlineStoragePath-prop">
         <db:title>offlineStoragePath : <db:link xlink:href="qstring.db">QString</db:link></db:title>
         <db:para>This property holds the directory for storing offline user
                                    data.</db:para>
         <db:para>Returns the directory where SQL and other offline storage is
                                    placed.</db:para>
         <db:para>QQuickWebView and the SQL databases created with
                                    openDatabase() are stored here.</db:para>
         <db:para>The default is QML/OfflineStorage in the platform-standard
                                    user application data directory.</db:para>
         <db:para>Note that the path may not currently exist on the
                                    filesystem, so callers wanting to <db:emphasis>create</db:emphasis> new
                                    files at this location should create it first - see <db:code><db:link xlink:href="qdir.db#mkpath">QDir::mkpath</db:link>()</db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">Access functions:</db:emphasis>
         </db:para>
         <db:informaltable>
            <db:tbody>
               <db:tr>
                  <db:td>
                     <db:para>
                                                  QString </db:para>
                  </db:td>
                  <db:td>
                     <db:para>
                        <db:emphasis role="bold">offlineStoragePath</db:emphasis>()
                                                  const</db:para>
                  </db:td>
               </db:tr>
               <db:tr>
                  <db:td>
                     <db:para>
                                                  void </db:para>
                  </db:td>
                  <db:td>
                     <db:para>
                        <db:emphasis role="bold">setOfflineStoragePath</db:emphasis>(const
                                                  QString &amp;<db:emphasis> dir</db:emphasis>)</db:para>
                  </db:td>
               </db:tr>
            </db:tbody>
         </db:informaltable>
      </db:section>
   </db:section>
   <db:section xml:id="func">
      <db:title>Member Function Documentation</db:title>
      <db:section xml:id="QQmlEngine">
         <db:title>QQmlEngine::QQmlEngine(<db:link xlink:href="qobject.db#QObject">QObject</db:link></db:title>
         <db:para>Create a new <db:code><db:link xlink:href="qqmlengine.db">QQmlEngine</db:link></db:code> with the given
                                    <db:emphasis>parent</db:emphasis>.</db:para>
      </db:section>
      <db:section xml:id="dtor.QQmlEngine">
         <db:title>[virtual] QQmlEngine::~QQmlEngine()</db:title>
         <db:para>Destroys the <db:code><db:link xlink:href="qqmlengine.db">QQmlEngine</db:link></db:code>.</db:para>
         <db:para>Any <db:code><db:link xlink:href="qqmlcontext.db">QQmlContext</db:link></db:code>'s
                                    created on this engine will be invalidated, but not destroyed
                                    (unless they are parented to the <db:code><db:link xlink:href="qqmlengine.db">QQmlEngine</db:link></db:code> object).</db:para>
         <db:para>See <db:code><db:link xlink:href="qjsengine.db">QJSEngine</db:link></db:code> docs
                                    for details on cleaning up the JS engine.</db:para>
      </db:section>
      <db:section xml:id="addImageProvider">
         <db:title>void QQmlEngine::addImageProvider(const <db:link xlink:href="qstring.db">QString</db:link><db:link xlink:href="qqmlimageproviderbase.db">QQmlImageProviderBase</db:link></db:title>
         <db:para>Sets the <db:emphasis>provider</db:emphasis> to use for images
                                    requested via the <db:emphasis>image</db:emphasis>: url scheme, with host
                                        <db:emphasis>providerId</db:emphasis>. The <db:code><db:link xlink:href="qqmlengine.db">QQmlEngine</db:link></db:code> takes ownership
                                    of <db:emphasis>provider</db:emphasis>.</db:para>
         <db:para>Image providers enable support for pixmap and threaded image
                                    requests. See the <db:code><db:link xlink:href="qquickimageprovider.db">QQuickImageProvider</db:link></db:code> documentation for details on
                                    implementing and using image providers.</db:para>
         <db:para>All required image providers should be added to the engine
                                    before any QML sources files are loaded.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#removeImageProvider">removeImageProvider</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qquickimageprovider.db">QQuickImageProvider</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qqmlimageproviderbase.db">QQmlImageProviderBase</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="addImportPath">
         <db:title>void QQmlEngine::addImportPath(const <db:link xlink:href="qstring.db">QString</db:link></db:title>
         <db:para>Adds <db:emphasis>path</db:emphasis> as a directory where the engine
                                    searches for installed modules in a URL-based directory
                                    structure.</db:para>
         <db:para>The <db:emphasis>path</db:emphasis> may be a local filesystem
                                    directory, a <db:link xlink:href="resources.db">Qt
                                        Resource</db:link> path (<db:code>:/imports</db:code>), a
                                        <db:link xlink:href="resources.db">Qt Resource</db:link>
                                    url (<db:code>qrc:/imports</db:code>) or a URL.</db:para>
         <db:para>The <db:emphasis>path</db:emphasis> will be converted into canonical
                                    form before it is added to the import path list.</db:para>
         <db:para>The newly added <db:emphasis>path</db:emphasis> will be first in the
                                        <db:code><db:link xlink:href="qqmlengine.db#importPathList">importPathList</db:link>()</db:code>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#setImportPathList">setImportPathList</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:link xlink:href="qtqml-modules-topic.db">QML
                                    Modules</db:link>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="addNamedBundle">
         <db:title>bool QQmlEngine::addNamedBundle(const <db:link xlink:href="qstring.db">QString</db:link><db:link xlink:href="qstring.db">QString</db:link></db:title>
         <db:para/>
      </db:section>
      <db:section xml:id="addPluginPath">
         <db:title>void QQmlEngine::addPluginPath(const <db:link xlink:href="qstring.db">QString</db:link></db:title>
         <db:para>Adds <db:emphasis>path</db:emphasis> as a directory where the engine
                                    searches for native plugins for imported modules (referenced in
                                    the <db:code>qmldir</db:code> file).</db:para>
         <db:para>By default, the list contains only <db:code>.</db:code>,
                                    i.e. the engine searches in the directory of the
                                        <db:code>qmldir</db:code> file itself.</db:para>
         <db:para>The newly added <db:emphasis>path</db:emphasis> will be first in the
                                        <db:code><db:link xlink:href="qqmlengine.db#pluginPathList">pluginPathList</db:link>()</db:code>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#setPluginPathList">setPluginPathList</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="baseUrl">
         <db:title><db:link xlink:href="qurl.db">QUrl</db:link></db:title>
         <db:para>Return the base URL for this engine. The base URL is only
                                    used to resolve components when a relative URL is passed to the
                                        <db:code><db:link xlink:href="qqmlcomponent.db">QQmlComponent</db:link></db:code>
                                    constructor.</db:para>
         <db:para>If a base URL has not been explicitly set, this method
                                    returns the application's current working directory.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#setBaseUrl">setBaseUrl</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="clearComponentCache">
         <db:title>void QQmlEngine::clearComponentCache()</db:title>
         <db:para>Clears the engine's internal component cache.</db:para>
         <db:para>This function causes the property metadata of all components
                                    previously loaded by the engine to be destroyed. All previously
                                    loaded components and the property bindings for all extant
                                    objects created from those components will cease to
                                    function.</db:para>
         <db:para>This function returns the engine to a state where it does
                                    not contain any loaded component data. This may be useful in
                                    order to reload a smaller subset of the previous component set,
                                    or to load a new version of a previously loaded
                                    component.</db:para>
         <db:para>Once the component cache has been cleared, components must
                                    be loaded before any new objects can be created.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#trimComponentCache">trimComponentCache</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="contextForObject">
         <db:title>[static] <db:link xlink:href="qqmlcontext.db">QQmlContext</db:link><db:link xlink:href="qobject.db#QObject">QObject</db:link></db:title>
         <db:para>Returns the <db:code><db:link xlink:href="qqmlcontext.db">QQmlContext</db:link></db:code> for the <db:emphasis>object</db:emphasis>, or 0
                                    if no context has been set.</db:para>
         <db:para>When the <db:code><db:link xlink:href="qqmlengine.db">QQmlEngine</db:link></db:code>
                                    instantiates a <db:code><db:link xlink:href="qobject.db">QObject</db:link></db:code>, the context is set
                                    automatically.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#setContextForObject">setContextForObject</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#qmlContext">qmlContext</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#qmlEngine">qmlEngine</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="event">
         <db:title>[virtual protected] bool QQmlEngine::event(<db:link xlink:href="qevent.db">QEvent</db:link></db:title>
         <db:para/>
      </db:section>
      <db:section xml:id="imageProvider">
         <db:title><db:link xlink:href="qqmlimageproviderbase.db">QQmlImageProviderBase</db:link><db:link xlink:href="qstring.db">QString</db:link></db:title>
         <db:para>Returns the image provider set for
                                        <db:emphasis>providerId</db:emphasis>.</db:para>
         <db:para>Returns the provider if it was found; otherwise returns
                                    0.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qquickimageprovider.db">QQuickImageProvider</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="importPathList">
         <db:title><db:link xlink:href="qstringlist.db">QStringList</db:link></db:title>
         <db:para>Returns the list of directories where the engine searches
                                    for installed modules in a URL-based directory
                                    structure.</db:para>
         <db:para>For example, if
                                        <db:code>/opt/MyApp/lib/imports</db:code> is in the
                                    path, then QML that imports
                                        <db:code>com.mycompany.Feature</db:code> will cause the
                                        <db:code><db:link xlink:href="qqmlengine.db">QQmlEngine</db:link></db:code> to look
                                    in
                                        <db:code>/opt/MyApp/lib/imports/com/mycompany/Feature/</db:code>
                                    for the components provided by that module. A
                                        <db:code>qmldir</db:code> file is required for defining
                                    the type version mapping and possibly QML extensions
                                    plugins.</db:para>
         <db:para>By default, the list contains the directory of the
                                    application executable, paths specified in the
                                        <db:code>QML2_IMPORT_PATH</db:code> environment
                                    variable, and the builtin <db:code>Qml2ImportsPath</db:code>
                                    from <db:code><db:link xlink:href="qlibraryinfo.db">QLibraryInfo</db:link></db:code>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#addImportPath">addImportPath</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#setImportPathList">setImportPathList</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="importPlugin">
         <db:title>bool QQmlEngine::importPlugin(const <db:link xlink:href="qstring.db">QString</db:link><db:link xlink:href="qstring.db">QString</db:link><db:link xlink:href="qlist.db">QList</db:link><db:link xlink:href="qqmlerror.db">QQmlError</db:link></db:title>
         <db:para>Imports the plugin named <db:emphasis>filePath</db:emphasis> with the
                                        <db:emphasis>uri</db:emphasis> provided. Returns true if the plugin
                                    was successfully imported; otherwise returns false.</db:para>
         <db:para>On failure and if non-null, the <db:emphasis>errors</db:emphasis> list
                                    will have any errors which occurred prepended to it.</db:para>
         <db:para>The plugin has to be a Qt plugin which implements the
                                        <db:code><db:link xlink:href="qqmlextensionplugin.db">QQmlExtensionPlugin</db:link></db:code> interface.</db:para>
      </db:section>
      <db:section xml:id="incubationController">
         <db:title><db:link xlink:href="qqmlincubationcontroller.db">QQmlIncubationController</db:link></db:title>
         <db:para>Returns the currently set incubation controller, or 0 if no
                                    controller has been set.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#setIncubationController">setIncubationController</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="networkAccessManager">
         <db:title>QNetworkAccessManager * QQmlEngine::networkAccessManager() const</db:title>
         <db:para>Returns a common QNetworkAccessManager which can be used by
                                    any QML type instantiated by this engine.</db:para>
         <db:para>If a <db:code><db:link xlink:href="qqmlnetworkaccessmanagerfactory.db">QQmlNetworkAccessManagerFactory</db:link></db:code> has been set and a
                                    QNetworkAccessManager has not yet been created, the <db:code><db:link xlink:href="qqmlnetworkaccessmanagerfactory.db">QQmlNetworkAccessManagerFactory</db:link></db:code> will be used to
                                    create the QNetworkAccessManager; otherwise the returned
                                    QNetworkAccessManager will have no proxy or cache set.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#setNetworkAccessManagerFactory">setNetworkAccessManagerFactory</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="networkAccessManagerFactory">
         <db:title><db:link xlink:href="qqmlnetworkaccessmanagerfactory.db">QQmlNetworkAccessManagerFactory</db:link></db:title>
         <db:para>Returns the current <db:code><db:link xlink:href="qqmlnetworkaccessmanagerfactory.db">QQmlNetworkAccessManagerFactory</db:link></db:code>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#setNetworkAccessManagerFactory">setNetworkAccessManagerFactory</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="objectOwnership">
         <db:title>[static] <db:link xlink:href="qqmlengine.db#ObjectOwnership-enum">ObjectOwnership</db:link><db:link xlink:href="qobject.db#QObject">QObject</db:link></db:title>
         <db:para>Returns the ownership of <db:emphasis>object</db:emphasis>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#setObjectOwnership">setObjectOwnership</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="outputWarningsToStandardError">
         <db:title>bool QQmlEngine::outputWarningsToStandardError() const</db:title>
         <db:para>Returns true if warning messages will be output to stderr in
                                    addition to being emitted by the <db:code><db:link xlink:href="qqmlengine.db#warnings">warnings</db:link>()</db:code> signal,
                                    otherwise false.</db:para>
         <db:para>The default value is true.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#setOutputWarningsToStandardError">setOutputWarningsToStandardError</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="pluginPathList">
         <db:title><db:link xlink:href="qstringlist.db">QStringList</db:link></db:title>
         <db:para>Returns the list of directories where the engine searches
                                    for native plugins for imported modules (referenced in the
                                        <db:code>qmldir</db:code> file).</db:para>
         <db:para>By default, the list contains only <db:code>.</db:code>,
                                    i.e. the engine searches in the directory of the
                                        <db:code>qmldir</db:code> file itself.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#addPluginPath">addPluginPath</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#setPluginPathList">setPluginPathList</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="quit">
         <db:title>[signal] void QQmlEngine::quit()</db:title>
         <db:para>This signal is emitted when the QML loaded by the engine
                                    would like to quit.</db:para>
      </db:section>
      <db:section xml:id="removeImageProvider">
         <db:title>void QQmlEngine::removeImageProvider(const <db:link xlink:href="qstring.db">QString</db:link></db:title>
         <db:para>Removes the image provider for
                                    <db:emphasis>providerId</db:emphasis>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#addImageProvider">addImageProvider</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qquickimageprovider.db">QQuickImageProvider</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="rootContext">
         <db:title><db:link xlink:href="qqmlcontext.db">QQmlContext</db:link></db:title>
         <db:para>Returns the engine's root context.</db:para>
         <db:para>The root context is automatically created by the <db:code><db:link xlink:href="qqmlengine.db">QQmlEngine</db:link></db:code>. Data that should
                                    be available to all QML component instances instantiated by the
                                    engine should be put in the root context.</db:para>
         <db:para>Additional data that should only be available to a subset of
                                    component instances should be added to sub-contexts parented to
                                    the root context.</db:para>
      </db:section>
      <db:section xml:id="setBaseUrl">
         <db:title>void QQmlEngine::setBaseUrl(const <db:link xlink:href="qurl.db">QUrl</db:link></db:title>
         <db:para>Set the base URL for this engine to
                                    <db:emphasis>url</db:emphasis>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#baseUrl">baseUrl</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="setContextForObject">
         <db:title>[static] void QQmlEngine::setContextForObject(<db:link xlink:href="qobject.db#QObject">QObject</db:link><db:link xlink:href="qqmlcontext.db">QQmlContext</db:link></db:title>
         <db:para>Sets the <db:code><db:link xlink:href="qqmlcontext.db">QQmlContext</db:link></db:code> for the <db:emphasis>object</db:emphasis> to
                                        <db:emphasis>context</db:emphasis>. If the <db:emphasis>object</db:emphasis>
                                    already has a context, a warning is output, but the context is
                                    not changed.</db:para>
         <db:para>When the <db:code><db:link xlink:href="qqmlengine.db">QQmlEngine</db:link></db:code>
                                    instantiates a <db:code><db:link xlink:href="qobject.db">QObject</db:link></db:code>, the context is set
                                    automatically.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#contextForObject">contextForObject</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="setImportPathList">
         <db:title>void QQmlEngine::setImportPathList(const <db:link xlink:href="qstringlist.db">QStringList</db:link></db:title>
         <db:para>Sets <db:emphasis>paths</db:emphasis> as the list of directories where
                                    the engine searches for installed modules in a URL-based
                                    directory structure.</db:para>
         <db:para>By default, the list contains the directory of the
                                    application executable, paths specified in the
                                        <db:code>QML2_IMPORT_PATH</db:code> environment
                                    variable, and the builtin <db:code>Qml2ImportsPath</db:code>
                                    from <db:code><db:link xlink:href="qlibraryinfo.db">QLibraryInfo</db:link></db:code>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#importPathList">importPathList</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#addImportPath">addImportPath</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="setIncubationController">
         <db:title>void QQmlEngine::setIncubationController(<db:link xlink:href="qqmlincubationcontroller.db">QQmlIncubationController</db:link></db:title>
         <db:para>Sets the engine's incubation <db:emphasis>controller</db:emphasis>.
                                    The engine can only have one active controller and it does not
                                    take ownership of it.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#incubationController">incubationController</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="setNetworkAccessManagerFactory">
         <db:title>void QQmlEngine::setNetworkAccessManagerFactory(<db:link xlink:href="qqmlnetworkaccessmanagerfactory.db">QQmlNetworkAccessManagerFactory</db:link></db:title>
         <db:para>Sets the <db:emphasis>factory</db:emphasis> to use for creating
                                    QNetworkAccessManager(s).</db:para>
         <db:para>QNetworkAccessManager is used for all network access by QML.
                                    By implementing a factory it is possible to create custom
                                    QNetworkAccessManager with specialized caching, proxy and cookie
                                    support.</db:para>
         <db:para>The factory must be set before executing the
                                    engine.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#networkAccessManagerFactory">networkAccessManagerFactory</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="setObjectOwnership">
         <db:title>[static] void QQmlEngine::setObjectOwnership(<db:link xlink:href="qobject.db#QObject">QObject</db:link><db:link xlink:href="qqmlengine.db#ObjectOwnership-enum">ObjectOwnership</db:link></db:title>
         <db:para>Sets the <db:emphasis>ownership</db:emphasis> of
                                        <db:emphasis>object</db:emphasis>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#objectOwnership">objectOwnership</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="setOutputWarningsToStandardError">
         <db:title>void QQmlEngine::setOutputWarningsToStandardError(bool enabled)</db:title>
         <db:para>Set whether warning messages will be output to stderr to
                                        <db:emphasis>enabled</db:emphasis>.</db:para>
         <db:para>If <db:emphasis>enabled</db:emphasis> is true, any warning messages
                                    generated by QML will be output to stderr and emitted by the
                                        <db:code><db:link xlink:href="qqmlengine.db#warnings">warnings</db:link>()</db:code>
                                    signal. If <db:emphasis>enabled</db:emphasis> is false, on the <db:code><db:link xlink:href="qqmlengine.db#warnings">warnings</db:link>()</db:code> signal
                                    will be emitted. This allows applications to handle warning
                                    output themselves.</db:para>
         <db:para>The default value is true.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#outputWarningsToStandardError">outputWarningsToStandardError</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="setPluginPathList">
         <db:title>void QQmlEngine::setPluginPathList(const <db:link xlink:href="qstringlist.db">QStringList</db:link></db:title>
         <db:para>Sets the list of directories where the engine searches for
                                    native plugins for imported modules (referenced in the
                                        <db:code>qmldir</db:code> file) to
                                        <db:emphasis>paths</db:emphasis>.</db:para>
         <db:para>By default, the list contains only <db:code>.</db:code>,
                                    i.e. the engine searches in the directory of the
                                        <db:code>qmldir</db:code> file itself.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#pluginPathList">pluginPathList</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#addPluginPath">addPluginPath</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="trimComponentCache">
         <db:title>void QQmlEngine::trimComponentCache()</db:title>
         <db:para>Trims the engine's internal component cache.</db:para>
         <db:para>This function causes the property metadata of any loaded
                                    components which are not currently in use to be
                                    destroyed.</db:para>
         <db:para>A component is considered to be in use if there are any
                                    extant instances of the component itself, any instances of other
                                    components that use the component, or any objects instantiated
                                    by any of those components.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#clearComponentCache">clearComponentCache</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="warnings">
         <db:title>[signal] void QQmlEngine::warnings(const <db:link xlink:href="qlist.db">QList</db:link><db:link xlink:href="qqmlerror.db">QQmlError</db:link></db:title>
         <db:para>This signal is emitted when <db:emphasis>warnings</db:emphasis>
                                    messages are generated by QML.</db:para>
      </db:section>
   </db:section>
   <db:section xml:id="relnonmem">
      <db:title>Related Non-Members</db:title>
      <db:section xml:id="qmlAttachedPropertiesObject">
         <db:title><db:link xlink:href="qobject.db#QObject">QObject</db:link><db:link xlink:href="qobject.db#QObject">QObject</db:link></db:title>
         <db:para>The form of this template function is:</db:para>
         <db:programlisting>template&lt;typename T&gt;QObject*qmlAttachedPropertiesObject(constQObject*attachee, bool create =true)</db:programlisting>
         <db:para>This returns the attached object instance that has been
                                    attached to the specified <db:emphasis>attachee</db:emphasis> by the
                                    attaching type <db:emphasis>T</db:emphasis>.</db:para>
         <db:para>If <db:emphasis>create</db:emphasis> is true and type
                                        <db:emphasis>T</db:emphasis> is a valid attaching type, this creates
                                    and returns a new attached object instance.</db:para>
         <db:para>Returns 0 if type <db:emphasis>T</db:emphasis> is not a valid
                                    attaching type, or if <db:emphasis>create</db:emphasis> is false and no
                                    attachment object instance has previously been created for
                                        <db:emphasis>attachee</db:emphasis>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:link xlink:href="qtqml-cppintegration-definetypes.db#providing-attached-objects-for-data-annotations">Providing Attached Objects for Data
                                    Annotations</db:link>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="qmlClearTypeRegistrations">
         <db:title>void qmlClearTypeRegistrations()</db:title>
         <db:para>Clears all stored type registrations, such as those produced
                                    with <db:code><db:link xlink:href="qqmlengine.db#qmlRegisterType">qmlRegisterType</db:link>()</db:code>.</db:para>
         <db:para>Do not call this function while a <db:code><db:link xlink:href="qqmlengine.db">QQmlEngine</db:link></db:code> exists or
                                    behavior will be undefined. Any existing QQmlEngines must be
                                    deleted before calling this function. This function only affects
                                    the application global cache. Delete the <db:code><db:link xlink:href="qqmlengine.db">QQmlEngine</db:link></db:code> to clear all
                                    cached data relating to that engine.</db:para>
         <db:para>#include &lt;<db:code><db:link xlink:href="qtqml-qmlmodule.db">QtQml</db:link></db:code>&gt; to use this method.</db:para>
      </db:section>
      <db:section xml:id="qmlContext">
         <db:title><db:link xlink:href="qqmlcontext.db">QQmlContext</db:link><db:link xlink:href="qobject.db#QObject">QObject</db:link></db:title>
         <db:para>Returns the <db:code><db:link xlink:href="qqmlcontext.db">QQmlContext</db:link></db:code> associated with
                                        <db:emphasis>object</db:emphasis>, if any. This is equivalent to
                                        <db:code><db:link xlink:href="qqmlengine.db#contextForObject">QQmlEngine::contextForObject</db:link></db:code>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#contextForObject">contextForObject</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#qmlEngine">qmlEngine</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="qmlEngine">
         <db:title><db:link xlink:href="qqmlengine.db#QQmlEngine">QQmlEngine</db:link><db:link xlink:href="qobject.db#QObject">QObject</db:link></db:title>
         <db:para>Returns the <db:code><db:link xlink:href="qqmlengine.db">QQmlEngine</db:link></db:code> associated with
                                    <db:emphasis>object</db:emphasis>, if any. This is equivalent to <db:code><db:link xlink:href="qqmlengine.db#contextForObject">QQmlEngine::contextForObject</db:link></db:code>-&gt;engine(),
                                    but more efficient.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#contextForObject">contextForObject</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#qmlContext">qmlContext</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="qmlProtectModule">
         <db:title>bool qmlProtectModule(const char * uri, int majVersion)</db:title>
         <db:para>This function protects a module from having types registered
                                    into it. This can be used to prevent other plugins from
                                    injecting types into your module. It can also be a performance
                                    improvement, as it allows the engine to skip checking for the
                                    possibility of new types or plugins when this import is
                                    reached.</db:para>
         <db:para>The performance benefit is primarily seen when registering
                                    application specific types from within the application instead
                                    of through a plugin. Using qmlProtectModule allows the engine to
                                    skip checking for a plugin when that uri is imported, which can
                                    be noticeable with slow file systems.</db:para>
         <db:para>After this function is called, any attempt to register C++
                                    types into this uri, major version combination will lead to a
                                    runtime error. Call this after you have registered all of your
                                    types with the engine.</db:para>
         <db:para>#include &lt;<db:code><db:link xlink:href="qtqml-qmlmodule.db">QtQml</db:link></db:code>&gt; to use this function.</db:para>
         <db:para>Returns true if the module with <db:emphasis>uri</db:emphasis> as a
                                        <db:link xlink:href="qtqml-modules-identifiedmodules.db">module
                                        identifier</db:link> and <db:emphasis>majVersion</db:emphasis> as a
                                    major version number was found and locked, otherwise returns
                                    false. The module must contain exported types in order to be
                                    found.</db:para>
      </db:section>
      <db:section xml:id="qmlRegisterExtendedType">
         <db:title>int qmlRegisterExtendedType(const char * uri, int versionMajor, int versionMinor, const char * qmlName)</db:title>
         <db:para>This template function registers the C++ type and its
                                    extension object in the QML system with the name
                                        <db:emphasis>qmlName</db:emphasis> in the library imported from
                                        <db:emphasis>uri</db:emphasis> having version number composed from
                                        <db:emphasis>versionMajor</db:emphasis> and
                                        <db:emphasis>versionMinor</db:emphasis>. Properties not available in
                                    the main type will be searched for in the extension
                                    object.</db:para>
         <db:para>Returns the QML type id.</db:para>
         <db:para>#include &lt;<db:code><db:link xlink:href="qtqml-qmlmodule.db">QtQml</db:link></db:code>&gt; to use this function.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#qmlRegisterType">qmlRegisterType</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:link xlink:href="qtqml-cppintegration-definetypes.db#registering-extension-objects">Registering Extension Objects</db:link>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="qmlRegisterExtendedUncreatableType">
         <db:title>int qmlRegisterExtendedUncreatableType(const char * uri, int versionMajor, int versionMinor, const char * qmlName, const <db:link xlink:href="qstring.db">QString</db:link></db:title>
         <db:para>This template function registers the C++ type and its
                                    extension in the QML system with the name
                                        <db:emphasis>qmlName</db:emphasis> in the library imported from
                                        <db:emphasis>uri</db:emphasis> having version number composed from
                                        <db:emphasis>versionMajor</db:emphasis> and
                                        <db:emphasis>versionMinor</db:emphasis>.</db:para>
         <db:para>While the type has a name and a type, it cannot be created,
                                    and the given error <db:emphasis>message</db:emphasis> will result if
                                    creation is attempted.</db:para>
         <db:para>This is useful where the type is only intended for providing
                                    attached properties, enum values or an abstract base class with
                                    its extension.</db:para>
         <db:para>Returns the QML type id.</db:para>
         <db:para>#include &lt;<db:code><db:link xlink:href="qtqml-qmlmodule.db">QtQml</db:link></db:code>&gt; to use this function.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#qmlRegisterUncreatableType">qmlRegisterUncreatableType</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="qmlRegisterInterface">
         <db:title>int qmlRegisterInterface(const char * typeName)</db:title>
         <db:para>This template function registers the C++ type in the QML
                                    system under the name <db:emphasis>typeName</db:emphasis>.</db:para>
         <db:para>#include &lt;<db:code><db:link xlink:href="qtqml-qmlmodule.db">QtQml</db:link></db:code>&gt; to use this function.</db:para>
         <db:para>Returns the QML type id.</db:para>
      </db:section>
      <db:section xml:id="qmlRegisterRevision">
         <db:title>int qmlRegisterRevision(const char * uri, int versionMajor, int versionMinor)</db:title>
         <db:para>This template function registers the specified revision of a
                                    C++ type in the QML system with the library imported from
                                        <db:emphasis>uri</db:emphasis> having the version number composed from
                                        <db:emphasis>versionMajor</db:emphasis> and
                                        <db:emphasis>versionMinor</db:emphasis>.</db:para>
         <db:para>Returns the QML type id.</db:para>
         <db:programlisting>template&lt;typename T,int
                                        metaObjectRevision&gt;int
                                        qmlRegisterRevision(constchar*uri,int versionMajor,int
                                    versionMinor);</db:programlisting>
         <db:para>This function is typically used to register the revision of
                                    a base class to use for the specified version of the type (see
                                        <db:link xlink:href="qtqml-cppintegration-definetypes.db#type-revisions-and-versions">Type Revisions and Versions</db:link>).</db:para>
      </db:section>
      <db:section xml:id="qmlRegisterSingletonType">
         <db:title>int qmlRegisterSingletonType(const char * uri, int versionMajor, int versionMinor, const char * typeName, <db:link xlink:href="qjsvalue.db">QJSValue</db:link><db:link xlink:href="qqmlengine.db#QQmlEngine">QQmlEngine</db:link><db:link xlink:href="qjsengine.db#QJSEngine">QJSEngine</db:link></db:title>
         <db:para>This function may be used to register a singleton type
                                    provider <db:emphasis>callback</db:emphasis> in a particular
                                        <db:emphasis>uri</db:emphasis> and <db:emphasis>typeName</db:emphasis> with a
                                    version specified in <db:emphasis>versionMajor</db:emphasis> and
                                        <db:emphasis>versionMinor</db:emphasis>.</db:para>
         <db:para>Installing a singleton type allows developers to provide
                                    arbitrary functionality (methods and properties) to a client
                                    without requiring individual instances of the type to be
                                    instantiated by the client.</db:para>
         <db:para>A singleton type may be either a <db:code><db:link xlink:href="qobject.db">QObject</db:link></db:code> or a <db:code><db:link xlink:href="qjsvalue.db">QJSValue</db:link></db:code>. This function should
                                    be used to register a singleton type provider function which
                                    returns a <db:code><db:link xlink:href="qjsvalue.db">QJSValue</db:link></db:code> as a
                                    singleton type.</db:para>
         <db:para>
            <db:emphasis role="bold">NOTE:</db:emphasis>
            <db:code><db:link xlink:href="qjsvalue.db">QJSValue</db:link></db:code> singleton type
                                    properties will <db:emphasis role="bold">not</db:emphasis> trigger binding
                                    re-evaluation if changed.</db:para>
         <db:para>Usage:</db:para>
         <db:programlisting>// First, define
                                        the singleton type provider function (callback).staticQJSValue
                                        example_qjsvalue_singletontype_provider(QQmlEngine*engine,QJSEngine*scriptEngine) {
                                    Q_UNUSED(engine) staticint seedValue =5; QJSValue example = scriptEngine-&gt;newObject(); example.setProperty("someProperty", seedValue++); return example; } //
                                        Second, register the singleton type provider with QML by
                                        calling this function in an initialization
                                        function.#include
                                        &lt;QtQml&gt;... qmlRegisterSingletonType("Qt.example.qjsvalueApi",1,0,"MyApi",
                                    example_qjsvalue_singletontype_provider); ...</db:programlisting>
         <db:para>In order to use the registered singleton type in QML, you
                                    must import the singleton type.</db:para>
         <db:programlisting language="qml">import QtQuick 2.0 import
                                    Qt.example.qjsvalueApi 1.0 as ExampleApi Item { id: root
                                    property intsomeValue: ExampleApi.MyApi.someProperty }</db:programlisting>
      </db:section>
      <db:section xml:id="qmlRegisterSingletonType-2">
         <db:title>int qmlRegisterSingletonType(const char * uri, int versionMajor, int versionMinor, const char * typeName, <db:link xlink:href="qobject.db#QObject">QObject</db:link><db:link xlink:href="qqmlengine.db#QQmlEngine">QQmlEngine</db:link><db:link xlink:href="qjsengine.db#QJSEngine">QJSEngine</db:link></db:title>
         <db:para>This function may be used to register a singleton type
                                    provider <db:emphasis>callback</db:emphasis> in a particular
                                        <db:emphasis>uri</db:emphasis> and <db:emphasis>typeName</db:emphasis> with a
                                    version specified in <db:emphasis>versionMajor</db:emphasis> and
                                        <db:emphasis>versionMinor</db:emphasis>.</db:para>
         <db:para>Installing a singleton type into a uri allows developers to
                                    provide arbitrary functionality (methods and properties) to
                                    clients without requiring individual instances ot the type to be
                                    instantiated by the client.</db:para>
         <db:para>A singleton type may be either a <db:code><db:link xlink:href="qobject.db">QObject</db:link></db:code> or a <db:code><db:link xlink:href="qjsvalue.db">QJSValue</db:link></db:code>. This function should
                                    be used to register a singleton type provider function which
                                    returns a <db:code><db:link xlink:href="qobject.db">QObject</db:link></db:code> of
                                    the given type T as a singleton type.</db:para>
         <db:para>A <db:code><db:link xlink:href="qobject.db">QObject</db:link></db:code>
                                    singleton type may be referenced via the type name with which it
                                    was registered, and this typename may be used as the target in a
                                        <db:link xlink:href="qml-qtqml-connections.db">Connections</db:link> type or otherwise used as any other
                                    type id would. One exception to this is that a <db:code><db:link xlink:href="qobject.db">QObject</db:link></db:code> singleton type
                                    property may not be aliased (because the singleton type name
                                    does not identify an object within the same component as any
                                    other item).</db:para>
         <db:para>
            <db:emphasis role="bold">NOTE:</db:emphasis> A <db:code><db:link xlink:href="qobject.db">QObject</db:link></db:code> singleton type instance returned from a
                                    singleton type provider is owned by the QML engine. For this
                                    reason, the singleton type provider function should
                                        <db:emphasis role="bold">not</db:emphasis> be implemented as a singleton
                                    factory.</db:para>
         <db:para>Usage:</db:para>
         <db:programlisting>// First, define
                                        your QObject which provides the functionality.class
                                    SingletonTypeExample : publicQObject { Q_OBJECT Q_PROPERTY
                                        (int someProperty READ
                                    someProperty WRITE setSomeProperty NOTIFY somePropertyChanged)
                                        public:
                                        SingletonTypeExample(QObject* parent =0) : QObject(parent), m_someProperty(0) { } ~SingletonTypeExample() {}
                                    Q_INVOKABLE int
                                    doSomething() { setSomeProperty(5); return m_someProperty; } int someProperty() const { return m_someProperty; }
                                        void
                                        setSomeProperty(int val)
                                    { m_someProperty = val;
                                        emit
                                    somePropertyChanged(val); } signals: void somePropertyChanged(int newValue); private: int m_someProperty; }; // Second, define the singleton type
                                        provider function (callback).staticQObject*example_qobject_singletontype_provider(QQmlEngine*engine,QJSEngine*scriptEngine) {
                                    Q_UNUSED(engine) Q_UNUSED(scriptEngine) SingletonTypeExample
                                        *example =new
                                    SingletonTypeExample(); return example; } //
                                        Third, register the singleton type provider with QML by
                                        calling this function in an initialization
                                        function.#include
                                        &lt;QtQml&gt;... qmlRegisterSingletonType&lt;SingletonTypeExample&gt;("Qt.example.qobjectSingleton",1,0,"MyApi",
                                    example_qobject_singletontype_provider); ...</db:programlisting>
         <db:para>In order to use the registered singleton type in QML, you
                                    must import the singleton type.</db:para>
         <db:programlisting language="qml">import QtQuick 2.0 import
                                    Qt.example.qobjectSingleton 1.0 Item { id: root
                                    property intsomeValue: MyApi.somePropertyComponent.onCompleted: {
                                        someValue=MyApi.doSomething() } }</db:programlisting>
         <db:para>Since singleton types do not have an associated <db:code><db:link xlink:href="qqmlcontext.db">QQmlContext</db:link></db:code> object, then
                                    within the functions of a <db:code><db:link xlink:href="qobject.db">QObject</db:link></db:code>-derived type that is registered as a
                                    singleton type implementation the QML context and engine
                                    information is not available. The <db:code><db:link xlink:href="qqmlengine.db#contextForObject">QQmlEngine::contextForObject</db:link>()</db:code> function returns
                                    NULL when supplied with a pointer to an <db:code><db:link xlink:href="qobject.db">QObject</db:link></db:code> that implements
                                    a singleton type.</db:para>
         <db:para>Extending the above example:</db:para>
         <db:programlisting>class
                                    SingletonTypeExample : publicQObject { ...
                                    Q_INVOKABLE void
                                    doSomethingElse() { // QML
                                        Engine/Context information is not accessible
                                        here: Q_ASSERT(QQmlEngine::contextForObject(this) ==0);
                                        Q_ASSERT(qmlContext(this) ==0);
                                        Q_ASSERT(qmlEngine(this) ==0); } ...
                                    }</db:programlisting>
      </db:section>
      <db:section xml:id="qmlRegisterSingletonType-3">
         <db:title>int qmlRegisterSingletonType(const <db:link xlink:href="qurl.db">QUrl</db:link></db:title>
         <db:para>This function may be used to register a singleton type with
                                    the name <db:emphasis>qmlName</db:emphasis>, in the library imported from
                                        <db:emphasis>uri</db:emphasis> having the version number composed from
                                        <db:emphasis>versionMajor</db:emphasis> and
                                        <db:emphasis>versionMinor</db:emphasis>. The type is defined by the
                                    QML file located at <db:emphasis>url</db:emphasis>. The url must be an
                                    absolute URL, i.e. url.isRelative() == false.</db:para>
         <db:para>In addition the type's QML file must have pragma Singleton
                                    statement among its import statements.</db:para>
         <db:para>A singleton type may be referenced via the type name with
                                    which it was registered, and this typename may be used as the
                                    target in a <db:link xlink:href="qml-qtqml-connections.db">Connections</db:link> type or otherwise used as any other
                                    type id would. One exception to this is that a singleton type
                                    property may not be aliased (because the singleton type name
                                    does not identify an object within the same component as any
                                    other item).</db:para>
         <db:para>Usage: // First, define your QML singleton type which
                                    provides the functionality.</db:para>
         <db:programlisting language="qml">pragma Singleton import QtQuick 2.0 Item { property inttestProp1: 125 }</db:programlisting>
         <db:programlisting>// Second, register
                                        the QML singleton type by calling this function in an
                                        initialization function.#include
                                        &lt;QtQml&gt;...qmlRegisterSingletonType(QUrl("file:///absolute/path/SingletonType.qml"),"Qt.example.qobjectSingleton",1,0,"RegisteredSingleton");
                                        ...</db:programlisting>
         <db:para>In order to use the registered singleton type in QML, you
                                    must import the singleton type.</db:para>
         <db:programlisting language="qml">import QtQuick 2.0 import
                                    Qt.example.qobjectSingleton 1.0 Item { id: root
                                    property intsomeValue: RegisteredSingleton.testProp1 }</db:programlisting>
         <db:para>It is also possible to have QML singleton types registered
                                    without using the <db:link xlink:href="qqmlengine.db#qmlRegisterSingletonType">qmlRegisterSingletonType</db:link> function. That can be
                                    done by adding a pragma Singleton statement among the imports of
                                    the type's QML file. In addition the type must be defined in a
                                    qmldir file with a singleton keyword and the qmldir must be
                                    imported by the QML files using the singleton.</db:para>
      </db:section>
      <db:section xml:id="qmlRegisterType">
         <db:title>int qmlRegisterType(const char * uri, int versionMajor, int versionMinor, const char * qmlName)</db:title>
         <db:para>This template function registers the C++ type in the QML
                                    system with the name <db:emphasis>qmlName</db:emphasis>, in the library
                                    imported from <db:emphasis>uri</db:emphasis> having the version number
                                    composed from <db:emphasis>versionMajor</db:emphasis> and
                                        <db:emphasis>versionMinor</db:emphasis>.</db:para>
         <db:para>Returns the QML type id.</db:para>
         <db:para>There are two forms of this template function:</db:para>
         <db:programlisting>template&lt;typename T&gt;int
                                        qmlRegisterType(constchar*uri,int versionMajor,int versionMinor,constchar*qmlName); template&lt;typename T,int
                                        metaObjectRevision&gt;int
                                        qmlRegisterType(constchar*uri,int versionMajor,int versionMinor,constchar*qmlName);</db:programlisting>
         <db:para>The former is the standard form which registers the type
                                        <db:emphasis>T</db:emphasis> as a new type. The latter allows a
                                    particular revision of a class to be registered in a specified
                                    version (see <db:link xlink:href="qtqml-cppintegration-definetypes.db#type-revisions-and-versions">Type Revisions and Versions</db:link>).</db:para>
         <db:para>For example, this registers a C++ class
                                        <db:code>MySliderItem</db:code> as a QML type named
                                        <db:code>Slider</db:code> for version 1.0 of a type
                                    namespace called "com.mycompany.qmlcomponents":</db:para>
         <db:programlisting>#include
                                        &lt;QtQml&gt;... qmlRegisterType&lt;MySliderItem&gt;("com.mycompany.qmlcomponents",1,0,"Slider");</db:programlisting>
         <db:para>Once this is registered, the type can be used in QML by
                                    importing the specified type namespace and version
                                    number:</db:para>
         <db:programlisting language="qml">import com.mycompany.qmlcomponents 1.0
                                        Slider { // ... }</db:programlisting>
         <db:para>Note that it's perfectly reasonable for a library to
                                    register types to older versions than the actual version of the
                                    library. Indeed, it is normal for the new library to allow QML
                                    written to previous versions to continue to work, even if more
                                    advanced versions of some of its types are available.</db:para>
      </db:section>
      <db:section xml:id="qmlRegisterType-3">
         <db:title>int qmlRegisterType(const <db:link xlink:href="qurl.db">QUrl</db:link></db:title>
         <db:para>This function registers a type in the QML system with the
                                    name <db:emphasis>qmlName</db:emphasis>, in the library imported from
                                        <db:emphasis>uri</db:emphasis> having the version number composed from
                                        <db:emphasis>versionMajor</db:emphasis> and
                                        <db:emphasis>versionMinor</db:emphasis>. The type is defined by the
                                    QML file located at <db:emphasis>url</db:emphasis>. The url must be an
                                    absolute URL, i.e. url.isRelative() == false.</db:para>
         <db:para>Normally QML files can be loaded as types directly from
                                    other QML files, or using a qmldir file. This function allows
                                    registration of files to types from C++ code, such as when the
                                    type mapping needs to be procedurally determined at
                                    startup.</db:para>
         <db:para>#include &lt;<db:code><db:link xlink:href="qtqml-qmlmodule.db">QtQml</db:link></db:code>&gt; to use this function.</db:para>
         <db:para>Returns non-zero if the registration was sucessful.</db:para>
      </db:section>
      <db:section xml:id="qmlRegisterType-4">
         <db:title>int qmlRegisterType()</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>This template function registers the C++ type in the QML
                                    system. Instances of this type cannot be created from the QML
                                    system.</db:para>
         <db:para>#include &lt;<db:code><db:link xlink:href="qtqml-qmlmodule.db">QtQml</db:link></db:code>&gt; to use this function.</db:para>
         <db:para>Returns the QML type id.</db:para>
      </db:section>
      <db:section xml:id="qmlRegisterTypeNotAvailable">
         <db:title>int qmlRegisterTypeNotAvailable(const char * uri, int versionMajor, int versionMinor, const char * qmlName, const <db:link xlink:href="qstring.db">QString</db:link></db:title>
         <db:para>This function registers a type in the QML system with the
                                    name <db:emphasis>qmlName</db:emphasis>, in the type namespace imported
                                    from <db:emphasis>uri</db:emphasis> having the version number composed
                                    from <db:emphasis>versionMajor</db:emphasis> and
                                        <db:emphasis>versionMinor</db:emphasis>, but any attempt to
                                    instantiate the type will produce the given error
                                        <db:emphasis>message</db:emphasis>.</db:para>
         <db:para>Normally, the types exported by a plugin should be fixed.
                                    However, if a C++ type is not available, you should at least
                                    "reserve" the QML type name, and give the user of the
                                    unavailable type a meaningful error message.</db:para>
         <db:para>Returns the QML type id.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>#ifdef
                                        NO_GAMES_ALLOWED
                                        qmlRegisterTypeNotAvailable("MinehuntCore",0,1,"Game","Get back to work,
                                        slacker!"); #else qmlRegisterType&lt;MinehuntGame&gt;("MinehuntCore",0,1,"Game"); #endif</db:programlisting>
         <db:para>This will cause any QML which imports the "MinehuntCore"
                                    type namespace and attempts to use the type to produce an error
                                    message:</db:para>
         <db:programlisting>fun.qml: Get back to work, slacker! Game { ^</db:programlisting>
         <db:para>Without this, a generic "Game is not a type" message would
                                    be given.</db:para>
         <db:para>#include &lt;<db:code><db:link xlink:href="qtqml-qmlmodule.db">QtQml</db:link></db:code>&gt; to use this function.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#qmlRegisterUncreatableType">qmlRegisterUncreatableType</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="qmlRegisterUncreatableType">
         <db:title>int qmlRegisterUncreatableType(const char * uri, int versionMajor, int versionMinor, const char * qmlName, const <db:link xlink:href="qstring.db">QString</db:link></db:title>
         <db:para>This template function registers the C++ type in the QML
                                    system with the name <db:emphasis>qmlName</db:emphasis>, in the library
                                    imported from <db:emphasis>uri</db:emphasis> having the version number
                                    composed from <db:emphasis>versionMajor</db:emphasis> and
                                        <db:emphasis>versionMinor</db:emphasis>.</db:para>
         <db:para>While the type has a name and a type, it cannot be created,
                                    and the given error <db:emphasis>message</db:emphasis> will result if
                                    creation is attempted.</db:para>
         <db:para>This is useful where the type is only intended for providing
                                    attached properties or enum values.</db:para>
         <db:para>Returns the QML type id.</db:para>
         <db:para>#include &lt;<db:code><db:link xlink:href="qtqml-qmlmodule.db">QtQml</db:link></db:code>&gt; to use this function.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qqmlengine.db#qmlRegisterTypeNotAvailable">qmlRegisterTypeNotAvailable</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
   </db:section>
   <db:section xml:id="macros">
      <db:title>Macro Documentation</db:title>
      <db:section xml:id="QML_DECLARE_TYPE">
         <db:title>QML_DECLARE_TYPE()</db:title>
         <db:para>Equivalent to <db:code>Q_DECLARE_METATYPE(TYPE
                                        *)</db:code> and
                                        <db:code>Q_DECLARE_METATYPE(QQmlListProperty&lt;TYPE&gt;)</db:code>
         </db:para>
         <db:para>#include &lt;<db:code><db:link xlink:href="qtqml-qmlmodule.db">QtQml</db:link></db:code>&gt; to use this macro.</db:para>
      </db:section>
      <db:section xml:id="QML_DECLARE_TYPEINFO">
         <db:title>QML_DECLARE_TYPEINFO( Type, Flags)</db:title>
         <db:para>Declares additional properties of the given
                                        <db:emphasis>Type</db:emphasis> as described by the specified
                                        <db:emphasis>Flags</db:emphasis>.</db:para>
         <db:para>Current the only supported type info is
                                        <db:code>QML_HAS_ATTACHED_PROPERTIES</db:code> which
                                    declares that the <db:emphasis>Type</db:emphasis> supports <db:link xlink:href="qtqml-syntax-objectattributes.db#attached-properties-and-attached-signal-handlers">attached properties</db:link>.</db:para>
         <db:para>#include &lt;<db:code><db:link xlink:href="qtqml-qmlmodule.db">QtQml</db:link></db:code>&gt; to use this macro.</db:para>
      </db:section>
   </db:section>
</db:article>
