<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            version="5.1"
            xml:lang="en">
   <db:title>QByteArray Class</db:title>
   <db:classsynopsis xlink:href="qbytearray.db">
      <db:ooclass>
         <db:classname>QByteArray</db:classname>
      </db:ooclass>
      <db:classsynopsisinfo role="header">#include
                                                  &lt;QByteArray&gt;</db:classsynopsisinfo>
      <db:classsynopsisinfo role="qmake"> QT +=
                                                core</db:classsynopsisinfo>
      <db:constructorsynopsis xlink:href="#QByteArray">
         <db:methodname>QByteArray</db:methodname>
         <db:void/>
      </db:constructorsynopsis>
      <db:constructorsynopsis xlink:href="#QByteArray-2">
         <db:methodname>QByteArray</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  data ,  int  size  =
                                    -1)</db:exceptionname>
      </db:constructorsynopsis>
      <db:constructorsynopsis xlink:href="#QByteArray-3">
         <db:methodname>QByteArray</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  size ,  char  ch )</db:exceptionname>
      </db:constructorsynopsis>
      <db:constructorsynopsis xlink:href="#QByteArray-5">
         <db:methodname>QByteArray</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp; 
                                        other )</db:exceptionname>
      </db:constructorsynopsis>
      <db:constructorsynopsis xlink:href="#QByteArray-6">
         <db:methodname>QByteArray</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( QByteArray  &amp;&amp; 
                                        other )</db:exceptionname>
      </db:constructorsynopsis>
      <db:destructorsynopsis xlink:href="#dtor.QByteArray">
         <db:methodname>~QByteArray</db:methodname>
         <db:void/>
      </db:destructorsynopsis>
      <db:methodsynopsis xlink:href="#append">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>append</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const
                                         QByteArray  &amp; 
                                    ba )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#append-2">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>append</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const
                                         QString  &amp; 
                                    str )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#append-3">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>append</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const
                                         char  * 
                                        str )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#append-4">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>append</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const
                                         char  * 
                                        str ,  int  len )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#append-5">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>append</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  ch )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#at">
         <db:type>char</db:type>
         <db:methodname>at</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  i ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#capacity">
         <db:type>int</db:type>
         <db:methodname>capacity</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#chop">
         <db:void/>
         <db:methodname>chop</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  n )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#clear">
         <db:void/>
         <db:methodname>clear</db:methodname>
         <db:void/>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#constData">
         <db:type>char</db:type>
         <db:methodname>constData</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#contains">
         <db:type>bool</db:type>
         <db:methodname>contains</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp;  ba )
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#contains-2">
         <db:type>bool</db:type>
         <db:methodname>contains</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  str ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#contains-3">
         <db:type>bool</db:type>
         <db:methodname>contains</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  ch ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#count">
         <db:type>int</db:type>
         <db:methodname>count</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const
                                         QByteArray  &amp;  ba )
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#count-2">
         <db:type>int</db:type>
         <db:methodname>count</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const
                                         char  * 
                                        str ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#count-3">
         <db:type>int</db:type>
         <db:methodname>count</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  ch ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#count-4">
         <db:type>int</db:type>
         <db:methodname>count</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#data">
         <db:type>char</db:type>
         <db:methodname>data</db:methodname>
         <db:void/>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#data-2">
         <db:type>char</db:type>
         <db:methodname>data</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#endsWith">
         <db:type>bool</db:type>
         <db:methodname>endsWith</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp;  ba )
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#endsWith-2">
         <db:type>bool</db:type>
         <db:methodname>endsWith</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  str ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#endsWith-3">
         <db:type>bool</db:type>
         <db:methodname>endsWith</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  ch ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#fill">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>fill</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  ch ,  int  size  =
                                    -1)</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#fromBase64">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>fromBase64</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp; 
                                        base64 )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#fromBase64-2">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>fromBase64</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp; 
                                        base64 ,  Base64Options 
                                        options )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#fromCFData">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>fromCFData</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( CFDataRef  data )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#fromHex">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>fromHex</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp; 
                                        hexEncoded )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#fromNSData">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>fromNSData</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  NSData  * 
                                    data )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#fromPercentEncoding">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>fromPercentEncoding</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const
                                         QByteArray  &amp; 
                                        input ,  char  percent  = '%')</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#fromRawCFData">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>fromRawCFData</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( CFDataRef 
                                    data )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#fromRawData">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>fromRawData</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  data ,
                                         int 
                                        size )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#fromRawNSData">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>fromRawNSData</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  NSData  * 
                                    data )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#fromStdString">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>fromStdString</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  std::string  &amp; 
                                        str )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#indexOf">
         <db:type>int</db:type>
         <db:methodname>indexOf</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp;  ba ,
                                         int 
                                        from  = 0) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#indexOf-2">
         <db:type>int</db:type>
         <db:methodname>indexOf</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString 
                                        &amp;  str ,  int  from  = 0) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#indexOf-3">
         <db:type>int</db:type>
         <db:methodname>indexOf</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  str ,  int  from  = 0)
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#indexOf-4">
         <db:type>int</db:type>
         <db:methodname>indexOf</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  ch ,  int  from  = 0)
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#insert">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>insert</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  i , const  QByteArray  &amp; 
                                        ba )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#insert-2">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>insert</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  i , const  QString  &amp; 
                                    str )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#insert-3">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>insert</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  i , const  char  * 
                                    str )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#insert-4">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>insert</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  i , const  char  *  str ,
                                         int 
                                    len )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#insert-5">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>insert</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  i ,  char  ch )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#isEmpty">
         <db:type>bool</db:type>
         <db:methodname>isEmpty</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#isNull">
         <db:type>bool</db:type>
         <db:methodname>isNull</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#lastIndexOf">
         <db:type>int</db:type>
         <db:methodname>lastIndexOf</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp;  ba ,
                                         int 
                                        from  = -1) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#lastIndexOf-2">
         <db:type>int</db:type>
         <db:methodname>lastIndexOf</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString 
                                        &amp;  str ,  int  from  = -1) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#lastIndexOf-3">
         <db:type>int</db:type>
         <db:methodname>lastIndexOf</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  str ,  int  from  = -1)
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#lastIndexOf-4">
         <db:type>int</db:type>
         <db:methodname>lastIndexOf</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  ch ,  int  from  = -1)
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#left">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>left</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  len ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#leftJustified">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>leftJustified</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  width ,
                                         char 
                                        fill  = ' ',  bool  truncate  = false)
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#length">
         <db:type>int</db:type>
         <db:methodname>length</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#mid">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>mid</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  pos ,  int  len  = -1)
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#number">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>number</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  n ,  int  base  = 10)</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#number-2">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>number</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( uint  n ,  int  base  =
                                    10)</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#number-3">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>number</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( qlonglong  n ,
                                         int 
                                        base  = 10)</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#number-4">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>number</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( qulonglong  n ,
                                         int 
                                        base  = 10)</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#number-5">
         <db:modifier>static</db:modifier>
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>number</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( double  n ,  char  f  = 'g',
                                         int 
                                        prec  = 6)</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#prepend">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>prepend</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp; 
                                    ba )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#prepend-2">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>prepend</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  str )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#prepend-3">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>prepend</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  str ,  int  len )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#prepend-4">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>prepend</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  ch )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#push_back">
         <db:void/>
         <db:methodname>push_back</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp; 
                                        other )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#push_back-2">
         <db:void/>
         <db:methodname>push_back</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  str )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#push_back-3">
         <db:void/>
         <db:methodname>push_back</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  ch )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#push_front">
         <db:void/>
         <db:methodname>push_front</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp; 
                                        other )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#push_front-2">
         <db:void/>
         <db:methodname>push_front</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  str )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#push_front-3">
         <db:void/>
         <db:methodname>push_front</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  ch )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#remove">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>remove</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  pos ,  int  len )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#repeated">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>repeated</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  times ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#replace">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>replace</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  pos ,  int  len , const
                                         QByteArray  &amp; 
                                        after )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#replace-2">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>replace</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  pos ,  int  len , const
                                         char  * 
                                        after )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#replace-3">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>replace</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  pos ,  int  len , const
                                         char  * 
                                        after ,  int  alen )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#replace-4">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>replace</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp; 
                                        before , const  QByteArray  &amp; 
                                        after )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#replace-5">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>replace</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  before , const
                                         QByteArray  &amp; 
                                        after )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#replace-6">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>replace</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  before ,  int  bsize , const
                                         char  * 
                                        after ,  int  asize )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#replace-7">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>replace</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp; 
                                        before , const  char  *  after )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#replace-8">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>replace</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString 
                                        &amp;  before , const  QByteArray  &amp; 
                                        after )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#replace-9">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>replace</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString 
                                        &amp;  before , const  char  *  after )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#replace-10">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>replace</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  before , const
                                         char  * 
                                        after )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#replace-11">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>replace</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  before , const  QByteArray  &amp; 
                                        after )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#replace-12">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>replace</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  before , const  QString  &amp; 
                                    after )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#replace-13">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>replace</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  before , const  char  * 
                                    after )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#replace-14">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>replace</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  before ,  char 
                                    after )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#reserve">
         <db:void/>
         <db:methodname>reserve</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  size )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#resize">
         <db:void/>
         <db:methodname>resize</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  size )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#right">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>right</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  len ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#rightJustified">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>rightJustified</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  width ,
                                         char 
                                        fill  = ' ',  bool  truncate  = false)
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setNum">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>setNum</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  n ,  int  base  = 10)</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setNum-2">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>setNum</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( uint  n ,  int  base  =
                                    10)</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setNum-3">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>setNum</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( short  n ,  int  base  =
                                    10)</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setNum-4">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>setNum</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( ushort  n ,  int  base  =
                                    10)</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setNum-5">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>setNum</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( qlonglong  n ,
                                         int 
                                        base  = 10)</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setNum-6">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>setNum</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( qulonglong  n ,
                                         int 
                                        base  = 10)</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setNum-7">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>setNum</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( double  n ,  char  f  = 'g',
                                         int 
                                        prec  = 6)</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setNum-8">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>setNum</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( float  n ,  char  f  = 'g',
                                         int 
                                        prec  = 6)</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#setRawData">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>setRawData</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  data ,  uint 
                                    size )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#simplified">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>simplified</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#size">
         <db:type>int</db:type>
         <db:methodname>size</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#split">
         <db:type>QList&lt;QByteArray&gt;</db:type>
         <db:methodname>split</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  sep ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#squeeze">
         <db:void/>
         <db:methodname>squeeze</db:methodname>
         <db:void/>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#startsWith">
         <db:type>bool</db:type>
         <db:methodname>startsWith</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp;  ba )
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#startsWith-2">
         <db:type>bool</db:type>
         <db:methodname>startsWith</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  str ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#startsWith-3">
         <db:type>bool</db:type>
         <db:methodname>startsWith</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  ch ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#swap">
         <db:void/>
         <db:methodname>swap</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( QByteArray  &amp; 
                                        other )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toBase64">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>toBase64</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toBase64-2">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>toBase64</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( Base64Options 
                                        options ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toCFData">
         <db:type>CFDataRef</db:type>
         <db:methodname>toCFData</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toDouble">
         <db:type>double</db:type>
         <db:methodname>toDouble</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( bool  *  ok  = 0) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toFloat">
         <db:type>float</db:type>
         <db:methodname>toFloat</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( bool  *  ok  = 0) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toHex">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>toHex</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toInt">
         <db:type>int</db:type>
         <db:methodname>toInt</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( bool 
                                        *  ok  = 0,  int  base  = 10) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toLong">
         <db:type>long</db:type>
         <db:methodname>toLong</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( bool 
                                        *  ok  = 0,  int  base  = 10) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toLongLong">
         <db:type xlink:href="qtglobal.html#qlonglong-typedef">qlonglong</db:type>
         <db:methodname>toLongLong</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( bool  *  ok  = 0,  int  base  = 10)
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toLower">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>toLower</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toNSData">
         <db:type>NSData</db:type>
         <db:methodname>toNSData</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toPercentEncoding">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>toPercentEncoding</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp; 
                                        exclude  = QByteArray(), const  QByteArray  &amp; 
                                        include  = QByteArray(),  char  percent  = '%')
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toRawCFData">
         <db:type>CFDataRef</db:type>
         <db:methodname>toRawCFData</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toRawNSData">
         <db:type>NSData</db:type>
         <db:methodname>toRawNSData</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toShort">
         <db:type>short</db:type>
         <db:methodname>toShort</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( bool  *  ok  = 0,  int  base  = 10)
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toStdString">
         <db:type>std::string</db:type>
         <db:methodname>toStdString</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toUInt">
         <db:type xlink:href="qtglobal.html#uint-typedef">uint</db:type>
         <db:methodname>toUInt</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( bool  *  ok  = 0,  int  base  = 10)
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toULong">
         <db:type xlink:href="qtglobal.html#ulong-typedef">ulong</db:type>
         <db:methodname>toULong</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( bool  *  ok  = 0,  int  base  = 10)
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toULongLong">
         <db:type xlink:href="qtglobal.html#qulonglong-typedef">qulonglong</db:type>
         <db:methodname>toULongLong</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( bool  *  ok  = 0,  int  base  = 10)
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toUShort">
         <db:type xlink:href="qtglobal.html#ushort-typedef">ushort</db:type>
         <db:methodname>toUShort</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( bool  *  ok  = 0,  int  base  = 10)
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#toUpper">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>toUpper</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#trimmed">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>trimmed</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#truncate">
         <db:void/>
         <db:methodname>truncate</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  pos )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-not-eq">
         <db:type>bool</db:type>
         <db:methodname>operator!=</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString  &amp;  str )
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-2b-eq">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>operator+=</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp; 
                                    ba )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-2b-eq-2">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>operator+=</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString 
                                        &amp;  str )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-2b-eq-3">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>operator+=</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  str )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-2b-eq-4">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>operator+=</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( char  ch )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-lt">
         <db:type>bool</db:type>
         <db:methodname>operator&lt;</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString 
                                        &amp;  str ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-lt-eq">
         <db:type>bool</db:type>
         <db:methodname>operator&lt;=</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString  &amp;  str )
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-eq">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>operator=</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QByteArray  &amp; 
                                        other )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-eq-2">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>operator=</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( QByteArray  &amp;&amp; 
                                        other )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-eq-3">
         <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
         <db:methodname>operator=</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  char  *  str )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-eq-eq">
         <db:type>bool</db:type>
         <db:methodname>operator==</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString  &amp;  str )
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-gt">
         <db:type>bool</db:type>
         <db:methodname>operator&gt;</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString 
                                        &amp;  str ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-gt-eq">
         <db:type>bool</db:type>
         <db:methodname>operator&gt;=</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">(const  QString  &amp;  str )
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-5b-5d">
         <db:type>QByteRef</db:type>
         <db:methodname>operator[]</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  i )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-5b-5d-2">
         <db:type>char</db:type>
         <db:methodname>operator[]</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( int  i ) const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-5b-5d-3">
         <db:type>QByteRef</db:type>
         <db:methodname>operator[]</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( uint  i )</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-5b-5d-4">
         <db:type>char</db:type>
         <db:methodname>operator[]</db:methodname>
         <db:void role="parameters"/>
         <db:exceptionname role="parameters">( uint  i )
                                    const</db:exceptionname>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-const-char--2a">
         <db:modifier>(obsolete)</db:modifier>
         <db:methodname>operator const char *</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-const-void--2a">
         <db:modifier>(obsolete)</db:modifier>
         <db:methodname>operator const void *</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-const-char--2a">
         <db:modifier>(compat)</db:modifier>
         <db:methodname>operator const char *</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
      <db:methodsynopsis xlink:href="#operator-const-void--2a">
         <db:modifier>(compat)</db:modifier>
         <db:methodname>operator const void *</db:methodname>
         <db:void/>
         <db:modifier>const</db:modifier>
      </db:methodsynopsis>
   </db:classsynopsis>
   <db:funcsynopsis xlink:href="#QT_NO_CAST_FROM_BYTEARRAY">
      <db:funcsynopsisinfo>macro</db:funcsynopsisinfo>
      <db:funcprototype>
         <db:funcdef>
            <db:function>QT_NO_CAST_FROM_BYTEARRAY</db:function>
         </db:funcdef>
         <db:void/>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qChecksum">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qtglobal.html#quint16-typedef">quint16</db:type>
            <db:function>qChecksum</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;uint&gt;</db:type>
            <db:parameter>data</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qtglobal.html#uint-typedef">uint</db:type>
            <db:parameter>len</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qCompress">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:function>qCompress</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QByteArray&lt;int&gt;</db:type>
            <db:parameter>data</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int</db:type>
            <db:parameter>compressionLevel</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qCompress-2">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:function>qCompress</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>uchar&lt;int&lt;int&gt;&gt;</db:type>
            <db:parameter>data</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int&lt;int&gt;</db:type>
            <db:parameter>nbytes</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int</db:type>
            <db:parameter>compressionLevel</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qUncompress">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:function>qUncompress</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>data</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qUncompress-2">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:function>qUncompress</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>uchar&lt;int&gt;</db:type>
            <db:parameter>data</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>int</db:type>
            <db:parameter>nbytes</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qsnprintf">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qsnprintf</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>char&lt;size_t&lt;char&gt;&gt;</db:type>
            <db:parameter>str</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>size_t&lt;char&gt;</db:type>
            <db:parameter>n</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>char</db:type>
            <db:parameter>fmt</db:parameter>
         </db:paramdef>
         <db:varargs/>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qstrcmp">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qstrcmp</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;char&gt;</db:type>
            <db:parameter>str1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>str2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qstrcpy">
      <db:funcprototype>
         <db:funcdef>
            <db:type>char</db:type>
            <db:function>qstrcpy</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>char&lt;char&gt;</db:type>
            <db:parameter>dst</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>char</db:type>
            <db:parameter>src</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qstrdup">
      <db:funcprototype>
         <db:funcdef>
            <db:type>char</db:type>
            <db:function>qstrdup</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>src</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qstricmp">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qstricmp</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;char&gt;</db:type>
            <db:parameter>str1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>str2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qstrlen">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qtglobal.html#uint-typedef">uint</db:type>
            <db:function>qstrlen</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>str</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qstrncmp">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qstrncmp</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;char&lt;uint&gt;&gt;</db:type>
            <db:parameter>str1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;uint&gt;</db:type>
            <db:parameter>str2</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qtglobal.html#uint-typedef">uint</db:type>
            <db:parameter>len</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qstrncpy">
      <db:funcprototype>
         <db:funcdef>
            <db:type>char</db:type>
            <db:function>qstrncpy</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>char&lt;char&lt;uint&gt;&gt;</db:type>
            <db:parameter>dst</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>char&lt;uint&gt;</db:type>
            <db:parameter>src</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type xlink:href="qtglobal.html#uint-typedef">uint</db:type>
            <db:parameter>len</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qstrnicmp">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qstrnicmp</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;char&lt;uint&gt;&gt;</db:type>
            <db:parameter>str1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;uint&gt;</db:type>
            <db:parameter>str2</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qtglobal.html#uint-typedef">uint</db:type>
            <db:parameter>len</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qstrnlen">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qtglobal.html#uint-typedef">uint</db:type>
            <db:function>qstrnlen</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;uint&gt;</db:type>
            <db:parameter>str</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qtglobal.html#uint-typedef">uint</db:type>
            <db:parameter>maxlen</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#qvsnprintf">
      <db:funcprototype>
         <db:funcdef>
            <db:type>int</db:type>
            <db:function>qvsnprintf</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>char&lt;size_t&lt;char&lt;va_list&gt;&gt;&gt;</db:type>
            <db:parameter>str</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>size_t&lt;char&lt;va_list&gt;&gt;</db:type>
            <db:parameter>n</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>char&lt;va_list&gt;</db:type>
            <db:parameter>fmt</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>va_list</db:type>
            <db:parameter>ap</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-not-eq-54">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator!=</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QByteArray&lt;QByteArray&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-not-eq-55">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator!=</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QByteArray&lt;char&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-not-eq-56">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator!=</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;QByteArray&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-2b">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:function>operator+</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QByteArray&lt;QByteArray&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-2b-29">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:function>operator+</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QByteArray&lt;char&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-2b-30">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:function>operator+</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QByteArray&lt;char&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-2b-31">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:function>operator+</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;QByteArray&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-2b-32">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:function>operator+</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>char&lt;QByteArray&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-lt-19">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator&lt;</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QByteArray&lt;QByteArray&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-lt-20">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator&lt;</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QByteArray&lt;char&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-lt-21">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator&lt;</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;QByteArray&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-lt-lt-46">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qdatastream.html">QDataStream</db:type>
            <db:function>operator&lt;&lt;</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>QDataStream&lt;QByteArray&gt;</db:type>
            <db:parameter>out</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>ba</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-lt-eq-16">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator&lt;=</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QByteArray&lt;QByteArray&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-lt-eq-17">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator&lt;=</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QByteArray&lt;char&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-lt-eq-18">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator&lt;=</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;QByteArray&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-eq-eq-62">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator==</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QByteArray&lt;QByteArray&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-eq-eq-63">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator==</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QByteArray&lt;char&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-eq-eq-64">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator==</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;QByteArray&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-gt-16">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator&gt;</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QByteArray&lt;QByteArray&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-gt-17">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator&gt;</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QByteArray&lt;char&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-gt-18">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator&gt;</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;QByteArray&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-gt-eq-16">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator&gt;=</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QByteArray&lt;QByteArray&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-gt-eq-17">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator&gt;=</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>QByteArray&lt;char&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-gt-eq-18">
      <db:funcprototype>
         <db:funcdef>
            <db:type>bool</db:type>
            <db:function>operator&gt;=</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type>char&lt;QByteArray&gt;</db:type>
            <db:parameter>a1</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type>const</db:type>
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>a2</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:funcsynopsis xlink:href="#operator-gt-gt-18">
      <db:funcprototype>
         <db:funcdef>
            <db:type xlink:href="qdatastream.html">QDataStream</db:type>
            <db:function>operator&gt;&gt;</db:function>
         </db:funcdef>
         <db:paramdef choice="req">
            <db:type>QDataStream&lt;QByteArray&gt;</db:type>
            <db:parameter>in</db:parameter>
         </db:paramdef>
         <db:paramdef choice="req">
            <db:type xlink:href="qbytearray.html#QByteArray">QByteArray</db:type>
            <db:parameter>ba</db:parameter>
         </db:paramdef>
      </db:funcprototype>
   </db:funcsynopsis>
   <db:section xml:id="details">
      <db:title>Detailed Description</db:title>
      <db:para>The <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> class
                                    provides an array of bytes.</db:para>
      <db:para>
         <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> can be
                                    used to store both raw bytes (including '\0's) and traditional
                                    8-bit '\0'-terminated strings. Using <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> is much more
                                    convenient than using <db:code>const char *</db:code>.
                                    Behind the scenes, it always ensures that the data is followed
                                    by a '\0' terminator, and uses <db:link xlink:href="implicit-sharing.html">implicit sharing</db:link>
                                    (copy-on-write) to reduce memory usage and avoid needless
                                    copying of data.</db:para>
      <db:para>In addition to <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>, Qt also provides the <db:code><db:link xlink:href="qstring.html">QString</db:link></db:code> class to store string
                                    data. For most purposes, <db:code><db:link xlink:href="qstring.html">QString</db:link></db:code> is the class you want to use. It stores
                                    16-bit Unicode characters, making it easy to store
                                    non-ASCII/non-Latin-1 characters in your application.
                                    Furthermore, <db:code><db:link xlink:href="qstring.html">QString</db:link></db:code> is
                                    used throughout in the Qt API. The two main cases where <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> is appropriate
                                    are when you need to store raw binary data, and when memory
                                    conservation is critical (e.g., with Qt for Embedded
                                    Linux).</db:para>
      <db:para>One way to initialize a <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> is simply to pass a <db:code>const
                                        char *</db:code> to its constructor. For example, the
                                    following code creates a byte array of size 5 containing the
                                    data "Hello":</db:para>
      <db:programlisting>QByteArray ba("Hello");</db:programlisting>
      <db:para>Although the <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code> is 5, the byte array also maintains an
                                    extra '\0' character at the end so that if a function is used
                                    that asks for a pointer to the underlying data (e.g. a call to
                                        <db:code><db:link xlink:href="qbytearray.html#data">data</db:link>()</db:code>), the
                                    data pointed to is guaranteed to be '\0'-terminated.</db:para>
      <db:para>
         <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> makes a
                                    deep copy of the <db:code>const char *</db:code> data, so
                                    you can modify it later without experiencing side effects. (If
                                    for performance reasons you don't want to take a deep copy of
                                    the character data, use <db:code><db:link xlink:href="qbytearray.html#fromRawData">QByteArray::fromRawData</db:link>()</db:code> instead.)</db:para>
      <db:para>Another approach is to set the size of the array using
                                        <db:code><db:link xlink:href="qbytearray.html#resize">resize</db:link>()</db:code> and
                                    to initialize the data byte per byte. <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> uses 0-based
                                    indexes, just like C++ arrays. To access the byte at a
                                    particular index position, you can use operator[](). On
                                    non-const byte arrays, operator[]() returns a reference to a
                                    byte that can be used on the left side of an assignment. For
                                    example:</db:para>
      <db:programlisting>QByteArray ba; ba.resize(5); ba[0]=0x3c; ba[1]=0xb8; ba[2]=0x64; ba[3]=0x18; ba[4]=0xca;</db:programlisting>
      <db:para>For read-only access, an alternative syntax is to use
                                        <db:code><db:link xlink:href="qbytearray.html#at">at</db:link>()</db:code>:</db:para>
      <db:programlisting>for
                                        (int i =0; i &lt; ba.size(); ++i) { if
                                        (ba.at(i) &gt;='a'&amp;&amp; ba.at(i) &lt;='f') cout &lt;&lt;"Found character in range
                                        [a-f]"&lt;&lt; endl; }</db:programlisting>
      <db:para>
         <db:code><db:link xlink:href="qbytearray.html#at">at</db:link>()</db:code> can be
                                    faster than operator[](), because it never causes a <db:link xlink:href="implicit-sharing.html#deep-copy">deep copy</db:link> to
                                    occur.</db:para>
      <db:para>To extract many bytes at a time, use <db:code><db:link xlink:href="qbytearray.html#left">left</db:link>()</db:code>, <db:code><db:link xlink:href="qbytearray.html#right">right</db:link>()</db:code>, or <db:code><db:link xlink:href="qbytearray.html#mid">mid</db:link>()</db:code>.</db:para>
      <db:para>A <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> can
                                    embed '\0' bytes. The <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code> function always returns the size of the
                                    whole array, including embedded '\0' bytes, but excluding the
                                    terminating '\0' added by <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>. For example:</db:para>
      <db:programlisting>QByteArray ba1("ca\0r\0t"); ba1.size(); // Returns 2. ba1.constData(); // Returns "ca" with terminating
                                        \0.QByteArray ba2("ca\0r\0t",3); ba2.size(); // Returns 3. ba2.constData(); // Returns "ca\0" with terminating
                                        \0.QByteArray ba3("ca\0r\0t",4); ba3.size(); // Returns 4. ba3.constData(); // Returns "ca\0r" with terminating
                                        \0.constchar cart[]= {'c','a','\0','r','\0','t'}; QByteArray ba4(QByteArray::fromRawData(cart,6)); ba4.size(); // Returns 6. ba4.constData(); // Returns "ca\0r\0t" without terminating
                                        \0.</db:programlisting>
      <db:para>If you want to obtain the length of the data up to and
                                    excluding the first '\0' character, call <db:code><db:link xlink:href="qbytearray.html#qstrlen">qstrlen</db:link>()</db:code> on the
                                    byte array.</db:para>
      <db:para>After a call to <db:code><db:link xlink:href="qbytearray.html#resize">resize</db:link>()</db:code>, newly allocated bytes have undefined
                                    values. To set all the bytes to a particular value, call <db:code><db:link xlink:href="qbytearray.html#fill">fill</db:link>()</db:code>.</db:para>
      <db:para>To obtain a pointer to the actual character data, call
                                        <db:code><db:link xlink:href="qbytearray.html#data">data</db:link>()</db:code> or
                                        <db:code><db:link xlink:href="qbytearray.html#constData">constData</db:link>()</db:code>. These functions return a pointer to the
                                    beginning of the data. The pointer is guaranteed to remain valid
                                    until a non-const function is called on the <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>. It is also
                                    guaranteed that the data ends with a '\0' byte unless the
                                        <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> was
                                    created from a <db:link xlink:href="qbytearray.html#fromRawData">raw
                                        data</db:link>. This '\0' byte is automatically provided by
                                        <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> and is
                                    not counted in <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>.</db:para>
      <db:para>
         <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> provides
                                    the following basic functions for modifying the byte data:
                                        <db:code><db:link xlink:href="qbytearray.html#append">append</db:link>()</db:code>,
                                        <db:code><db:link xlink:href="qbytearray.html#prepend">prepend</db:link>()</db:code>,
                                        <db:code><db:link xlink:href="qbytearray.html#insert">insert</db:link>()</db:code>,
                                        <db:code><db:link xlink:href="qbytearray.html#replace">replace</db:link>()</db:code>,
                                    and <db:code><db:link xlink:href="qbytearray.html#remove">remove</db:link>()</db:code>. For
                                    example:</db:para>
      <db:programlisting>QByteArray x("and"); x.prepend("rock
                                        "); // x == "rock
                                        and" x.append("
                                        roll"); // x == "rock
                                        and roll" x.replace(5,3,"&amp;"); // x == "rock &amp;
                                    roll"</db:programlisting>
      <db:para>The <db:code><db:link xlink:href="qbytearray.html#replace">replace</db:link>()</db:code> and <db:code><db:link xlink:href="qbytearray.html#remove">remove</db:link>()</db:code> functions' first two arguments are the
                                    position from which to start erasing and the number of bytes
                                    that should be erased.</db:para>
      <db:para>When you <db:code><db:link xlink:href="qbytearray.html#append">append</db:link>()</db:code> data to a non-empty array, the array will
                                    be reallocated and the new data copied to it. You can avoid this
                                    behavior by calling <db:code><db:link xlink:href="qbytearray.html#reserve">reserve</db:link>()</db:code>, which preallocates a certain amount of
                                    memory. You can also call <db:code><db:link xlink:href="qbytearray.html#capacity">capacity</db:link>()</db:code> to find
                                    out how much memory <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> actually allocated. Data appended to an
                                    empty array is not copied.</db:para>
      <db:para>A frequent requirement is to remove whitespace characters
                                    from a byte array ('\n', '\t', ' ', etc.). If you want to remove
                                    whitespace from both ends of a <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>, use <db:code><db:link xlink:href="qbytearray.html#trimmed">trimmed</db:link>()</db:code>. If you
                                    want to remove whitespace from both ends and replace multiple
                                    consecutive whitespaces with a single space character within the
                                    byte array, use <db:code><db:link xlink:href="qbytearray.html#simplified">simplified</db:link>()</db:code>.</db:para>
      <db:para>If you want to find all occurrences of a particular
                                    character or substring in a <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>, use <db:code><db:link xlink:href="qbytearray.html#indexOf">indexOf</db:link>()</db:code> or <db:code><db:link xlink:href="qbytearray.html#lastIndexOf">lastIndexOf</db:link>()</db:code>.
                                    The former searches forward starting from a given index
                                    position, the latter searches backward. Both return the index
                                    position of the character or substring if they find it;
                                    otherwise, they return -1. For example, here's a typical loop
                                    that finds all occurrences of a particular substring:</db:para>
      <db:programlisting>QByteArray ba("We must be &lt;b&gt;bold&lt;/b&gt;, very
                                        &lt;b&gt;bold&lt;/b&gt;"); int j =0; while ((j = ba.indexOf("&lt;b&gt;", j)) !=-1) { cout &lt;&lt;"Found &lt;b&gt; tag at index position
                                        "&lt;&lt; j &lt;&lt; endl; ++j;
                                    }</db:programlisting>
      <db:para>If you simply want to check whether a <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> contains a
                                    particular character or substring, use <db:code><db:link xlink:href="qbytearray.html#contains">contains</db:link>()</db:code>. If you
                                    want to find out how many times a particular character or
                                    substring occurs in the byte array, use <db:code><db:link xlink:href="qbytearray.html#count">count</db:link>()</db:code>. If you want
                                    to replace all occurrences of a particular value with another,
                                    use one of the two-parameter <db:code><db:link xlink:href="qbytearray.html#replace">replace</db:link>()</db:code>
                                    overloads.</db:para>
      <db:para>
         <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>s can be
                                    compared using overloaded operators such as operator&lt;(),
                                    operator&lt;=(), operator==(), operator&gt;=(), and so on. The
                                    comparison is based exclusively on the numeric values of the
                                    characters and is very fast, but is not what a human would
                                    expect. <db:code><db:link xlink:href="qstring.html#localeAwareCompare">QString::localeAwareCompare</db:link>()</db:code> is a better choice
                                    for sorting user-interface strings.</db:para>
      <db:para>For historical reasons, <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> distinguishes between a null byte array
                                    and an empty byte array. A <db:emphasis>null</db:emphasis> byte array is a
                                    byte array that is initialized using <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>'s default
                                    constructor or by passing (const char *)0 to the constructor. An
                                        <db:emphasis>empty</db:emphasis> byte array is any byte array with
                                    size 0. A null byte array is always empty, but an empty byte
                                    array isn't necessarily null:</db:para>
      <db:programlisting>QByteArray().isNull(); // returns trueQByteArray().isEmpty(); // returns trueQByteArray("").isNull(); // returns
                                        falseQByteArray("").isEmpty(); // returns
                                        trueQByteArray("abc").isNull(); // returns
                                        falseQByteArray("abc").isEmpty(); // returns
                                        false</db:programlisting>
      <db:para>All functions except <db:code><db:link xlink:href="qbytearray.html#isNull">isNull</db:link>()</db:code> treat null byte arrays the same as empty
                                    byte arrays. For example, <db:code><db:link xlink:href="qbytearray.html#data">data</db:link>()</db:code> returns a pointer to a '\0' character for a
                                    null byte array (<db:emphasis>not</db:emphasis> a null pointer), and
                                        <db:code><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link>()</db:code> compares equal to <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>. We recommend
                                    that you always use <db:code><db:link xlink:href="qbytearray.html#isEmpty">isEmpty</db:link>()</db:code> and avoid <db:code><db:link xlink:href="qbytearray.html#isNull">isNull</db:link>()</db:code>.</db:para>
      <db:section xml:id="notes-on-locale">
         <db:title>Notes on Locale</db:title>
         <db:para/>
         <db:section xml:id="number-string-conversions">
            <db:title>Number-String Conversions</db:title>
            <db:para>Functions that perform conversions between numeric data
                                    types and strings are performed in the C locale, irrespective of
                                    the user's locale settings. Use <db:code><db:link xlink:href="qstring.html">QString</db:link></db:code> to perform locale-aware conversions
                                    between numbers and strings.</db:para>
         </db:section>
         <db:section xml:id="sect-8-bit-character-comparisons">
            <db:title>8-bit Character Comparisons</db:title>
            <db:para>In <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>, the
                                    notion of uppercase and lowercase and of which character is
                                    greater than or less than another character is locale dependent.
                                    This affects functions that support a case insensitive option or
                                    that compare or lowercase or uppercase their arguments. Case
                                    insensitive operations and comparisons will be accurate if both
                                    strings contain only ASCII characters. (If
                                        <db:code>$LC_CTYPE</db:code> is set, most Unix systems
                                    do "the right thing".) Functions that this affects include
                                        <db:code><db:link xlink:href="qbytearray.html#contains">contains</db:link>()</db:code>,
                                        <db:code><db:link xlink:href="qbytearray.html#indexOf">indexOf</db:link>()</db:code>,
                                        <db:code><db:link xlink:href="qbytearray.html#lastIndexOf">lastIndexOf</db:link>()</db:code>, operator&lt;(), operator&lt;=(),
                                    operator&gt;(), operator&gt;=(), <db:code><db:link xlink:href="qbytearray.html#toLower">toLower</db:link>()</db:code> and
                                        <db:code><db:link xlink:href="qbytearray.html#toUpper">toUpper</db:link>()</db:code>.</db:para>
            <db:para>This issue does not apply to <db:code><db:link xlink:href="qstring.html">QString</db:link></db:code>s since they represent characters using
                                    Unicode.</db:para>
         </db:section>
      </db:section>
      <db:section>
         <db:title>See Also</db:title>
         <db:simplelist type="vert">
            <db:member>
               <db:code><db:link xlink:href="qstring.html">QString</db:link></db:code>
            </db:member>
            <db:member>
               <db:code><db:link xlink:href="qbitarray.html">QBitArray</db:link></db:code>
            </db:member>
         </db:simplelist>
      </db:section>
   </db:section>
   <db:section xml:id="types">
      <db:title>Member Type Documentation</db:title>
      <db:section xml:id="Base64Option-enum">
         <db:title>enum QByteArray::Base64Option</db:title>
         <db:bridgehead renderas="sect2">flags QByteArray::Base64Options</db:bridgehead>
         <db:para>This enum contains the options available for encoding and
                                    decoding Base64. Base64 is defined by <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt">RFC
                                    4648</db:link>, with the following options:</db:para>
         <db:informaltable>
            <db:tbody>
               <db:tr>
                  <db:th>
                     <db:para>Constant</db:para>
                  </db:th>
                  <db:th>
                     <db:para>Value</db:para>
                  </db:th>
                  <db:th>
                     <db:para>Description</db:para>
                  </db:th>
               </db:tr>
               <db:tr>
                  <db:td>
                     <db:para>
                        <db:code>QByteArray::Base64Encoding</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>
                        <db:code>0</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>(default) The regular
                                                  Base64 alphabet, called simply "base64"</db:para>
                  </db:td>
               </db:tr>
               <db:tr>
                  <db:td>
                     <db:para>
                        <db:code>QByteArray::Base64UrlEncoding</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>
                        <db:code>1</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>An alternate alphabet,
                                                  called "base64url", which replaces two characters
                                                  in the alphabet to be more friendly to
                                                  URLs.</db:para>
                  </db:td>
               </db:tr>
               <db:tr>
                  <db:td>
                     <db:para>
                        <db:code>QByteArray::KeepTrailingEquals</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>
                        <db:code>0</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>(default) Keeps the
                                                  trailing padding equal signs at the end of the
                                                  encoded data, so the data is always a size
                                                  multiple of four.</db:para>
                  </db:td>
               </db:tr>
               <db:tr>
                  <db:td>
                     <db:para>
                        <db:code>QByteArray::OmitTrailingEquals</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>
                        <db:code>2</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>Omits adding the padding
                                                  equal signs at the end of the encoded
                                                  data.</db:para>
                  </db:td>
               </db:tr>
            </db:tbody>
         </db:informaltable>
         <db:para>
            <db:code><db:link xlink:href="qbytearray.html#fromBase64">QByteArray::fromBase64</db:link>()</db:code> ignores the
                                    KeepTrailingEquals and OmitTrailingEquals options and will not
                                    flag errors in case they are missing or if there are too many of
                                    them.</db:para>
         <db:para>This enum was introduced or modified in Qt 5.2.</db:para>
         <db:para>The Base64Options type is a typedef for <db:code><db:link xlink:href="qflags.html">QFlags</db:link>&lt;Base64Option&gt;</db:code>. It
                                    stores an OR combination of Base64Option values.</db:para>
      </db:section>
   </db:section>
   <db:section xml:id="func">
      <db:title>Member Function Documentation</db:title>
      <db:section xml:id="QByteArray">
         <db:title>QByteArray::QByteArray()</db:title>
         <db:para>Constructs an empty byte array.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#isEmpty">isEmpty</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="QByteArray-2">
         <db:title>QByteArray::QByteArray(const char * data, int size = -1)</db:title>
         <db:para>Constructs a byte array containing the first
                                        <db:emphasis>size</db:emphasis> bytes of array
                                    <db:emphasis>data</db:emphasis>.</db:para>
         <db:para>If <db:emphasis>data</db:emphasis> is 0, a null byte array is
                                    constructed.</db:para>
         <db:para>If <db:emphasis>size</db:emphasis> is negative, <db:emphasis>data</db:emphasis>
                                    is assumed to point to a nul-terminated string and its length is
                                    determined dynamically. The terminating nul-character is not
                                    considered part of the byte array.</db:para>
         <db:para>
            <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> makes a
                                    deep copy of the string data.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData">fromRawData</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="QByteArray-3">
         <db:title>QByteArray::QByteArray(int size, char ch)</db:title>
         <db:para>Constructs a byte array of size <db:emphasis>size</db:emphasis> with
                                    every byte set to character <db:emphasis>ch</db:emphasis>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fill">fill</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="QByteArray-5">
         <db:title>QByteArray::QByteArray(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Constructs a copy of <db:emphasis>other</db:emphasis>.</db:para>
         <db:para>This operation takes <db:link xlink:href="containers.html#constant-time">constant time</db:link>,
                                    because <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> is
                                        <db:link xlink:href="implicit-sharing.html#implicitly-shared">implicitly shared</db:link>. This makes returning a <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> from a function
                                    very fast. If a shared instance is modified, it will be copied
                                    (copy-on-write), taking <db:link xlink:href="containers.html#linear-time">linear
                                    time</db:link>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-eq">operator=</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="QByteArray-6">
         <db:title>QByteArray::QByteArray(<db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Move-constructs a <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> instance, making it point at the same
                                    object that <db:emphasis>other</db:emphasis> was pointing to.</db:para>
         <db:para>This function was introduced in Qt 5.2.</db:para>
      </db:section>
      <db:section xml:id="dtor.QByteArray">
         <db:title>QByteArray::~QByteArray()</db:title>
         <db:para>Destroys the byte array.</db:para>
      </db:section>
      <db:section xml:id="append">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Appends the byte array <db:emphasis>ba</db:emphasis> onto the end of
                                    this byte array.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray x("free"); QByteArray y("dom"); x.append(y); // x ==
                                        "freedom"</db:programlisting>
         <db:para>This is the same as insert(<db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>,
                                        <db:emphasis>ba</db:emphasis>).</db:para>
         <db:para>Note: <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> is
                                    an <db:link xlink:href="implicit-sharing.html#implicitly-shared">implicitly shared</db:link> class. Consequently, if
                                        <db:emphasis>this</db:emphasis> is an empty <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>, then
                                        <db:emphasis>this</db:emphasis> will just share the data held in
                                        <db:emphasis>ba</db:emphasis>. In this case, no copying of data is
                                    done, taking <db:link xlink:href="containers.html#constant-time">constant time</db:link>. If a shared instance is modified,
                                    it will be copied (copy-on-write), taking <db:link xlink:href="containers.html#linear-time">linear
                                    time</db:link>.</db:para>
         <db:para>If <db:emphasis>this</db:emphasis> is not an empty <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>, a deep copy of
                                    the data is performed, taking <db:link xlink:href="containers.html#linear-time">linear
                                    time</db:link>.</db:para>
         <db:para>This operation typically does not suffer from allocation
                                    overhead, because <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> preallocates extra space at the end of
                                    the data so that it may grow without reallocating for each
                                    append operation.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-2b-eq">operator+=</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#prepend">prepend</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#insert">insert</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="append-2">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qstring.html">QString</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Appends the string <db:emphasis>str</db:emphasis> to this byte array.
                                    The Unicode data is converted into 8-bit characters using
                                        <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code>.</db:para>
         <db:para>You can disable this function by defining
                                        <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile
                                    your applications. You then need to call <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code> (or
                                        <db:code><db:link xlink:href="qstring.html#toLatin1">QString::toLatin1</db:link>()</db:code> or <db:code><db:link xlink:href="qstring.html#toLocal8Bit">QString::toLocal8Bit</db:link>()</db:code>) explicitly if you want to
                                    convert the data to <db:code>const char
                                    *</db:code>.</db:para>
      </db:section>
      <db:section xml:id="append-3">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Appends the string <db:emphasis>str</db:emphasis> to this byte
                                    array.</db:para>
      </db:section>
      <db:section xml:id="append-4">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This function overloads <db:code><db:link xlink:href="qbytearray.html#append">append</db:link>()</db:code>.</db:para>
         <db:para>Appends the first <db:emphasis>len</db:emphasis> characters of the
                                    string <db:emphasis>str</db:emphasis> to this byte array and returns a
                                    reference to this byte array.</db:para>
         <db:para>If <db:emphasis>len</db:emphasis> is negative, the length of the
                                    string will be determined automatically using <db:code><db:link xlink:href="qbytearray.html#qstrlen">qstrlen</db:link>()</db:code>. If
                                        <db:emphasis>len</db:emphasis> is zero or <db:emphasis>str</db:emphasis> is
                                    null, nothing is appended to the byte array. Ensure that
                                        <db:emphasis>len</db:emphasis> is <db:emphasis>not</db:emphasis> longer than
                                        <db:emphasis>str</db:emphasis>.</db:para>
      </db:section>
      <db:section xml:id="append-5">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Appends the character <db:emphasis>ch</db:emphasis> to this byte
                                    array.</db:para>
      </db:section>
      <db:section xml:id="at">
         <db:title>char QByteArray::at(int i) const</db:title>
         <db:para>Returns the character at index position <db:emphasis>i</db:emphasis>
                                    in the byte array.</db:para>
         <db:para>
            <db:emphasis>i</db:emphasis> must be a valid index position in the
                                    byte array (i.e., 0 &lt;= <db:emphasis>i</db:emphasis> &lt; <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>).</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-5b-5d">operator[]</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="capacity">
         <db:title>int QByteArray::capacity() const</db:title>
         <db:para>Returns the maximum number of bytes that can be stored in
                                    the byte array without forcing a reallocation.</db:para>
         <db:para>The sole purpose of this function is to provide a means of
                                    fine tuning <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>'s
                                    memory usage. In general, you will rarely ever need to call this
                                    function. If you want to know how many bytes are in the byte
                                    array, call <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#reserve">reserve</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#squeeze">squeeze</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="chop">
         <db:title>void QByteArray::chop(int n)</db:title>
         <db:para>Removes <db:emphasis>n</db:emphasis> bytes from the end of the byte
                                    array.</db:para>
         <db:para>If <db:emphasis>n</db:emphasis> is greater than <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>, the result is
                                    an empty byte array.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray ba("STARTTLS\r\n"); ba.chop(2); // ba ==
                                        "STARTTLS"</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#truncate">truncate</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#resize">resize</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#left">left</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="clear">
         <db:title>void QByteArray::clear()</db:title>
         <db:para>Clears the contents of the byte array and makes it
                                    empty.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#resize">resize</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#isEmpty">isEmpty</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="constData">
         <db:title>const char * QByteArray::constData() const</db:title>
         <db:para>Returns a pointer to the data stored in the byte array. The
                                    pointer can be used to access the bytes that compose the array.
                                    The data is '\0'-terminated unless the <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> object was
                                    created from raw data. The pointer remains valid as long as the
                                    byte array isn't reallocated or destroyed.</db:para>
         <db:para>This function is mostly useful to pass a byte array to a
                                    function that accepts a <db:code>const char
                                    *</db:code>.</db:para>
         <db:para>Note: A <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>
                                    can store any byte values including '\0's, but most functions
                                    that take <db:code>char *</db:code> arguments assume that
                                    the data ends at the first '\0' they encounter.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#data">data</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-5b-5d">operator[]</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData">fromRawData</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="contains">
         <db:title>bool QByteArray::contains(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns <db:code>true</db:code> if the byte array
                                    contains an occurrence of the byte array <db:emphasis>ba</db:emphasis>;
                                    otherwise returns <db:code>false</db:code>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#indexOf">indexOf</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#count">count</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="contains-2">
         <db:title>bool QByteArray::contains(const char * str) const</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if the byte array
                                    contains the string <db:emphasis>str</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="contains-3">
         <db:title>bool QByteArray::contains(char ch) const</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if the byte array
                                    contains the character <db:emphasis>ch</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="count">
         <db:title>int QByteArray::count(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns the number of (potentially overlapping) occurrences
                                    of byte array <db:emphasis>ba</db:emphasis> in this byte array.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#contains">contains</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#indexOf">indexOf</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="count-2">
         <db:title>int QByteArray::count(const char * str) const</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns the number of (potentially overlapping) occurrences
                                    of string <db:emphasis>str</db:emphasis> in the byte array.</db:para>
      </db:section>
      <db:section xml:id="count-3">
         <db:title>int QByteArray::count(char ch) const</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns the number of occurrences of character
                                        <db:emphasis>ch</db:emphasis> in the byte array.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#contains">contains</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#indexOf">indexOf</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="count-4">
         <db:title>int QByteArray::count() const</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Same as <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>.</db:para>
      </db:section>
      <db:section xml:id="data">
         <db:title>char * QByteArray::data()</db:title>
         <db:para>Returns a pointer to the data stored in the byte array. The
                                    pointer can be used to access and modify the bytes that compose
                                    the array. The data is '\0'-terminated, i.e. the number of bytes
                                    in the returned character string is <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code> + 1 for the '\0'
                                    terminator.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray ba("Hello world"); char*data = ba.data(); while (*data) { cout &lt;&lt;"["&lt;&lt;*data &lt;&lt;"]"&lt;&lt; endl; ++data; }</db:programlisting>
         <db:para>The pointer remains valid as long as the byte array isn't
                                    reallocated or destroyed. For read-only access, <db:code><db:link xlink:href="qbytearray.html#constData">constData</db:link>()</db:code> is
                                    faster because it never causes a <db:link xlink:href="implicit-sharing.html#deep-copy">deep copy</db:link> to
                                    occur.</db:para>
         <db:para>This function is mostly useful to pass a byte array to a
                                    function that accepts a <db:code>const char
                                    *</db:code>.</db:para>
         <db:para>The following example makes a copy of the char* returned by
                                    data(), but it will corrupt the heap and cause a crash because
                                    it does not allocate a byte for the '\0' at the end:</db:para>
         <db:programlisting>QString tmp
                                        ="test"; QByteArray text = tmp.toLocal8Bit(); char*data =newchar[text.size()]; strcpy(data, text.data()); delete[] data;</db:programlisting>
         <db:para>This one allocates the correct amount of space:</db:para>
         <db:programlisting>QString tmp
                                        ="test"; QByteArray text = tmp.toLocal8Bit(); char*data =newchar[text.size() +1]; strcpy(data, text.data()); delete[] data;</db:programlisting>
         <db:para>Note: A <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>
                                    can store any byte values including '\0's, but most functions
                                    that take <db:code>char *</db:code> arguments assume that
                                    the data ends at the first '\0' they encounter.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#constData">constData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-5b-5d">operator[]</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="data-2">
         <db:title>const char * QByteArray::data() const</db:title>
         <db:para>This is an overloaded function.</db:para>
      </db:section>
      <db:section xml:id="endsWith">
         <db:title>bool QByteArray::endsWith(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns <db:code>true</db:code> if this byte array ends
                                    with byte array <db:emphasis>ba</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray url("http://qt-project.org/doc/qt-5.0/qtdoc/index.html");
                                        if (url.endsWith(".html")) ...</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#startsWith">startsWith</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#right">right</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="endsWith-2">
         <db:title>bool QByteArray::endsWith(const char * str) const</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if this byte array ends
                                    with string <db:emphasis>str</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="endsWith-3">
         <db:title>bool QByteArray::endsWith(char ch) const</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if this byte array ends
                                    with character <db:emphasis>ch</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="fill">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Sets every byte in the byte array to character
                                        <db:emphasis>ch</db:emphasis>. If <db:emphasis>size</db:emphasis> is different
                                    from -1 (the default), the byte array is resized to size
                                        <db:emphasis>size</db:emphasis> beforehand.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray ba("Istambul"); ba.fill('o'); // ba ==
                                        "oooooooo" ba.fill('X',2); // ba == "XX"</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#resize">resize</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="fromBase64">
         <db:title>[static] <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a decoded copy of the Base64 array
                                        <db:emphasis>base64</db:emphasis>. Input is not checked for validity;
                                    invalid characters in the input are skipped, enabling the
                                    decoding process to continue with subsequent
                                    characters.</db:para>
         <db:para>For example:</db:para>
         <db:programlisting>QByteArray text =QByteArray::fromBase64("UXQgaXMgZ3JlYXQh"); text.data(); // returns "Qt is
                                    great!"</db:programlisting>
         <db:para>The algorithm used to decode Base64-encoded data is defined
                                    in <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt">RFC
                                        4648</db:link>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toBase64">toBase64</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="fromBase64-2">
         <db:title>[static] <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#Base64Option-enum">Base64Options</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns a decoded copy of the Base64 array
                                        <db:emphasis>base64</db:emphasis>, using the alphabet defined by
                                        <db:emphasis>options</db:emphasis>. Input is not checked for validity;
                                    invalid characters in the input are skipped, enabling the
                                    decoding process to continue with subsequent
                                    characters.</db:para>
         <db:para>For example:</db:para>
         <db:programlisting>QByteArray::fromBase64("PHA+SGVsbG8/PC9wPg==",QByteArray::Base64Encoding); // returns "&lt;p&gt;Hello?&lt;/p&gt;"QByteArray::fromBase64("PHA-SGVsbG8_PC9wPg==",QByteArray::Base64UrlEncoding); // returns
                                        "&lt;p&gt;Hello?&lt;/p&gt;"</db:programlisting>
         <db:para>The algorithm used to decode Base64-encoded data is defined
                                    in <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt">RFC
                                        4648</db:link>.</db:para>
         <db:para>This function was introduced in Qt 5.2.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toBase64">toBase64</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="fromCFData">
         <db:title>[static] <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Constructs a new <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> containing a copy of the CFData
                                        <db:emphasis>data</db:emphasis>.</db:para>
         <db:para>This function was introduced in Qt 5.3.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawCFData">fromRawCFData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData">fromRawData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toRawCFData">toRawCFData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toCFData">toCFData</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="fromHex">
         <db:title>[static] <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a decoded copy of the hex encoded array
                                        <db:emphasis>hexEncoded</db:emphasis>. Input is not checked for
                                    validity; invalid characters in the input are skipped, enabling
                                    the decoding process to continue with subsequent
                                    characters.</db:para>
         <db:para>For example:</db:para>
         <db:programlisting>QByteArray text =QByteArray::fromHex("517420697320677265617421"); text.data(); // returns "Qt is
                                    great!"</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toHex">toHex</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="fromNSData">
         <db:title>[static] <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Constructs a new <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> containing a copy of the NSData
                                        <db:emphasis>data</db:emphasis>.</db:para>
         <db:para>This function was introduced in Qt 5.3.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawNSData">fromRawNSData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData">fromRawData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toNSData">toNSData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toRawNSData">toRawNSData</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="fromPercentEncoding">
         <db:title>[static] <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a decoded copy of the URI/URL-style percent-encoded
                                        <db:emphasis>input</db:emphasis>. The <db:emphasis>percent</db:emphasis>
                                    parameter allows you to replace the '%' character for another
                                    (for instance, '_' or '=').</db:para>
         <db:para>For example:</db:para>
         <db:programlisting>QByteArray text =QByteArray::fromPercentEncoding("Qt%20is%20great%33"); text.data(); // returns "Qt is
                                    great!"</db:programlisting>
         <db:para>This function was introduced in Qt 4.4.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toPercentEncoding">toPercentEncoding</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qurl.html#fromPercentEncoding">QUrl::fromPercentEncoding</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="fromRawCFData">
         <db:title>[static] <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Constructs a <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> that uses the bytes of the CFData
                                        <db:emphasis>data</db:emphasis>.</db:para>
         <db:para>The <db:emphasis>data</db:emphasis>'s bytes are not copied.</db:para>
         <db:para>The caller guarantees that the CFData will not be deleted or
                                    modified as long as this <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> object exists.</db:para>
         <db:para>This function was introduced in Qt 5.3.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromCFData">fromCFData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData">fromRawData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toRawCFData">toRawCFData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toCFData">toCFData</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="fromRawData">
         <db:title>[static] <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Constructs a <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> that uses the first
                                        <db:emphasis>size</db:emphasis> bytes of the <db:emphasis>data</db:emphasis>
                                    array. The bytes are <db:emphasis>not</db:emphasis> copied. The <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> will contain the
                                        <db:emphasis>data</db:emphasis> pointer. The caller guarantees that
                                        <db:emphasis>data</db:emphasis> will not be deleted or modified as
                                    long as this <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>
                                    and any copies of it exist that have not been modified. In other
                                    words, because <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> is an <db:link xlink:href="implicit-sharing.html#implicitly-shared">implicitly
                                        shared</db:link> class and the instance returned by this
                                    function contains the <db:emphasis>data</db:emphasis> pointer, the caller
                                    must not delete <db:emphasis>data</db:emphasis> or modify it directly as
                                    long as the returned <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> and any copies exist. However, <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> does not take
                                    ownership of <db:emphasis>data</db:emphasis>, so the <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> destructor will
                                    never delete the raw <db:emphasis>data</db:emphasis>, even when the last
                                        <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> referring
                                    to <db:emphasis>data</db:emphasis> is destroyed.</db:para>
         <db:para>A subsequent attempt to modify the contents of the returned
                                        <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> or any
                                    copy made from it will cause it to create a deep copy of the
                                        <db:emphasis>data</db:emphasis> array before doing the modification.
                                    This ensures that the raw <db:emphasis>data</db:emphasis> array itself
                                    will never be modified by <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>.</db:para>
         <db:para>Here is an example of how to read data using a <db:code><db:link xlink:href="qdatastream.html">QDataStream</db:link></db:code> on raw data in
                                    memory without copying the raw data into a <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>:</db:para>
         <db:programlisting>staticconstchar mydata[]= { 0x00,0x00,0x03,0x84,0x78,0x9c,0x3b,0x76,0xec,0x18,0xc3,0x31,0x0a,0xf1,0xcc,0x99,...0x6d,0x5b }; QByteArray data =QByteArray::fromRawData(mydata,sizeof(mydata));
                                        QDataStream in(&amp;data,QIODevice::ReadOnly); ...</db:programlisting>
         <db:warning>
            <db:para> A byte array created with
                                    fromRawData() is <db:emphasis>not</db:emphasis> null-terminated, unless
                                    the raw data contains a 0 character at position
                                        <db:emphasis>size</db:emphasis>. While that does not matter for
                                        <db:code><db:link xlink:href="qdatastream.html">QDataStream</db:link></db:code> or
                                    functions like <db:code><db:link xlink:href="qbytearray.html#indexOf">indexOf</db:link>()</db:code>, passing the byte array to a function
                                    accepting a <db:code>const char *</db:code> expected to be
                                    '\0'-terminated will fail.</db:para>
         </db:warning>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#setRawData">setRawData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#data">data</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#constData">constData</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="fromRawNSData">
         <db:title>[static] <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Constructs a <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> that uses the bytes of the NSData
                                        <db:emphasis>data</db:emphasis>.</db:para>
         <db:para>The <db:emphasis>data</db:emphasis>'s bytes are not copied.</db:para>
         <db:para>The caller guarantees that the NSData will not be deleted or
                                    modified as long as this <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> object exists.</db:para>
         <db:para>This function was introduced in Qt 5.3.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromNSData">fromNSData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData">fromRawData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toRawNSData">toRawNSData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toNSData">toNSData</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="fromStdString">
         <db:title>[static] <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a copy of the <db:emphasis>str</db:emphasis> string as a
                                        <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>.</db:para>
         <db:para>This function was introduced in Qt 5.4.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toStdString">toStdString</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qstring.html#fromStdString">QString::fromStdString</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="indexOf">
         <db:title>int QByteArray::indexOf(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns the index position of the first occurrence of the
                                    byte array <db:emphasis>ba</db:emphasis> in this byte array, searching
                                    forward from index position <db:emphasis>from</db:emphasis>. Returns -1 if
                                        <db:emphasis>ba</db:emphasis> could not be found.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray x("sticky question"); QByteArray y("sti"); x.indexOf(y); // returns 0 x.indexOf(y,1); // returns 10 x.indexOf(y,10); // returns 10 x.indexOf(y,11); // returns -1</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#lastIndexOf">lastIndexOf</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#contains">contains</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#count">count</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="indexOf-2">
         <db:title>int QByteArray::indexOf(const <db:link xlink:href="qstring.html">QString</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns the index position of the first occurrence of the
                                    string <db:emphasis>str</db:emphasis> in the byte array, searching forward
                                    from index position <db:emphasis>from</db:emphasis>. Returns -1 if
                                        <db:emphasis>str</db:emphasis> could not be found.</db:para>
         <db:para>The Unicode data is converted into 8-bit characters using
                                        <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code>.</db:para>
         <db:para>You can disable this function by defining
                                        <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile
                                    your applications. You then need to call <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code> (or
                                        <db:code><db:link xlink:href="qstring.html#toLatin1">QString::toLatin1</db:link>()</db:code> or <db:code><db:link xlink:href="qstring.html#toLocal8Bit">QString::toLocal8Bit</db:link>()</db:code>) explicitly if you want to
                                    convert the data to <db:code>const char
                                    *</db:code>.</db:para>
      </db:section>
      <db:section xml:id="indexOf-3">
         <db:title>int QByteArray::indexOf(const char * str, int from = 0) const</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns the index position of the first occurrence of the
                                    string <db:emphasis>str</db:emphasis> in the byte array, searching forward
                                    from index position <db:emphasis>from</db:emphasis>. Returns -1 if
                                        <db:emphasis>str</db:emphasis> could not be found.</db:para>
      </db:section>
      <db:section xml:id="indexOf-4">
         <db:title>int QByteArray::indexOf(char ch, int from = 0) const</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns the index position of the first occurrence of the
                                    character <db:emphasis>ch</db:emphasis> in the byte array, searching
                                    forward from index position <db:emphasis>from</db:emphasis>. Returns -1 if
                                        <db:emphasis>ch</db:emphasis> could not be found.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray ba("ABCBA"); ba.indexOf("B"); // returns 1 ba.indexOf("B",1); // returns 1 ba.indexOf("B",2); // returns 3 ba.indexOf("X"); // returns -1</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#lastIndexOf">lastIndexOf</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#contains">contains</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="insert">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Inserts the byte array <db:emphasis>ba</db:emphasis> at index position
                                        <db:emphasis>i</db:emphasis> and returns a reference to this byte
                                    array.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray ba("Meal"); ba.insert(1,QByteArray("ontr")); // ba ==
                                        "Montreal"</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#append">append</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#prepend">prepend</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#replace">replace</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#remove">remove</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="insert-2">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qstring.html">QString</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Inserts the string <db:emphasis>str</db:emphasis> at index position
                                        <db:emphasis>i</db:emphasis> in the byte array. The Unicode data is
                                    converted into 8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code>.</db:para>
         <db:para>If <db:emphasis>i</db:emphasis> is greater than <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>, the array is
                                    first extended using <db:code><db:link xlink:href="qbytearray.html#resize">resize</db:link>()</db:code>.</db:para>
         <db:para>You can disable this function by defining
                                        <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile
                                    your applications. You then need to call <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code> (or
                                        <db:code><db:link xlink:href="qstring.html#toLatin1">QString::toLatin1</db:link>()</db:code> or <db:code><db:link xlink:href="qstring.html#toLocal8Bit">QString::toLocal8Bit</db:link>()</db:code>) explicitly if you want to
                                    convert the data to <db:code>const char
                                    *</db:code>.</db:para>
      </db:section>
      <db:section xml:id="insert-3">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Inserts the string <db:emphasis>str</db:emphasis> at position
                                        <db:emphasis>i</db:emphasis> in the byte array.</db:para>
         <db:para>If <db:emphasis>i</db:emphasis> is greater than <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>, the array is
                                    first extended using <db:code><db:link xlink:href="qbytearray.html#resize">resize</db:link>()</db:code>.</db:para>
      </db:section>
      <db:section xml:id="insert-4">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Inserts <db:emphasis>len</db:emphasis> bytes of the string
                                        <db:emphasis>str</db:emphasis> at position <db:emphasis>i</db:emphasis> in the
                                    byte array.</db:para>
         <db:para>If <db:emphasis>i</db:emphasis> is greater than <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>, the array is
                                    first extended using <db:code><db:link xlink:href="qbytearray.html#resize">resize</db:link>()</db:code>.</db:para>
         <db:para>This function was introduced in Qt 4.6.</db:para>
      </db:section>
      <db:section xml:id="insert-5">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Inserts character <db:emphasis>ch</db:emphasis> at index position
                                        <db:emphasis>i</db:emphasis> in the byte array. If <db:emphasis>i</db:emphasis>
                                    is greater than <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>, the array is first extended using <db:code><db:link xlink:href="qbytearray.html#resize">resize</db:link>()</db:code>.</db:para>
      </db:section>
      <db:section xml:id="isEmpty">
         <db:title>bool QByteArray::isEmpty() const</db:title>
         <db:para>Returns <db:code>true</db:code> if the byte array has
                                    size 0; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray().isEmpty(); // returns trueQByteArray("").isEmpty(); // returns
                                        trueQByteArray("abc").isEmpty(); // returns
                                        false</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="isNull">
         <db:title>bool QByteArray::isNull() const</db:title>
         <db:para>Returns <db:code>true</db:code> if this byte array is
                                    null; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray().isNull(); // returns trueQByteArray("").isNull(); // returns
                                        falseQByteArray("abc").isNull(); // returns
                                        false</db:programlisting>
         <db:para>Qt makes a distinction between null byte arrays and empty
                                    byte arrays for historical reasons. For most applications, what
                                    matters is whether or not a byte array contains any data, and
                                    this can be determined using <db:code><db:link xlink:href="qbytearray.html#isEmpty">isEmpty</db:link>()</db:code>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#isEmpty">isEmpty</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="lastIndexOf">
         <db:title>int QByteArray::lastIndexOf(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns the index position of the last occurrence of the
                                    byte array <db:emphasis>ba</db:emphasis> in this byte array, searching
                                    backward from index position <db:emphasis>from</db:emphasis>. If
                                        <db:emphasis>from</db:emphasis> is -1 (the default), the search starts
                                    at the last byte. Returns -1 if <db:emphasis>ba</db:emphasis> could not be
                                    found.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray x("crazy azimuths"); QByteArray y("az"); x.lastIndexOf(y); // returns 6 x.lastIndexOf(y,6); // returns 6 x.lastIndexOf(y,5); // returns 2 x.lastIndexOf(y,1); // returns -1</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#indexOf">indexOf</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#contains">contains</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#count">count</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="lastIndexOf-2">
         <db:title>int QByteArray::lastIndexOf(const <db:link xlink:href="qstring.html">QString</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns the index position of the last occurrence of the
                                    string <db:emphasis>str</db:emphasis> in the byte array, searching
                                    backward from index position <db:emphasis>from</db:emphasis>. If
                                        <db:emphasis>from</db:emphasis> is -1 (the default), the search starts
                                    at the last (<db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>
                                    - 1) byte. Returns -1 if <db:emphasis>str</db:emphasis> could not be
                                    found.</db:para>
         <db:para>The Unicode data is converted into 8-bit characters using
                                        <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code>.</db:para>
         <db:para>You can disable this function by defining
                                        <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile
                                    your applications. You then need to call <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code> (or
                                        <db:code><db:link xlink:href="qstring.html#toLatin1">QString::toLatin1</db:link>()</db:code> or <db:code><db:link xlink:href="qstring.html#toLocal8Bit">QString::toLocal8Bit</db:link>()</db:code>) explicitly if you want to
                                    convert the data to <db:code>const char
                                    *</db:code>.</db:para>
      </db:section>
      <db:section xml:id="lastIndexOf-3">
         <db:title>int QByteArray::lastIndexOf(const char * str, int from = -1) const</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns the index position of the last occurrence of the
                                    string <db:emphasis>str</db:emphasis> in the byte array, searching
                                    backward from index position <db:emphasis>from</db:emphasis>. If
                                        <db:emphasis>from</db:emphasis> is -1 (the default), the search starts
                                    at the last (<db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>
                                    - 1) byte. Returns -1 if <db:emphasis>str</db:emphasis> could not be
                                    found.</db:para>
      </db:section>
      <db:section xml:id="lastIndexOf-4">
         <db:title>int QByteArray::lastIndexOf(char ch, int from = -1) const</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns the index position of the last occurrence of
                                    character <db:emphasis>ch</db:emphasis> in the byte array, searching
                                    backward from index position <db:emphasis>from</db:emphasis>. If
                                        <db:emphasis>from</db:emphasis> is -1 (the default), the search starts
                                    at the last (<db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>
                                    - 1) byte. Returns -1 if <db:emphasis>ch</db:emphasis> could not be
                                    found.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray ba("ABCBA"); ba.lastIndexOf("B"); // returns 3 ba.lastIndexOf("B",3); // returns 3 ba.lastIndexOf("B",2); // returns 1 ba.lastIndexOf("X"); // returns -1</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#indexOf">indexOf</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#contains">contains</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="left">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a byte array that contains the leftmost
                                        <db:emphasis>len</db:emphasis> bytes of this byte array.</db:para>
         <db:para>The entire byte array is returned if <db:emphasis>len</db:emphasis> is
                                    greater than <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray x("Pineapple"); QByteArray y = x.left(4);
                                        // y ==
                                    "Pine"</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#right">right</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#mid">mid</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#startsWith">startsWith</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#truncate">truncate</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="leftJustified">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a byte array of size <db:emphasis>width</db:emphasis> that
                                    contains this byte array padded by the <db:emphasis>fill</db:emphasis>
                                    character.</db:para>
         <db:para>If <db:emphasis>truncate</db:emphasis> is false and the <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code> of the byte
                                    array is more than <db:emphasis>width</db:emphasis>, then the returned
                                    byte array is a copy of this byte array.</db:para>
         <db:para>If <db:emphasis>truncate</db:emphasis> is true and the <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code> of the byte
                                    array is more than <db:emphasis>width</db:emphasis>, then any bytes in a
                                    copy of the byte array after position <db:emphasis>width</db:emphasis> are
                                    removed, and the copy is returned.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray x("apple"); QByteArray y = x.leftJustified(8,'.'); // y == "apple..."</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#rightJustified">rightJustified</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="length">
         <db:title>int QByteArray::length() const</db:title>
         <db:para>Same as <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>.</db:para>
      </db:section>
      <db:section xml:id="mid">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a byte array containing <db:emphasis>len</db:emphasis> bytes
                                    from this byte array, starting at position
                                    <db:emphasis>pos</db:emphasis>.</db:para>
         <db:para>If <db:emphasis>len</db:emphasis> is -1 (the default), or
                                        <db:emphasis>pos</db:emphasis> + <db:emphasis>len</db:emphasis> &gt;= <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>, returns a byte
                                    array containing all bytes starting at position
                                        <db:emphasis>pos</db:emphasis> until the end of the byte
                                    array.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray x("Five pineapples"); QByteArray y = x.mid(5,4); // y == "pine"QByteArray z = x.mid(5);
                                        // z ==
                                    "pineapples"</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#left">left</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#right">right</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="number">
         <db:title>[static] <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a byte array containing the string equivalent of the
                                    number <db:emphasis>n</db:emphasis> to base <db:emphasis>base</db:emphasis> (10 by
                                    default). The <db:emphasis>base</db:emphasis> can be any value between 2
                                    and 36.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>int n
                                        =63; QByteArray::number(n); // returns "63"QByteArray::number(n,16); // returns "3f"QByteArray::number(n,16).toUpper(); // returns "3F"</db:programlisting>
         <db:note>
            <db:para>The format of the number is not
                                    localized; the default C locale is used irrespective of the
                                    user's locale.</db:para>
         </db:note>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#setNum">setNum</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toInt">toInt</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="number-2">
         <db:title>[static] <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qtglobal.html#uint-typedef">uint</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toUInt">toUInt</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="number-3">
         <db:title>[static] <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qtglobal.html#qlonglong-typedef">qlonglong</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toLongLong">toLongLong</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="number-4">
         <db:title>[static] <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qtglobal.html#qulonglong-typedef">qulonglong</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toULongLong">toULongLong</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="number-5">
         <db:title>[static] <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns a byte array that contains the printed value of
                                        <db:emphasis>n</db:emphasis>, formatted in format <db:emphasis>f</db:emphasis>
                                    with precision <db:emphasis>prec</db:emphasis>.</db:para>
         <db:para>Argument <db:emphasis>n</db:emphasis> is formatted according to the
                                        <db:emphasis>f</db:emphasis> format specified, which is
                                        <db:code>g</db:code> by default, and can be any of the
                                    following:</db:para>
         <db:informaltable>
            <db:thead>
               <db:tr>
                  <db:th>
                     <db:para>Format</db:para>
                  </db:th>
                  <db:th>
                     <db:para>Meaning</db:para>
                  </db:th>
               </db:tr>
            </db:thead>
            <db:tbody>
               <db:tr>
                  <db:td>
                     <db:para>
                        <db:code>e</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>format as [-]9.9e[+|-]999</db:para>
                  </db:td>
               </db:tr>
               <db:tr>
                  <db:td>
                     <db:para>
                        <db:code>E</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>format as [-]9.9E[+|-]999</db:para>
                  </db:td>
               </db:tr>
               <db:tr>
                  <db:td>
                     <db:para>
                        <db:code>f</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>format as [-]9.9</db:para>
                  </db:td>
               </db:tr>
               <db:tr>
                  <db:td>
                     <db:para>
                        <db:code>g</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>use <db:code>e</db:code> or
                                                  <db:code>f</db:code> format, whichever is the
                                                  most concise</db:para>
                  </db:td>
               </db:tr>
               <db:tr>
                  <db:td>
                     <db:para>
                        <db:code>G</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>use <db:code>E</db:code> or
                                                  <db:code>f</db:code> format, whichever is the
                                                  most concise</db:para>
                  </db:td>
               </db:tr>
            </db:tbody>
         </db:informaltable>
         <db:para>With 'e', 'E', and 'f', <db:emphasis>prec</db:emphasis> is the number
                                    of digits after the decimal point. With 'g' and 'G',
                                        <db:emphasis>prec</db:emphasis> is the maximum number of significant
                                    digits (trailing zeroes are omitted).</db:para>
         <db:programlisting>QByteArray ba =QByteArray::number(12.3456,'E',3); // ba == 1.235E+01</db:programlisting>
         <db:note>
            <db:para>The format of the number is not
                                    localized; the default C locale is used irrespective of the
                                    user's locale.</db:para>
         </db:note>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toDouble">toDouble</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="prepend">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Prepends the byte array <db:emphasis>ba</db:emphasis> to this byte
                                    array and returns a reference to this byte array.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray x("ship"); QByteArray y("air"); x.prepend(y); // x ==
                                        "airship"</db:programlisting>
         <db:para>This is the same as insert(0, <db:emphasis>ba</db:emphasis>).</db:para>
         <db:para>Note: <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> is
                                    an <db:link xlink:href="implicit-sharing.html#implicitly-shared">implicitly shared</db:link> class. Consequently, if
                                        <db:emphasis>this</db:emphasis> is an empty <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>, then
                                        <db:emphasis>this</db:emphasis> will just share the data held in
                                        <db:emphasis>ba</db:emphasis>. In this case, no copying of data is
                                    done, taking <db:link xlink:href="containers.html#constant-time">constant time</db:link>. If a shared instance is modified,
                                    it will be copied (copy-on-write), taking <db:link xlink:href="containers.html#linear-time">linear
                                    time</db:link>.</db:para>
         <db:para>If <db:emphasis>this</db:emphasis> is not an empty <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>, a deep copy of
                                    the data is performed, taking <db:link xlink:href="containers.html#linear-time">linear
                                    time</db:link>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#append">append</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#insert">insert</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="prepend-2">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Prepends the string <db:emphasis>str</db:emphasis> to this byte
                                    array.</db:para>
      </db:section>
      <db:section xml:id="prepend-3">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Prepends <db:emphasis>len</db:emphasis> bytes of the string
                                        <db:emphasis>str</db:emphasis> to this byte array.</db:para>
         <db:para>This function was introduced in Qt 4.6.</db:para>
      </db:section>
      <db:section xml:id="prepend-4">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Prepends the character <db:emphasis>ch</db:emphasis> to this byte
                                    array.</db:para>
      </db:section>
      <db:section xml:id="push_back">
         <db:title>void QByteArray::push_back(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This function is provided for STL compatibility. It is
                                    equivalent to append(<db:emphasis>other</db:emphasis>).</db:para>
      </db:section>
      <db:section xml:id="push_back-2">
         <db:title>void QByteArray::push_back(const char * str)</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Same as append(<db:emphasis>str</db:emphasis>).</db:para>
      </db:section>
      <db:section xml:id="push_back-3">
         <db:title>void QByteArray::push_back(char ch)</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Same as append(<db:emphasis>ch</db:emphasis>).</db:para>
      </db:section>
      <db:section xml:id="push_front">
         <db:title>void QByteArray::push_front(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This function is provided for STL compatibility. It is
                                    equivalent to prepend(<db:emphasis>other</db:emphasis>).</db:para>
      </db:section>
      <db:section xml:id="push_front-2">
         <db:title>void QByteArray::push_front(const char * str)</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Same as prepend(<db:emphasis>str</db:emphasis>).</db:para>
      </db:section>
      <db:section xml:id="push_front-3">
         <db:title>void QByteArray::push_front(char ch)</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Same as prepend(<db:emphasis>ch</db:emphasis>).</db:para>
      </db:section>
      <db:section xml:id="remove">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Removes <db:emphasis>len</db:emphasis> bytes from the array, starting
                                    at index position <db:emphasis>pos</db:emphasis>, and returns a reference
                                    to the array.</db:para>
         <db:para>If <db:emphasis>pos</db:emphasis> is out of range, nothing happens. If
                                        <db:emphasis>pos</db:emphasis> is valid, but <db:emphasis>pos</db:emphasis> +
                                        <db:emphasis>len</db:emphasis> is larger than the size of the array,
                                    the array is truncated at position
                                    <db:emphasis>pos</db:emphasis>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray ba("Montreal"); ba.remove(1,4); // ba == "Meal"</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#insert">insert</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#replace">replace</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="repeated">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a copy of this byte array repeated the specified
                                    number of <db:emphasis>times</db:emphasis>.</db:para>
         <db:para>If <db:emphasis>times</db:emphasis> is less than 1, an empty byte
                                    array is returned.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray ba("ab"); ba.repeated(4); //
                                        returns "abababab"</db:programlisting>
         <db:para>This function was introduced in Qt 4.5.</db:para>
      </db:section>
      <db:section xml:id="replace">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Replaces <db:emphasis>len</db:emphasis> bytes from index position
                                        <db:emphasis>pos</db:emphasis> with the byte array
                                        <db:emphasis>after</db:emphasis>, and returns a reference to this byte
                                    array.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray x("Say yes!"); QByteArray y("no"); x.replace(4,3, y); // x == "Say no!"</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#insert">insert</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#remove">remove</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="replace-2">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces <db:emphasis>len</db:emphasis> bytes from index position
                                        <db:emphasis>pos</db:emphasis> with the zero terminated string
                                        <db:emphasis>after</db:emphasis>.</db:para>
         <db:para>Notice: this can change the length of the byte
                                    array.</db:para>
      </db:section>
      <db:section xml:id="replace-3">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces <db:emphasis>len</db:emphasis> bytes from index position
                                        <db:emphasis>pos</db:emphasis> with <db:emphasis>alen</db:emphasis> bytes from
                                    the string <db:emphasis>after</db:emphasis>. <db:emphasis>after</db:emphasis> is
                                    allowed to have '\0' characters.</db:para>
         <db:para>This function was introduced in Qt 4.7.</db:para>
      </db:section>
      <db:section xml:id="replace-4">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the byte array
                                        <db:emphasis>before</db:emphasis> with the byte array
                                        <db:emphasis>after</db:emphasis>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray ba("colour behaviour flavour
                                        neighbour"); ba.replace(QByteArray("ou"),QByteArray("o")); // ba ==
                                        "color behavior flavor neighbor"</db:programlisting>
      </db:section>
      <db:section xml:id="replace-5">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the string
                                        <db:emphasis>before</db:emphasis> with the byte array
                                        <db:emphasis>after</db:emphasis>.</db:para>
      </db:section>
      <db:section xml:id="replace-6">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the string
                                        <db:emphasis>before</db:emphasis> with the string
                                        <db:emphasis>after</db:emphasis>. Since the sizes of the strings are
                                    given by <db:emphasis>bsize</db:emphasis> and <db:emphasis>asize</db:emphasis>, they
                                    may contain zero characters and do not need to be
                                    zero-terminated.</db:para>
      </db:section>
      <db:section xml:id="replace-7">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the byte array
                                        <db:emphasis>before</db:emphasis> with the string
                                        <db:emphasis>after</db:emphasis>.</db:para>
      </db:section>
      <db:section xml:id="replace-8">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qstring.html">QString</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the string
                                        <db:emphasis>before</db:emphasis> with the byte array
                                        <db:emphasis>after</db:emphasis>. The Unicode data is converted into
                                    8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code>.</db:para>
         <db:para>You can disable this function by defining
                                        <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile
                                    your applications. You then need to call <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code> (or
                                        <db:code><db:link xlink:href="qstring.html#toLatin1">QString::toLatin1</db:link>()</db:code> or <db:code><db:link xlink:href="qstring.html#toLocal8Bit">QString::toLocal8Bit</db:link>()</db:code>) explicitly if you want to
                                    convert the data to <db:code>const char
                                    *</db:code>.</db:para>
      </db:section>
      <db:section xml:id="replace-9">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qstring.html">QString</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the string
                                        <db:emphasis>before</db:emphasis> with the string
                                        <db:emphasis>after</db:emphasis>.</db:para>
      </db:section>
      <db:section xml:id="replace-10">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the string
                                        <db:emphasis>before</db:emphasis> with the string
                                        <db:emphasis>after</db:emphasis>.</db:para>
      </db:section>
      <db:section xml:id="replace-11">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the character
                                        <db:emphasis>before</db:emphasis> with the byte array
                                        <db:emphasis>after</db:emphasis>.</db:para>
      </db:section>
      <db:section xml:id="replace-12">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qstring.html">QString</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the character
                                        <db:emphasis>before</db:emphasis> with the string
                                        <db:emphasis>after</db:emphasis>. The Unicode data is converted into
                                    8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code>.</db:para>
         <db:para>You can disable this function by defining
                                        <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile
                                    your applications. You then need to call <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code> (or
                                        <db:code><db:link xlink:href="qstring.html#toLatin1">QString::toLatin1</db:link>()</db:code> or <db:code><db:link xlink:href="qstring.html#toLocal8Bit">QString::toLocal8Bit</db:link>()</db:code>) explicitly if you want to
                                    convert the data to <db:code>const char
                                    *</db:code>.</db:para>
      </db:section>
      <db:section xml:id="replace-13">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the character
                                        <db:emphasis>before</db:emphasis> with the string
                                        <db:emphasis>after</db:emphasis>.</db:para>
      </db:section>
      <db:section xml:id="replace-14">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the character
                                        <db:emphasis>before</db:emphasis> with the character
                                        <db:emphasis>after</db:emphasis>.</db:para>
      </db:section>
      <db:section xml:id="reserve">
         <db:title>void QByteArray::reserve(int size)</db:title>
         <db:para>Attempts to allocate memory for at least
                                        <db:emphasis>size</db:emphasis> bytes. If you know in advance how
                                    large the byte array will be, you can call this function, and if
                                    you call <db:code><db:link xlink:href="qbytearray.html#resize">resize</db:link>()</db:code>
                                    often you are likely to get better performance. If
                                        <db:emphasis>size</db:emphasis> is an underestimate, the worst that
                                    will happen is that the <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> will be a bit slower.</db:para>
         <db:para>The sole purpose of this function is to provide a means of
                                    fine tuning <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>'s
                                    memory usage. In general, you will rarely ever need to call this
                                    function. If you want to change the size of the byte array, call
                                        <db:code><db:link xlink:href="qbytearray.html#resize">resize</db:link>()</db:code>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#squeeze">squeeze</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#capacity">capacity</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="resize">
         <db:title>void QByteArray::resize(int size)</db:title>
         <db:para>Sets the size of the byte array to <db:emphasis>size</db:emphasis>
                                    bytes.</db:para>
         <db:para>If <db:emphasis>size</db:emphasis> is greater than the current size,
                                    the byte array is extended to make it <db:emphasis>size</db:emphasis>
                                    bytes with the extra bytes added to the end. The new bytes are
                                    uninitialized.</db:para>
         <db:para>If <db:emphasis>size</db:emphasis> is less than the current size,
                                    bytes are removed from the end.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#truncate">truncate</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="right">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a byte array that contains the rightmost
                                        <db:emphasis>len</db:emphasis> bytes of this byte array.</db:para>
         <db:para>The entire byte array is returned if <db:emphasis>len</db:emphasis> is
                                    greater than <db:code><db:link xlink:href="qbytearray.html#size">size</db:link>()</db:code>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray x("Pineapple"); QByteArray y = x.right(5); // y ==
                                        "apple"</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#endsWith">endsWith</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#left">left</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#mid">mid</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="rightJustified">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a byte array of size <db:emphasis>width</db:emphasis> that
                                    contains the <db:emphasis>fill</db:emphasis> character followed by this
                                    byte array.</db:para>
         <db:para>If <db:emphasis>truncate</db:emphasis> is false and the size of the
                                    byte array is more than <db:emphasis>width</db:emphasis>, then the
                                    returned byte array is a copy of this byte array.</db:para>
         <db:para>If <db:emphasis>truncate</db:emphasis> is true and the size of the
                                    byte array is more than <db:emphasis>width</db:emphasis>, then the
                                    resulting byte array is truncated at position
                                        <db:emphasis>width</db:emphasis>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray x("apple"); QByteArray y = x.rightJustified(8,'.'); // y == "...apple"</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#leftJustified">leftJustified</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="setNum">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Sets the byte array to the printed value of
                                        <db:emphasis>n</db:emphasis> in base <db:emphasis>base</db:emphasis> (10 by
                                    default) and returns a reference to the byte array. The
                                        <db:emphasis>base</db:emphasis> can be any value between 2 and 36. For
                                    bases other than 10, n is treated as an unsigned
                                    integer.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray ba; int n =63; ba.setNum(n); // ba == "63" ba.setNum(n,16); // ba == "3f"</db:programlisting>
         <db:note>
            <db:para>The format of the number is not
                                    localized; the default C locale is used irrespective of the
                                    user's locale.</db:para>
         </db:note>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number">number</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toInt">toInt</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="setNum-2">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qtglobal.html#uint-typedef">uint</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toUInt">toUInt</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="setNum-3">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toShort">toShort</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="setNum-4">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qtglobal.html#ushort-typedef">ushort</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toUShort">toUShort</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="setNum-5">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qtglobal.html#qlonglong-typedef">qlonglong</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toLongLong">toLongLong</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="setNum-6">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qtglobal.html#qulonglong-typedef">qulonglong</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toULongLong">toULongLong</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="setNum-7">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Sets the byte array to the printed value of
                                        <db:emphasis>n</db:emphasis>, formatted in format <db:emphasis>f</db:emphasis>
                                    with precision <db:emphasis>prec</db:emphasis>, and returns a reference to
                                    the byte array.</db:para>
         <db:para>The format <db:emphasis>f</db:emphasis> can be any of the
                                    following:</db:para>
         <db:informaltable>
            <db:thead>
               <db:tr>
                  <db:th>
                     <db:para>Format</db:para>
                  </db:th>
                  <db:th>
                     <db:para>Meaning</db:para>
                  </db:th>
               </db:tr>
            </db:thead>
            <db:tbody>
               <db:tr>
                  <db:td>
                     <db:para>
                        <db:code>e</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>format as [-]9.9e[+|-]999</db:para>
                  </db:td>
               </db:tr>
               <db:tr>
                  <db:td>
                     <db:para>
                        <db:code>E</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>format as [-]9.9E[+|-]999</db:para>
                  </db:td>
               </db:tr>
               <db:tr>
                  <db:td>
                     <db:para>
                        <db:code>f</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>format as [-]9.9</db:para>
                  </db:td>
               </db:tr>
               <db:tr>
                  <db:td>
                     <db:para>
                        <db:code>g</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>use <db:code>e</db:code> or
                                                  <db:code>f</db:code> format, whichever is the
                                                  most concise</db:para>
                  </db:td>
               </db:tr>
               <db:tr>
                  <db:td>
                     <db:para>
                        <db:code>G</db:code>
                     </db:para>
                  </db:td>
                  <db:td>
                     <db:para>use <db:code>E</db:code> or
                                                  <db:code>f</db:code> format, whichever is the
                                                  most concise</db:para>
                  </db:td>
               </db:tr>
            </db:tbody>
         </db:informaltable>
         <db:para>With 'e', 'E', and 'f', <db:emphasis>prec</db:emphasis> is the number
                                    of digits after the decimal point. With 'g' and 'G',
                                        <db:emphasis>prec</db:emphasis> is the maximum number of significant
                                    digits (trailing zeroes are omitted).</db:para>
         <db:note>
            <db:para>The format of the number is not
                                    localized; the default C locale is used irrespective of the
                                    user's locale.</db:para>
         </db:note>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toDouble">toDouble</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="setNum-8">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Sets the byte array to the printed value of
                                        <db:emphasis>n</db:emphasis>, formatted in format <db:emphasis>f</db:emphasis>
                                    with precision <db:emphasis>prec</db:emphasis>, and returns a reference to
                                    the byte array.</db:para>
         <db:note>
            <db:para>The format of the number is not
                                    localized; the default C locale is used irrespective of the
                                    user's locale.</db:para>
         </db:note>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toFloat">toFloat</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="setRawData">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qtglobal.html#uint-typedef">uint</db:link></db:title>
         <db:para>Resets the <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> to use the first <db:emphasis>size</db:emphasis>
                                    bytes of the <db:emphasis>data</db:emphasis> array. The bytes are
                                        <db:emphasis>not</db:emphasis> copied. The <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> will contain the
                                        <db:emphasis>data</db:emphasis> pointer. The caller guarantees that
                                        <db:emphasis>data</db:emphasis> will not be deleted or modified as
                                    long as this <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>
                                    and any copies of it exist that have not been modified.</db:para>
         <db:para>This function can be used instead of <db:code><db:link xlink:href="qbytearray.html#fromRawData">fromRawData</db:link>()</db:code> to
                                    re-use existing <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> objects to save memory
                                    re-allocations.</db:para>
         <db:para>This function was introduced in Qt 4.7.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData">fromRawData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#data">data</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#constData">constData</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="simplified">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a byte array that has whitespace removed from the
                                    start and the end, and which has each sequence of internal
                                    whitespace replaced with a single space.</db:para>
         <db:para>Whitespace means any character for which the standard C++
                                        <db:code>isspace()</db:code> function returns
                                        <db:code>true</db:code> in the C locale. This includes
                                    the ASCII isspace() function returns <db:code>true</db:code>
                                    in the C locale. This includes the ASCII characters '\t', '\n',
                                    '\v', '\f', '\r', and ' '.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray ba(" lots\t of\nwhitespace\r\n ");
                                    ba = ba.simplified(); // ba == "lots of
                                    whitespace";</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#trimmed">trimmed</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="size">
         <db:title>int QByteArray::size() const</db:title>
         <db:para>Returns the number of bytes in this byte array.</db:para>
         <db:para>The last byte in the byte array is at position size() - 1.
                                    In addition, <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>
                                    ensures that the byte at position size() is always '\0', so that
                                    you can use the return value of <db:code><db:link xlink:href="qbytearray.html#data">data</db:link>()</db:code> and <db:code><db:link xlink:href="qbytearray.html#constData">constData</db:link>()</db:code> as
                                    arguments to functions that expect '\0'-terminated strings. If
                                    the <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> object
                                    was created from a <db:link xlink:href="qbytearray.html#fromRawData">raw data</db:link> that didn't include the trailing
                                    null-termination character then <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> doesn't add it automaticall unless the
                                        <db:link xlink:href="implicit-sharing.html#deep-copy">deep
                                        copy</db:link> is created.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray ba("Hello"); int n =
                                        ba.size();
                                        // n == 5
                                        ba.data()[0];
                                        // returns 'H'
                                        ba.data()[4];
                                        // returns 'o'
                                        ba.data()[5];
                                        // returns
                                    '\0'</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#isEmpty">isEmpty</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#resize">resize</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="split">
         <db:title><db:link xlink:href="qlist.html">QList</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Splits the byte array into subarrays wherever
                                        <db:emphasis>sep</db:emphasis> occurs, and returns the list of those
                                    arrays. If <db:emphasis>sep</db:emphasis> does not match anywhere in the
                                    byte array, split() returns a single-element list containing
                                    this byte array.</db:para>
      </db:section>
      <db:section xml:id="squeeze">
         <db:title>void QByteArray::squeeze()</db:title>
         <db:para>Releases any memory not required to store the array's
                                    data.</db:para>
         <db:para>The sole purpose of this function is to provide a means of
                                    fine tuning <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>'s
                                    memory usage. In general, you will rarely ever need to call this
                                    function.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#reserve">reserve</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#capacity">capacity</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="startsWith">
         <db:title>bool QByteArray::startsWith(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns <db:code>true</db:code> if this byte array
                                    starts with byte array <db:emphasis>ba</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray url("ftp://ftp.qt-project.org/");
                                        if (url.startsWith("ftp:")) ...</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#endsWith">endsWith</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#left">left</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="startsWith-2">
         <db:title>bool QByteArray::startsWith(const char * str) const</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if this byte array
                                    starts with string <db:emphasis>str</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="startsWith-3">
         <db:title>bool QByteArray::startsWith(char ch) const</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if this byte array
                                    starts with character <db:emphasis>ch</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="swap">
         <db:title>void QByteArray::swap(<db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Swaps byte array <db:emphasis>other</db:emphasis> with this byte
                                    array. This operation is very fast and never fails.</db:para>
         <db:para>This function was introduced in Qt 4.8.</db:para>
      </db:section>
      <db:section xml:id="toBase64">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a copy of the byte array, encoded as
                                    Base64.</db:para>
         <db:programlisting>QByteArray text("Qt is great!"); text.toBase64(); // returns
                                    "UXQgaXMgZ3JlYXQh"</db:programlisting>
         <db:para>The algorithm used to encode Base64-encoded data is defined
                                    in <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt">RFC
                                        4648</db:link>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromBase64">fromBase64</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toBase64-2">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#Base64Option-enum">Base64Options</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns a copy of the byte array, encoded using the options
                                        <db:emphasis>options</db:emphasis>.</db:para>
         <db:programlisting>QByteArray text("&lt;p&gt;Hello?&lt;/p&gt;");
                                        text.toBase64(QByteArray::Base64Encoding |QByteArray::OmitTrailingEquals); // returns "PHA+SGVsbG8/PC9wPg"
                                        text.toBase64(QByteArray::Base64Encoding); // returns "PHA+SGVsbG8/PC9wPg=="
                                        text.toBase64(QByteArray::Base64UrlEncoding); // returns
                                        "PHA-SGVsbG8_PC9wPg==" text.toBase64(QByteArray::Base64UrlEncoding |QByteArray::OmitTrailingEquals); // returns
                                    "PHA-SGVsbG8_PC9wPg"</db:programlisting>
         <db:para>The algorithm used to encode Base64-encoded data is defined
                                    in <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt">RFC
                                        4648</db:link>.</db:para>
         <db:para>This function was introduced in Qt 5.2.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromBase64">fromBase64</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toCFData">
         <db:title>CFDataRef QByteArray::toCFData() const</db:title>
         <db:para>Creates a CFData from a <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>. The caller owns the CFData object and
                                    is responsible for releasing it.</db:para>
         <db:para>This function was introduced in Qt 5.3.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toRawCFData">toRawCFData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromCFData">fromCFData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawCFData">fromRawCFData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData">fromRawData</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toDouble">
         <db:title>double QByteArray::toDouble(bool * ok = 0) const</db:title>
         <db:para>Returns the byte array converted to a
                                        <db:code>double</db:code> value.</db:para>
         <db:para>Returns 0.0 if the conversion fails.</db:para>
         <db:para>If <db:emphasis>ok</db:emphasis> is not 0: if a conversion error
                                    occurs, *<db:emphasis>ok</db:emphasis> is set to false; otherwise
                                        *<db:emphasis>ok</db:emphasis> is set to true.</db:para>
         <db:programlisting>QByteArray string("1234.56"); double a = string.toDouble(); // a == 1234.56</db:programlisting>
         <db:note>
            <db:para>The conversion of the number is
                                    performed in the default C locale, irrespective of the user's
                                    locale.</db:para>
         </db:note>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number">number</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toFloat">
         <db:title>float QByteArray::toFloat(bool * ok = 0) const</db:title>
         <db:para>Returns the byte array converted to a
                                        <db:code>float</db:code> value.</db:para>
         <db:para>Returns 0.0 if the conversion fails.</db:para>
         <db:para>If <db:emphasis>ok</db:emphasis> is not 0: if a conversion error
                                    occurs, *<db:emphasis>ok</db:emphasis> is set to false; otherwise
                                        *<db:emphasis>ok</db:emphasis> is set to true.</db:para>
         <db:note>
            <db:para>The conversion of the number is
                                    performed in the default C locale, irrespective of the user's
                                    locale.</db:para>
         </db:note>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number">number</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toHex">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a hex encoded copy of the byte array. The hex
                                    encoding uses the numbers 0-9 and the letters a-f.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromHex">fromHex</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toInt">
         <db:title>int QByteArray::toInt(bool * ok = 0, int base = 10) const</db:title>
         <db:para>Returns the byte array converted to an
                                        <db:code>int</db:code> using base <db:emphasis>base</db:emphasis>,
                                    which is 10 by default and must be between 2 and 36, or
                                    0.</db:para>
         <db:para>If <db:emphasis>base</db:emphasis> is 0, the base is determined
                                    automatically using the following rules: If the byte array
                                    begins with "0x", it is assumed to be hexadecimal; if it begins
                                    with "0", it is assumed to be octal; otherwise it is assumed to
                                    be decimal.</db:para>
         <db:para>Returns 0 if the conversion fails.</db:para>
         <db:para>If <db:emphasis>ok</db:emphasis> is not 0: if a conversion error
                                    occurs, *<db:emphasis>ok</db:emphasis> is set to false; otherwise
                                        *<db:emphasis>ok</db:emphasis> is set to true.</db:para>
         <db:programlisting>QByteArray str("FF"); bool ok; int hex = str.toInt(&amp;ok,16); // hex == 255, ok == trueint dec = str.toInt(&amp;ok,10); // dec == 0, ok ==
                                    false</db:programlisting>
         <db:note>
            <db:para>The conversion of the number is
                                    performed in the default C locale, irrespective of the user's
                                    locale.</db:para>
         </db:note>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number">number</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toLong">
         <db:title>long QByteArray::toLong(bool * ok = 0, int base = 10) const</db:title>
         <db:para>Returns the byte array converted to a
                                        <db:code>long</db:code> int using base
                                        <db:emphasis>base</db:emphasis>, which is 10 by default and must be
                                    between 2 and 36, or 0.</db:para>
         <db:para>If <db:emphasis>base</db:emphasis> is 0, the base is determined
                                    automatically using the following rules: If the byte array
                                    begins with "0x", it is assumed to be hexadecimal; if it begins
                                    with "0", it is assumed to be octal; otherwise it is assumed to
                                    be decimal.</db:para>
         <db:para>Returns 0 if the conversion fails.</db:para>
         <db:para>If <db:emphasis>ok</db:emphasis> is not 0: if a conversion error
                                    occurs, *<db:emphasis>ok</db:emphasis> is set to false; otherwise
                                        *<db:emphasis>ok</db:emphasis> is set to true.</db:para>
         <db:programlisting>QByteArray str("FF"); bool ok; long hex = str.toLong(&amp;ok,16); // hex == 255, ok == truelong dec = str.toLong(&amp;ok,10); // dec == 0, ok ==
                                    false</db:programlisting>
         <db:note>
            <db:para>The conversion of the number is
                                    performed in the default C locale, irrespective of the user's
                                    locale.</db:para>
         </db:note>
         <db:para>This function was introduced in Qt
                                    4.1.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number">number</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toLongLong">
         <db:title><db:link xlink:href="qtglobal.html#qlonglong-typedef">qlonglong</db:link></db:title>
         <db:para>Returns the byte array converted to a <db:code>long
                                        long</db:code> using base <db:emphasis>base</db:emphasis>, which is
                                    10 by default and must be between 2 and 36, or 0.</db:para>
         <db:para>If <db:emphasis>base</db:emphasis> is 0, the base is determined
                                    automatically using the following rules: If the byte array
                                    begins with "0x", it is assumed to be hexadecimal; if it begins
                                    with "0", it is assumed to be octal; otherwise it is assumed to
                                    be decimal.</db:para>
         <db:para>Returns 0 if the conversion fails.</db:para>
         <db:para>If <db:emphasis>ok</db:emphasis> is not 0: if a conversion error
                                    occurs, *<db:emphasis>ok</db:emphasis> is set to false; otherwise
                                        *<db:emphasis>ok</db:emphasis> is set to true.</db:para>
         <db:note>
            <db:para>The conversion of the number is
                                    performed in the default C locale, irrespective of the user's
                                    locale.</db:para>
         </db:note>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number">number</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toLower">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a lowercase copy of the byte array. The bytearray is
                                    interpreted as a Latin-1 encoded string.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray x("Qt by DIGIA"); QByteArray y = x.toLower(); // y ==
                                        "qt by digia"</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toUpper">toUpper</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:link xlink:href="qbytearray.html#8-bit-character-comparisons">8-bit Character Comparisons</db:link>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toNSData">
         <db:title>NSData * QByteArray::toNSData() const</db:title>
         <db:para>Creates a NSData from a <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>. The NSData object is
                                    autoreleased.</db:para>
         <db:para>This function was introduced in Qt 5.3.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromNSData">fromNSData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawNSData">fromRawNSData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData">fromRawData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toRawNSData">toRawNSData</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toPercentEncoding">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a URI/URL-style percent-encoded copy of this byte
                                    array. The <db:emphasis>percent</db:emphasis> parameter allows you to
                                    override the default '%' character for another.</db:para>
         <db:para>By default, this function will encode all characters that
                                    are not one of the following:</db:para>
         <db:para>ALPHA ("a" to "z" and "A" to "Z") / DIGIT (0 to 9) / "-" /
                                    "." / "_" / "~"</db:para>
         <db:para>To prevent characters from being encoded pass them to
                                        <db:emphasis>exclude</db:emphasis>. To force characters to be encoded
                                    pass them to <db:emphasis>include</db:emphasis>. The
                                        <db:emphasis>percent</db:emphasis> character is always
                                    encoded.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray text ="{a fishy string?}";
                                        QByteArray ba = text.toPercentEncoding("{}","s"); qDebug(ba.constData()); // prints "{a fi%73hy
                                        %73tring%3F}"</db:programlisting>
         <db:para>The hex encoding uses the numbers 0-9 and the uppercase
                                    letters A-F.</db:para>
         <db:para>This function was introduced in Qt 4.4.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromPercentEncoding">fromPercentEncoding</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qurl.html#toPercentEncoding">QUrl::toPercentEncoding</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toRawCFData">
         <db:title>CFDataRef QByteArray::toRawCFData() const</db:title>
         <db:para>Constructs a CFData that uses the bytes of the <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>.</db:para>
         <db:para>The <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>'s
                                    bytes are not copied.</db:para>
         <db:para>The caller guarantees that the <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> will not be
                                    deleted or modified as long as this CFData object
                                    exists.</db:para>
         <db:para>This function was introduced in Qt 5.3.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toCFData">toCFData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawCFData">fromRawCFData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromCFData">fromCFData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData">fromRawData</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toRawNSData">
         <db:title>NSData * QByteArray::toRawNSData() const</db:title>
         <db:para>Constructs a NSData that uses the bytes of the <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>.</db:para>
         <db:para>The <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>'s
                                    bytes are not copied.</db:para>
         <db:para>The caller guarantees that the <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> will not be
                                    deleted or modified as long as this NSData object
                                    exists.</db:para>
         <db:para>This function was introduced in Qt 5.3.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawNSData">fromRawNSData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromNSData">fromNSData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData">fromRawData</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toNSData">toNSData</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toShort">
         <db:title>short QByteArray::toShort(bool * ok = 0, int base = 10) const</db:title>
         <db:para>Returns the byte array converted to a
                                        <db:code>short</db:code> using base
                                        <db:emphasis>base</db:emphasis>, which is 10 by default and must be
                                    between 2 and 36, or 0.</db:para>
         <db:para>If <db:emphasis>base</db:emphasis> is 0, the base is determined
                                    automatically using the following rules: If the byte array
                                    begins with "0x", it is assumed to be hexadecimal; if it begins
                                    with "0", it is assumed to be octal; otherwise it is assumed to
                                    be decimal.</db:para>
         <db:para>Returns 0 if the conversion fails.</db:para>
         <db:para>If <db:emphasis>ok</db:emphasis> is not 0: if a conversion error
                                    occurs, *<db:emphasis>ok</db:emphasis> is set to false; otherwise
                                        *<db:emphasis>ok</db:emphasis> is set to true.</db:para>
         <db:note>
            <db:para>The conversion of the number is
                                    performed in the default C locale, irrespective of the user's
                                    locale.</db:para>
         </db:note>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number">number</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toStdString">
         <db:title>std::string QByteArray::toStdString() const</db:title>
         <db:para>Returns a std::string object with the data contained in this
                                        <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>.</db:para>
         <db:para>This operator is mostly useful to pass a <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> to a function
                                    that accepts a std::string object.</db:para>
         <db:para>This function was introduced in Qt 5.4.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromStdString">fromStdString</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qstring.html#toStdString">QString::toStdString</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toUInt">
         <db:title><db:link xlink:href="qtglobal.html#uint-typedef">uint</db:link></db:title>
         <db:para>Returns the byte array converted to an <db:code>unsigned
                                        int</db:code> using base <db:emphasis>base</db:emphasis>, which is
                                    10 by default and must be between 2 and 36, or 0.</db:para>
         <db:para>If <db:emphasis>base</db:emphasis> is 0, the base is determined
                                    automatically using the following rules: If the byte array
                                    begins with "0x", it is assumed to be hexadecimal; if it begins
                                    with "0", it is assumed to be octal; otherwise it is assumed to
                                    be decimal.</db:para>
         <db:para>Returns 0 if the conversion fails.</db:para>
         <db:para>If <db:emphasis>ok</db:emphasis> is not 0: if a conversion error
                                    occurs, *<db:emphasis>ok</db:emphasis> is set to false; otherwise
                                        *<db:emphasis>ok</db:emphasis> is set to true.</db:para>
         <db:note>
            <db:para>The conversion of the number is
                                    performed in the default C locale, irrespective of the user's
                                    locale.</db:para>
         </db:note>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number">number</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toULong">
         <db:title><db:link xlink:href="qtglobal.html#ulong-typedef">ulong</db:link></db:title>
         <db:para>Returns the byte array converted to an <db:code>unsigned
                                        long int</db:code> using base <db:emphasis>base</db:emphasis>, which
                                    is 10 by default and must be between 2 and 36, or 0.</db:para>
         <db:para>If <db:emphasis>base</db:emphasis> is 0, the base is determined
                                    automatically using the following rules: If the byte array
                                    begins with "0x", it is assumed to be hexadecimal; if it begins
                                    with "0", it is assumed to be octal; otherwise it is assumed to
                                    be decimal.</db:para>
         <db:para>Returns 0 if the conversion fails.</db:para>
         <db:para>If <db:emphasis>ok</db:emphasis> is not 0: if a conversion error
                                    occurs, *<db:emphasis>ok</db:emphasis> is set to false; otherwise
                                        *<db:emphasis>ok</db:emphasis> is set to true.</db:para>
         <db:note>
            <db:para>The conversion of the number is
                                    performed in the default C locale, irrespective of the user's
                                    locale.</db:para>
         </db:note>
         <db:para>This function was introduced in Qt
                                    4.1.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number">number</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toULongLong">
         <db:title><db:link xlink:href="qtglobal.html#qulonglong-typedef">qulonglong</db:link></db:title>
         <db:para>Returns the byte array converted to an <db:code>unsigned
                                        long long</db:code> using base <db:emphasis>base</db:emphasis>,
                                    which is 10 by default and must be between 2 and 36, or
                                    0.</db:para>
         <db:para>If <db:emphasis>base</db:emphasis> is 0, the base is determined
                                    automatically using the following rules: If the byte array
                                    begins with "0x", it is assumed to be hexadecimal; if it begins
                                    with "0", it is assumed to be octal; otherwise it is assumed to
                                    be decimal.</db:para>
         <db:para>Returns 0 if the conversion fails.</db:para>
         <db:para>If <db:emphasis>ok</db:emphasis> is not 0: if a conversion error
                                    occurs, *<db:emphasis>ok</db:emphasis> is set to false; otherwise
                                        *<db:emphasis>ok</db:emphasis> is set to true.</db:para>
         <db:note>
            <db:para>The conversion of the number is
                                    performed in the default C locale, irrespective of the user's
                                    locale.</db:para>
         </db:note>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number">number</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toUShort">
         <db:title><db:link xlink:href="qtglobal.html#ushort-typedef">ushort</db:link></db:title>
         <db:para>Returns the byte array converted to an <db:code>unsigned
                                        short</db:code> using base <db:emphasis>base</db:emphasis>, which is
                                    10 by default and must be between 2 and 36, or 0.</db:para>
         <db:para>If <db:emphasis>base</db:emphasis> is 0, the base is determined
                                    automatically using the following rules: If the byte array
                                    begins with "0x", it is assumed to be hexadecimal; if it begins
                                    with "0", it is assumed to be octal; otherwise it is assumed to
                                    be decimal.</db:para>
         <db:para>Returns 0 if the conversion fails.</db:para>
         <db:para>If <db:emphasis>ok</db:emphasis> is not 0: if a conversion error
                                    occurs, *<db:emphasis>ok</db:emphasis> is set to false; otherwise
                                        *<db:emphasis>ok</db:emphasis> is set to true.</db:para>
         <db:note>
            <db:para>The conversion of the number is
                                    performed in the default C locale, irrespective of the user's
                                    locale.</db:para>
         </db:note>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number">number</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="toUpper">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns an uppercase copy of the byte array. The bytearray
                                    is interpreted as a Latin-1 encoded string.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray x("Qt by DIGIA"); QByteArray y = x.toUpper(); // y ==
                                        "QT BY DIGIA"</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toLower">toLower</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:link xlink:href="qbytearray.html#8-bit-character-comparisons">8-bit Character Comparisons</db:link>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="trimmed">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a byte array that has whitespace removed from the
                                    start and the end.</db:para>
         <db:para>Whitespace means any character for which the standard C++
                                        <db:code>isspace()</db:code> function returns
                                        <db:code>true</db:code> in the C locale. This includes
                                    the ASCII characters '\t', '\n', '\v', '\f', '\r', and '
                                    '.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray ba(" lots\t of\nwhitespace\r\n ");
                                    ba = ba.trimmed(); // ba == "lots\t
                                        of\nwhitespace";</db:programlisting>
         <db:para>Unlike <db:code><db:link xlink:href="qbytearray.html#simplified">simplified</db:link>()</db:code>, trimmed() leaves internal whitespace
                                    alone.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#simplified">simplified</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="truncate">
         <db:title>void QByteArray::truncate(int pos)</db:title>
         <db:para>Truncates the byte array at index position
                                        <db:emphasis>pos</db:emphasis>.</db:para>
         <db:para>If <db:emphasis>pos</db:emphasis> is beyond the end of the array,
                                    nothing happens.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray ba("Stockholm"); ba.truncate(5); //
                                        ba == "Stock"</db:programlisting>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#chop">chop</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#resize">resize</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#left">left</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="operator-not-eq">
         <db:title>bool QByteArray::operator!=(const <db:link xlink:href="qstring.html">QString</db:link></db:title>
         <db:para>Returns <db:code>true</db:code> if this byte array is
                                    not equal to string <db:emphasis>str</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
         <db:para>The Unicode data is converted into 8-bit characters using
                                        <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code>.</db:para>
         <db:para>The comparison is case sensitive.</db:para>
         <db:para>You can disable this operator by defining
                                        <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you
                                    compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#fromUtf8">QString::fromUtf8</db:link>()</db:code>,
                                        <db:code><db:link xlink:href="qstring.html#fromLatin1">QString::fromLatin1</db:link>()</db:code>, or <db:code><db:link xlink:href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</db:link>()</db:code> explicitly if you want to
                                    convert the byte array to a <db:code><db:link xlink:href="qstring.html">QString</db:link></db:code> before doing the comparison.</db:para>
      </db:section>
      <db:section xml:id="operator-2b-eq">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Appends the byte array <db:emphasis>ba</db:emphasis> onto the end of
                                    this byte array and returns a reference to this byte
                                    array.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray x("free"); QByteArray y("dom"); x += y;
                                        // x ==
                                    "freedom"</db:programlisting>
         <db:para>Note: <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> is
                                    an <db:link xlink:href="implicit-sharing.html#implicitly-shared">implicitly shared</db:link> class. Consequently, if
                                        <db:emphasis>this</db:emphasis> is an empty <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>, then
                                        <db:emphasis>this</db:emphasis> will just share the data held in
                                        <db:emphasis>ba</db:emphasis>. In this case, no copying of data is
                                    done, taking <db:link xlink:href="containers.html#constant-time">constant time</db:link>. If a shared instance is modified,
                                    it will be copied (copy-on-write), taking <db:link xlink:href="containers.html#linear-time">linear
                                    time</db:link>.</db:para>
         <db:para>If <db:emphasis>this</db:emphasis> is not an empty <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>, a deep copy of
                                    the data is performed, taking <db:link xlink:href="containers.html#linear-time">linear
                                    time</db:link>.</db:para>
         <db:para>This operation typically does not suffer from allocation
                                    overhead, because <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> preallocates extra space at the end of
                                    the data so that it may grow without reallocating for each
                                    append operation.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#append">append</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#prepend">prepend</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="operator-2b-eq-2">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qstring.html">QString</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Appends the string <db:emphasis>str</db:emphasis> onto the end of this
                                    byte array and returns a reference to this byte array. The
                                    Unicode data is converted into 8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code>.</db:para>
         <db:para>You can disable this function by defining
                                        <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile
                                    your applications. You then need to call <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code> (or
                                        <db:code><db:link xlink:href="qstring.html#toLatin1">QString::toLatin1</db:link>()</db:code> or <db:code><db:link xlink:href="qstring.html#toLocal8Bit">QString::toLocal8Bit</db:link>()</db:code>) explicitly if you want to
                                    convert the data to <db:code>const char
                                    *</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-2b-eq-3">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Appends the string <db:emphasis>str</db:emphasis> onto the end of this
                                    byte array and returns a reference to this byte array.</db:para>
      </db:section>
      <db:section xml:id="operator-2b-eq-4">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Appends the character <db:emphasis>ch</db:emphasis> onto the end of
                                    this byte array and returns a reference to this byte
                                    array.</db:para>
      </db:section>
      <db:section xml:id="operator-lt">
         <db:title>bool QByteArray::operator&lt;(const <db:link xlink:href="qstring.html">QString</db:link></db:title>
         <db:para>Returns <db:code>true</db:code> if this byte array is
                                    lexically less than string <db:emphasis>str</db:emphasis>; otherwise
                                    returns <db:code>false</db:code>.</db:para>
         <db:para>The Unicode data is converted into 8-bit characters using
                                        <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code>.</db:para>
         <db:para>The comparison is case sensitive.</db:para>
         <db:para>You can disable this operator by defining
                                        <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you
                                    compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#fromUtf8">QString::fromUtf8</db:link>()</db:code>,
                                        <db:code><db:link xlink:href="qstring.html#fromLatin1">QString::fromLatin1</db:link>()</db:code>, or <db:code><db:link xlink:href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</db:link>()</db:code> explicitly if you want to
                                    convert the byte array to a <db:code><db:link xlink:href="qstring.html">QString</db:link></db:code> before doing the comparison.</db:para>
      </db:section>
      <db:section xml:id="operator-lt-eq">
         <db:title>bool QByteArray::operator&lt;=(const <db:link xlink:href="qstring.html">QString</db:link></db:title>
         <db:para>Returns <db:code>true</db:code> if this byte array is
                                    lexically less than or equal to string <db:emphasis>str</db:emphasis>;
                                    otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>The Unicode data is converted into 8-bit characters using
                                        <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code>.</db:para>
         <db:para>The comparison is case sensitive.</db:para>
         <db:para>You can disable this operator by defining
                                        <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you
                                    compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#fromUtf8">QString::fromUtf8</db:link>()</db:code>,
                                        <db:code><db:link xlink:href="qstring.html#fromLatin1">QString::fromLatin1</db:link>()</db:code>, or <db:code><db:link xlink:href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</db:link>()</db:code> explicitly if you want to
                                    convert the byte array to a <db:code><db:link xlink:href="qstring.html">QString</db:link></db:code> before doing the comparison.</db:para>
      </db:section>
      <db:section xml:id="operator-eq">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Assigns <db:emphasis>other</db:emphasis> to this byte array and
                                    returns a reference to this byte array.</db:para>
      </db:section>
      <db:section xml:id="operator-eq-2">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Move-assigns <db:emphasis>other</db:emphasis> to this <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>
                                    instance.</db:para>
         <db:para>This function was introduced in Qt 5.2.</db:para>
      </db:section>
      <db:section xml:id="operator-eq-3">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Assigns <db:emphasis>str</db:emphasis> to this byte array.</db:para>
      </db:section>
      <db:section xml:id="operator-eq-eq">
         <db:title>bool QByteArray::operator==(const <db:link xlink:href="qstring.html">QString</db:link></db:title>
         <db:para>Returns <db:code>true</db:code> if this byte array is
                                    equal to string <db:emphasis>str</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
         <db:para>The Unicode data is converted into 8-bit characters using
                                        <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code>.</db:para>
         <db:para>The comparison is case sensitive.</db:para>
         <db:para>You can disable this operator by defining
                                        <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you
                                    compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#fromUtf8">QString::fromUtf8</db:link>()</db:code>,
                                        <db:code><db:link xlink:href="qstring.html#fromLatin1">QString::fromLatin1</db:link>()</db:code>, or <db:code><db:link xlink:href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</db:link>()</db:code> explicitly if you want to
                                    convert the byte array to a <db:code><db:link xlink:href="qstring.html">QString</db:link></db:code> before doing the comparison.</db:para>
      </db:section>
      <db:section xml:id="operator-gt">
         <db:title>bool QByteArray::operator&gt;(const <db:link xlink:href="qstring.html">QString</db:link></db:title>
         <db:para>Returns <db:code>true</db:code> if this byte array is
                                    lexically greater than string <db:emphasis>str</db:emphasis>; otherwise
                                    returns <db:code>false</db:code>.</db:para>
         <db:para>The Unicode data is converted into 8-bit characters using
                                        <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code>.</db:para>
         <db:para>The comparison is case sensitive.</db:para>
         <db:para>You can disable this operator by defining
                                        <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you
                                    compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#fromUtf8">QString::fromUtf8</db:link>()</db:code>,
                                        <db:code><db:link xlink:href="qstring.html#fromLatin1">QString::fromLatin1</db:link>()</db:code>, or <db:code><db:link xlink:href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</db:link>()</db:code> explicitly if you want to
                                    convert the byte array to a <db:code><db:link xlink:href="qstring.html">QString</db:link></db:code> before doing the comparison.</db:para>
      </db:section>
      <db:section xml:id="operator-gt-eq">
         <db:title>bool QByteArray::operator&gt;=(const <db:link xlink:href="qstring.html">QString</db:link></db:title>
         <db:para>Returns <db:code>true</db:code> if this byte array is
                                    greater than or equal to string <db:emphasis>str</db:emphasis>; otherwise
                                    returns <db:code>false</db:code>.</db:para>
         <db:para>The Unicode data is converted into 8-bit characters using
                                        <db:code><db:link xlink:href="qstring.html#toUtf8">QString::toUtf8</db:link>()</db:code>.</db:para>
         <db:para>The comparison is case sensitive.</db:para>
         <db:para>You can disable this operator by defining
                                        <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you
                                    compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#fromUtf8">QString::fromUtf8</db:link>()</db:code>,
                                        <db:code><db:link xlink:href="qstring.html#fromLatin1">QString::fromLatin1</db:link>()</db:code>, or <db:code><db:link xlink:href="qstring.html#fromLocal8Bit">QString::fromLocal8Bit</db:link>()</db:code> explicitly if you want to
                                    convert the byte array to a <db:code><db:link xlink:href="qstring.html">QString</db:link></db:code> before doing the comparison.</db:para>
      </db:section>
      <db:section xml:id="operator-5b-5d">
         <db:title>QByteRef QByteArray::operator[](int i)</db:title>
         <db:para>Returns the byte at index position <db:emphasis>i</db:emphasis> as a
                                    modifiable reference.</db:para>
         <db:para>If an assignment is made beyond the end of the byte array,
                                    the array is extended with <db:code><db:link xlink:href="qbytearray.html#resize">resize</db:link>()</db:code> before the assignment takes
                                    place.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>QByteArray ba; for (int i =0; i &lt;10; ++i) ba[i]='A'+ i; // ba == "ABCDEFGHIJ"</db:programlisting>
         <db:para>The return value is of type QByteRef, a helper class for
                                        <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code>. When you
                                    get an object of type QByteRef, you can use it as if it were a
                                    char &amp;. If you assign to it, the assignment will apply to
                                    the character in the <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> from which you got the
                                    reference.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#at">at</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="operator-5b-5d-2">
         <db:title>char QByteArray::operator[](int i) const</db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Same as at(<db:emphasis>i</db:emphasis>).</db:para>
      </db:section>
      <db:section xml:id="operator-5b-5d-3">
         <db:title>QByteRef QByteArray::operator[](<db:link xlink:href="qtglobal.html#uint-typedef">uint</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
      </db:section>
      <db:section xml:id="operator-5b-5d-4">
         <db:title>char QByteArray::operator[](<db:link xlink:href="qtglobal.html#uint-typedef">uint</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
      </db:section>
   </db:section>
   <db:section xml:id="relnonmem">
      <db:title>Related Non-Members</db:title>
      <db:section xml:id="qChecksum">
         <db:title><db:link xlink:href="qtglobal.html#quint16-typedef">quint16</db:link><db:link xlink:href="qtglobal.html#uint-typedef">uint</db:link></db:title>
         <db:para>Returns the CRC-16 checksum of the first
                                        <db:emphasis>len</db:emphasis> bytes of
                                    <db:emphasis>data</db:emphasis>.</db:para>
         <db:para>The checksum is independent of the byte order
                                    (endianness).</db:para>
         <db:note>
            <db:para>This function is a 16-bit cache
                                    conserving (16 entry table) implementation of the CRC-16-CCITT
                                    algorithm.</db:para>
         </db:note>
      </db:section>
      <db:section xml:id="qCompress">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Compresses the <db:emphasis>data</db:emphasis> byte array and returns
                                    the compressed data in a new byte array.</db:para>
         <db:para>The <db:emphasis>compressionLevel</db:emphasis> parameter specifies
                                    how much compression should be used. Valid values are between 0
                                    and 9, with 9 corresponding to the greatest compression (i.e.
                                    smaller compressed data) at the cost of using a slower
                                    algorithm. Smaller values (8, 7, ..., 1) provide successively
                                    less compression at slightly faster speeds. The value 0
                                    corresponds to no compression at all. The default value is -1,
                                    which specifies zlib's default compression.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qUncompress">qUncompress</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="qCompress-2">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qtglobal.html#uchar-typedef">uchar</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Compresses the first <db:emphasis>nbytes</db:emphasis> of
                                        <db:emphasis>data</db:emphasis> and returns the compressed data in a
                                    new byte array.</db:para>
      </db:section>
      <db:section xml:id="qUncompress">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Uncompresses the <db:emphasis>data</db:emphasis> byte array and
                                    returns a new byte array with the uncompressed data.</db:para>
         <db:para>Returns an empty <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> if the input data was corrupt.</db:para>
         <db:para>This function will uncompress data compressed with <db:code><db:link xlink:href="qbytearray.html#qCompress">qCompress</db:link>()</db:code> from
                                    this and any earlier Qt version, back to Qt 3.1 when this
                                    feature was added.</db:para>
         <db:note>
            <db:para> If you want to use this function to
                                    uncompress external data that was compressed using zlib, you
                                    first need to prepend a four byte header to the byte array
                                    containing the data. The header must contain the expected length
                                    (in bytes) of the uncompressed data, expressed as an unsigned,
                                    big-endian, 32-bit integer.</db:para>
         </db:note>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qCompress">qCompress</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="qUncompress-2">
         <db:title><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qtglobal.html#uchar-typedef">uchar</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Uncompresses the first <db:emphasis>nbytes</db:emphasis> of
                                        <db:emphasis>data</db:emphasis> and returns a new byte array with the
                                    uncompressed data.</db:para>
      </db:section>
      <db:section xml:id="qsnprintf">
         <db:title>int qsnprintf(char * str, size_t n, const char * fmt, ...)</db:title>
         <db:para>A portable
                                    snprintf() function, calls qvsnprintf.</db:para>
         <db:para>
            <db:emphasis>fmt</db:emphasis> is the <db:code>printf()</db:code>
                                    format string. The result is put into <db:emphasis>str</db:emphasis>,
                                    which is a buffer of at least <db:emphasis>n</db:emphasis> bytes.</db:para>
         <db:warning>
            <db:para> Call this function only when you
                                    know what you are doing since it shows different behavior on
                                    certain platforms. Use <db:code><db:link xlink:href="qstring.html#sprintf">QString::sprintf</db:link>()</db:code> to format a string
                                    instead.</db:para>
         </db:warning>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qvsnprintf">qvsnprintf</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qstring.html#sprintf">QString::sprintf</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="qstrcmp">
         <db:title>int qstrcmp(const char * str1, const char * str2)</db:title>
         <db:para>A safe <db:code>strcmp()</db:code> function.</db:para>
         <db:para>Compares <db:emphasis>str1</db:emphasis> and <db:emphasis>str2</db:emphasis>.
                                    Returns a negative value if <db:emphasis>str1</db:emphasis> is less than
                                        <db:emphasis>str2</db:emphasis>, 0 if <db:emphasis>str1</db:emphasis> is equal
                                    to <db:emphasis>str2</db:emphasis> or a positive value if
                                        <db:emphasis>str1</db:emphasis> is greater than
                                    <db:emphasis>str2</db:emphasis>.</db:para>
         <db:para>Special case 1: Returns 0 if <db:emphasis>str1</db:emphasis> and
                                        <db:emphasis>str2</db:emphasis> are both 0.</db:para>
         <db:para>Special case 2: Returns an arbitrary non-zero value if
                                        <db:emphasis>str1</db:emphasis> is 0 or <db:emphasis>str2</db:emphasis> is 0
                                    (but not both).</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qstrncmp">qstrncmp</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qstricmp">qstricmp</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qstrnicmp">qstrnicmp</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:link xlink:href="qbytearray.html#8-bit-character-comparisons">8-bit Character Comparisons</db:link>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="qstrcpy">
         <db:title>char * qstrcpy(char * dst, const char * src)</db:title>
         <db:para>Copies all the characters up to and including the '\0' from
                                        <db:emphasis>src</db:emphasis> into <db:emphasis>dst</db:emphasis> and returns a
                                    pointer to <db:emphasis>dst</db:emphasis>. If <db:emphasis>src</db:emphasis> is 0,
                                    it immediately returns 0.</db:para>
         <db:para>This function assumes that <db:emphasis>dst</db:emphasis> is large
                                    enough to hold the contents of <db:emphasis>src</db:emphasis>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qstrncpy">qstrncpy</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="qstrdup">
         <db:title>char * qstrdup(const char * src)</db:title>
         <db:para>Returns a duplicate string.</db:para>
         <db:para>Allocates space for a copy of <db:emphasis>src</db:emphasis>, copies
                                    it, and returns a pointer to the copy. If <db:emphasis>src</db:emphasis>
                                    is 0, it immediately returns 0.</db:para>
         <db:para>Ownership is passed to the caller, so the returned string
                                    must be deleted using <db:code>delete[]</db:code>.</db:para>
      </db:section>
      <db:section xml:id="qstricmp">
         <db:title>int qstricmp(const char * str1, const char * str2)</db:title>
         <db:para>A safe <db:code>stricmp()</db:code> function.</db:para>
         <db:para>Compares <db:emphasis>str1</db:emphasis> and <db:emphasis>str2</db:emphasis>
                                    ignoring the case of the characters. The encoding of the strings
                                    is assumed to be Latin-1.</db:para>
         <db:para>Returns a negative value if <db:emphasis>str1</db:emphasis> is less
                                    than <db:emphasis>str2</db:emphasis>, 0 if <db:emphasis>str1</db:emphasis> is equal
                                    to <db:emphasis>str2</db:emphasis> or a positive value if
                                        <db:emphasis>str1</db:emphasis> is greater than
                                    <db:emphasis>str2</db:emphasis>.</db:para>
         <db:para>Special case 1: Returns 0 if <db:emphasis>str1</db:emphasis> and
                                        <db:emphasis>str2</db:emphasis> are both 0.</db:para>
         <db:para>Special case 2: Returns a random non-zero value if
                                        <db:emphasis>str1</db:emphasis> is 0 or <db:emphasis>str2</db:emphasis> is 0
                                    (but not both).</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qstrcmp">qstrcmp</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qstrncmp">qstrncmp</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qstrnicmp">qstrnicmp</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:link xlink:href="qbytearray.html#8-bit-character-comparisons">8-bit Character Comparisons</db:link>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="qstrlen">
         <db:title><db:link xlink:href="qtglobal.html#uint-typedef">uint</db:link></db:title>
         <db:para>A safe <db:code>strlen()</db:code> function.</db:para>
         <db:para>Returns the number of characters that precede the
                                    terminating '\0', or 0 if <db:emphasis>str</db:emphasis> is 0.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qstrnlen">qstrnlen</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="qstrncmp">
         <db:title>int qstrncmp(const char * str1, const char * str2, <db:link xlink:href="qtglobal.html#uint-typedef">uint</db:link></db:title>
         <db:para>A safe <db:code>strncmp()</db:code> function.</db:para>
         <db:para>Compares at most <db:emphasis>len</db:emphasis> bytes of
                                        <db:emphasis>str1</db:emphasis> and <db:emphasis>str2</db:emphasis>.</db:para>
         <db:para>Returns a negative value if <db:emphasis>str1</db:emphasis> is less
                                    than <db:emphasis>str2</db:emphasis>, 0 if <db:emphasis>str1</db:emphasis> is equal
                                    to <db:emphasis>str2</db:emphasis> or a positive value if
                                        <db:emphasis>str1</db:emphasis> is greater than
                                    <db:emphasis>str2</db:emphasis>.</db:para>
         <db:para>Special case 1: Returns 0 if <db:emphasis>str1</db:emphasis> and
                                        <db:emphasis>str2</db:emphasis> are both 0.</db:para>
         <db:para>Special case 2: Returns a random non-zero value if
                                        <db:emphasis>str1</db:emphasis> is 0 or <db:emphasis>str2</db:emphasis> is 0
                                    (but not both).</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qstrcmp">qstrcmp</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qstricmp">qstricmp</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qstrnicmp">qstrnicmp</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:link xlink:href="qbytearray.html#8-bit-character-comparisons">8-bit Character Comparisons</db:link>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="qstrncpy">
         <db:title>char * qstrncpy(char * dst, const char * src, <db:link xlink:href="qtglobal.html#uint-typedef">uint</db:link></db:title>
         <db:para>A safe <db:code>strncpy()</db:code> function.</db:para>
         <db:para>Copies at most <db:emphasis>len</db:emphasis> bytes from
                                        <db:emphasis>src</db:emphasis> (stopping at <db:emphasis>len</db:emphasis> or
                                    the terminating '\0' whichever comes first) into
                                        <db:emphasis>dst</db:emphasis> and returns a pointer to
                                        <db:emphasis>dst</db:emphasis>. Guarantees that <db:emphasis>dst</db:emphasis>
                                    is '\0'-terminated. If <db:emphasis>src</db:emphasis> or
                                        <db:emphasis>dst</db:emphasis> is 0, returns 0 immediately.</db:para>
         <db:para>This function assumes that <db:emphasis>dst</db:emphasis> is at least
                                        <db:emphasis>len</db:emphasis> characters long.</db:para>
         <db:note>
            <db:para>When compiling with Visual C++
                                    compiler version 14.00 (Visual C++ 2005) or later, internally
                                    the function strncpy_s will be used.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See
                                        also </db:emphasis>
            <db:code><db:link xlink:href="qbytearray.html#qstrcpy">qstrcpy</db:link>()</db:code>.</db:para>
      </db:section>
      <db:section xml:id="qstrnicmp">
         <db:title>int qstrnicmp(const char * str1, const char * str2, <db:link xlink:href="qtglobal.html#uint-typedef">uint</db:link></db:title>
         <db:para>A safe <db:code>strnicmp()</db:code> function.</db:para>
         <db:para>Compares at most <db:emphasis>len</db:emphasis> bytes of
                                        <db:emphasis>str1</db:emphasis> and <db:emphasis>str2</db:emphasis> ignoring the
                                    case of the characters. The encoding of the strings is assumed
                                    to be Latin-1.</db:para>
         <db:para>Returns a negative value if <db:emphasis>str1</db:emphasis> is less
                                    than <db:emphasis>str2</db:emphasis>, 0 if <db:emphasis>str1</db:emphasis> is equal
                                    to <db:emphasis>str2</db:emphasis> or a positive value if
                                        <db:emphasis>str1</db:emphasis> is greater than
                                    <db:emphasis>str2</db:emphasis>.</db:para>
         <db:para>Special case 1: Returns 0 if <db:emphasis>str1</db:emphasis> and
                                        <db:emphasis>str2</db:emphasis> are both 0.</db:para>
         <db:para>Special case 2: Returns a random non-zero value if
                                        <db:emphasis>str1</db:emphasis> is 0 or <db:emphasis>str2</db:emphasis> is 0
                                    (but not both).</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qstrcmp">qstrcmp</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qstrncmp">qstrncmp</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qstricmp">qstricmp</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:link xlink:href="qbytearray.html#8-bit-character-comparisons">8-bit Character Comparisons</db:link>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="qstrnlen">
         <db:title><db:link xlink:href="qtglobal.html#uint-typedef">uint</db:link><db:link xlink:href="qtglobal.html#uint-typedef">uint</db:link></db:title>
         <db:para>A safe <db:code>strnlen()</db:code> function.</db:para>
         <db:para>Returns the number of characters that precede the
                                    terminating '\0', but at most <db:emphasis>maxlen</db:emphasis>. If
                                        <db:emphasis>str</db:emphasis> is 0, returns 0.</db:para>
         <db:para>This function was introduced in Qt 4.2.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qstrlen">qstrlen</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="qvsnprintf">
         <db:title>int qvsnprintf(char * str, size_t n, const char * fmt, va_list ap)</db:title>
         <db:para>A portable <db:code>vsnprintf()</db:code> function. Will
                                    call <db:code>::vsnprintf()</db:code>,
                                        <db:code>::_vsnprintf()</db:code>, or
                                        <db:code>::vsnprintf_s</db:code> depending on the
                                    system, or fall back to an internal version.</db:para>
         <db:para>
            <db:emphasis>fmt</db:emphasis> is the <db:code>printf()</db:code>
                                    format string. The result is put into <db:emphasis>str</db:emphasis>,
                                    which is a buffer of at least <db:emphasis>n</db:emphasis> bytes.</db:para>
         <db:para>The caller is responsible to call
                                        <db:code>va_end()</db:code> on
                                    <db:emphasis>ap</db:emphasis>.</db:para>
         <db:warning>
            <db:para> Since vsnprintf() shows different
                                    behavior on certain platforms, you should not rely on the return
                                    value or on the fact that you will always get a 0 terminated
                                    string back.</db:para>
         </db:warning>
         <db:para>Ideally, you should never call this function but use <db:code><db:link xlink:href="qstring.html#sprintf">QString::sprintf</db:link>()</db:code>
                                    instead.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#qsnprintf">qsnprintf</db:link>()</db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qstring.html#sprintf">QString::sprintf</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="operator-not-eq-54">
         <db:title>bool operator!=(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if byte array
                                        <db:emphasis>a1</db:emphasis> is not equal to byte array
                                        <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-not-eq-55">
         <db:title>bool operator!=(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if byte array
                                        <db:emphasis>a1</db:emphasis> is not equal to string
                                        <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-not-eq-56">
         <db:title>bool operator!=(const char * a1, const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if string
                                        <db:emphasis>a1</db:emphasis> is not equal to byte array
                                        <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-2b">
         <db:title>const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Returns a byte array that is the result of concatenating
                                    byte array <db:emphasis>a1</db:emphasis> and byte array
                                        <db:emphasis>a2</db:emphasis>.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-2b-eq">QByteArray::operator+=</db:link>()</db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="operator-2b-29">
         <db:title>const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns a byte array that is the result of concatenating
                                    byte array <db:emphasis>a1</db:emphasis> and string
                                    <db:emphasis>a2</db:emphasis>.</db:para>
      </db:section>
      <db:section xml:id="operator-2b-30">
         <db:title>const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns a byte array that is the result of concatenating
                                    byte array <db:emphasis>a1</db:emphasis> and character
                                    <db:emphasis>a2</db:emphasis>.</db:para>
      </db:section>
      <db:section xml:id="operator-2b-31">
         <db:title>const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns a byte array that is the result of concatenating
                                    string <db:emphasis>a1</db:emphasis> and byte array
                                    <db:emphasis>a2</db:emphasis>.</db:para>
      </db:section>
      <db:section xml:id="operator-2b-32">
         <db:title>const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns a byte array that is the result of concatenating
                                    character <db:emphasis>a1</db:emphasis> and byte array
                                    <db:emphasis>a2</db:emphasis>.</db:para>
      </db:section>
      <db:section xml:id="operator-lt-19">
         <db:title>bool operator&lt;(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if byte array
                                        <db:emphasis>a1</db:emphasis> is lexically less than byte array
                                        <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-lt-20">
         <db:title>bool operator&lt;(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if byte array
                                        <db:emphasis>a1</db:emphasis> is lexically less than string
                                        <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-lt-21">
         <db:title>bool operator&lt;(const char * a1, const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if string
                                        <db:emphasis>a1</db:emphasis> is lexically less than byte array
                                        <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-lt-lt-46">
         <db:title><db:link xlink:href="qdatastream.html">QDataStream</db:link><db:link xlink:href="qdatastream.html">QDataStream</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Writes byte array <db:emphasis>ba</db:emphasis> to the stream
                                        <db:emphasis>out</db:emphasis> and returns a reference to the
                                    stream.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:link xlink:href="datastreamformat.html">Serializing Qt Data
                                        Types</db:link>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
      <db:section xml:id="operator-lt-eq-16">
         <db:title>bool operator&lt;=(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if byte array
                                        <db:emphasis>a1</db:emphasis> is lexically less than or equal to byte
                                    array <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-lt-eq-17">
         <db:title>bool operator&lt;=(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if byte array
                                        <db:emphasis>a1</db:emphasis> is lexically less than or equal to
                                    string <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-lt-eq-18">
         <db:title>bool operator&lt;=(const char * a1, const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if string
                                        <db:emphasis>a1</db:emphasis> is lexically less than or equal to byte
                                    array <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-eq-eq-62">
         <db:title>bool operator==(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if byte array
                                        <db:emphasis>a1</db:emphasis> is equal to byte array
                                        <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-eq-eq-63">
         <db:title>bool operator==(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if byte array
                                        <db:emphasis>a1</db:emphasis> is equal to string <db:emphasis>a2</db:emphasis>;
                                    otherwise returns <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-eq-eq-64">
         <db:title>bool operator==(const char * a1, const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if string
                                        <db:emphasis>a1</db:emphasis> is equal to byte array
                                        <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-gt-16">
         <db:title>bool operator&gt;(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if byte array
                                        <db:emphasis>a1</db:emphasis> is lexically greater than byte array
                                        <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-gt-17">
         <db:title>bool operator&gt;(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if byte array
                                        <db:emphasis>a1</db:emphasis> is lexically greater than string
                                        <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-gt-18">
         <db:title>bool operator&gt;(const char * a1, const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if string
                                        <db:emphasis>a1</db:emphasis> is lexically greater than byte array
                                        <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-gt-eq-16">
         <db:title>bool operator&gt;=(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if byte array
                                        <db:emphasis>a1</db:emphasis> is lexically greater than or equal to
                                    byte array <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-gt-eq-17">
         <db:title>bool operator&gt;=(const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if byte array
                                        <db:emphasis>a1</db:emphasis> is lexically greater than or equal to
                                    string <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-gt-eq-18">
         <db:title>bool operator&gt;=(const char * a1, const <db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if string
                                        <db:emphasis>a1</db:emphasis> is lexically greater than or equal to
                                    byte array <db:emphasis>a2</db:emphasis>; otherwise returns
                                        <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-gt-gt-18">
         <db:title><db:link xlink:href="qdatastream.html">QDataStream</db:link><db:link xlink:href="qdatastream.html">QDataStream</db:link><db:link xlink:href="qbytearray.html#QByteArray">QByteArray</db:link></db:title>
         <db:para>Reads a byte array into <db:emphasis>ba</db:emphasis> from the stream
                                        <db:emphasis>in</db:emphasis> and returns a reference to the
                                    stream.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:link xlink:href="datastreamformat.html">Serializing Qt Data
                                        Types</db:link>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
   </db:section>
   <db:section xml:id="macros">
      <db:title>Macro Documentation</db:title>
      <db:section xml:id="QT_NO_CAST_FROM_BYTEARRAY">
         <db:title>QT_NO_CAST_FROM_BYTEARRAY</db:title>
         <db:para>Disables automatic conversions from <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> to const char *
                                    or const void *.</db:para>
         <db:section>
            <db:title>See Also</db:title>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qstring.html#QT_NO_CAST_TO_ASCII">QT_NO_CAST_TO_ASCII</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qstring.html#QT_NO_CAST_FROM_ASCII">QT_NO_CAST_FROM_ASCII</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:section>
      </db:section>
   </db:section>
   <db:section>
      <db:title>Obsolete Members</db:title>
      <db:section xml:id="obsolete_memfunc">
         <db:title>Member Function Documentation</db:title>
         <db:section xml:id="operator-const-char--2a">
            <db:title>QByteArray::operator const char *() const</db:title>
            <db:para>Returns a pointer to the data stored in the byte array. The pointer can be used to access the bytes that compose the array. The data is '\0'-terminated. The pointer remains valid as long as the array isn't reallocated or destroyed.</db:para>
            <db:para>This operator is mostly useful to pass a byte array to a function that accepts a <db:code>const char *</db:code>.</db:para>
            <db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_BYTEARRAY</db:code> when you compile your applications.</db:para>
            <db:para>Note: A <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> can store any byte values including '\0's, but most functions that take <db:code>char *</db:code> arguments assume that the data ends at the first '\0' they encounter.</db:para>
            <db:section>
               <db:title>See Also</db:title>
               <db:simplelist type="vert">
                  <db:member>
                     <db:code><db:link xlink:href="qbytearray.html#constData">constData</db:link>()</db:code>
                  </db:member>
               </db:simplelist>
            </db:section>
         </db:section>
         <db:section xml:id="operator-const-void--2a">
            <db:title>QByteArray::operator const void *() const</db:title>
            <db:para>Returns a pointer to the data stored in the byte array. The pointer can be used to access the bytes that compose the array. The data is '\0'-terminated. The pointer remains valid as long as the array isn't reallocated or destroyed.</db:para>
            <db:para>This operator is mostly useful to pass a byte array to a function that accepts a <db:code>const char *</db:code>.</db:para>
            <db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_BYTEARRAY</db:code> when you compile your applications.</db:para>
            <db:para>Note: A <db:code><db:link xlink:href="qbytearray.html">QByteArray</db:link></db:code> can store any byte values including '\0's, but most functions that take <db:code>char *</db:code> arguments assume that the data ends at the first '\0' they encounter.</db:para>
            <db:section>
               <db:title>See Also</db:title>
               <db:simplelist type="vert">
                  <db:member>
                     <db:code><db:link xlink:href="qbytearray.html#constData">constData</db:link>()</db:code>
                  </db:member>
               </db:simplelist>
            </db:section>
         </db:section>
      </db:section>
   </db:section>
</db:article>
