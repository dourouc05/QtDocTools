<?xml version="1.0" encoding="UTF-8"?>
<WebXML>
    <document>
        <page name="xquery-introduction.html" href="xquery-introduction.html" status="active" location="xquery-introduction.qdoc" filepath="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/src/xquery-introduction.qdoc" lineno="28" subtype="page" title="A Short Path to XQuery" fulltitle="A Short Path to XQuery" subtitle="" module="QtXmlPatterns">
            <target name="shorthand-form" title="Shorthand Form"/>
            <target name="name-tests" title="Name Tests"/>
            <target name="empty-method-not-robust" title="Empty Method Not Robust"/>
            <target name="constructing-elements" title="Constructing Elements"/>
            <keyword name="xquery-introduction" title="XQuery-introduction"/>
            <contents name="introduction" title="Introduction" level="1"/>
            <contents name="using-path-expressions-to-match-and-select-items" title="Using Path Expressions To Match And Select Items" level="1"/>
            <contents name="axis-steps" title="Axis Steps" level="2"/>
            <contents name="axis-specifiers" title="Axis Specifiers" level="2"/>
            <contents name="node-tests" title="Node Tests" level="2"/>
            <contents name="shorthand-form" title="Shorthand Form" level="2"/>
            <contents name="name-tests" title="Name Tests" level="2"/>
            <contents name="wildcards-in-name-tests" title="Wildcards in Name Tests" level="3"/>
            <contents name="using-predicates-in-path-expressions" title="Using Predicates In Path Expressions" level="1"/>
            <contents name="positional-predicates" title="Positional Predicates" level="2"/>
            <contents name="boolean-predicates" title="Boolean Predicates" level="2"/>
            <contents name="constructing-elements" title="Constructing Elements" level="1"/>
            <contents name="element-constructors-are-expressions" title="Element Constructors are Expressions" level="2"/>
            <contents name="constructing-atomic-values" title="Constructing Atomic Values" level="1"/>
            <contents name="running-the-cookbook-examples" title="Running The Cookbook Examples" level="1"/>
            <contents name="further-reading" title="Further Reading" level="1"/>
            <contents name="faq" title="FAQ" level="1"/>
            <contents name="why-didn-t-my-path-expression-match-anything" title="Why didn't my path expression match anything?" level="2"/>
            <contents name="what-if-my-input-namespace-is-different-from-my-output-namespace" title="What if my input namespace is different from my output namespace?" level="2"/>
            <contents name="why-doesn-t-my-return-clause-work" title="Why doesn't my return clause work?" level="2"/>
            <contents name="why-didn-t-my-expression-get-evaluated" title="Why didn't my expression get evaluated?" level="2"/>
            <contents name="my-predicate-is-correct-so-why-doesn-t-it-select-the-right-stuff" title="My predicate is correct, so why doesn't it select the right stuff?" level="2"/>
            <contents name="why-doesn-t-my-flwor-behave-as-expected" title="Why doesn't my FLWOR behave as expected?" level="2"/>
            <contents name="why-are-my-elements-created-in-the-wrong-order" title="Why are my elements created in the wrong order?" level="2"/>
            <contents name="why-can-t-i-use-keyword-true-keyword-and-keyword-false-keyword-in-my-xquery" title="Why can't I use &lt;@keyword&gt;true&lt;/@keyword&gt; and &lt;@keyword&gt;false&lt;/@keyword&gt; in my XQuery?" level="2"/>
            <description path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/src/xquery-introduction.qdoc" line="28" column="4">
                <relation href="xmlprocessing.html" type="page" meta="start" description="XQuery"/>
                <para>
                    <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> is a language for querying XML data or non-XML data that can be modeled as XML. <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> is specified by the W3C.</para>
                <section id="introduction">
                    <heading level="1">Introduction</heading>
                    <para>Where Java and C++ are <italic>statement-based</italic> languages, the <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> language is <italic>expression-based</italic>. The simplest <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> expression is an XML element constructor:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="20"/>
                    <para>This <teletype type="highlighted">&lt;recipe/&gt;</teletype> element is an <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> expression that forms a complete <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link>. In fact, this <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> doesn't actually query anything. It just creates an empty <teletype type="highlighted">&lt;recipe/&gt;</teletype> element in the output. But <link raw="Constructing Elements" href="xquery-introduction.html#constructing-elements" type="page" page="A Short Path to XQuery">constructing new elements in an XQuery</link> is often necessary.</para>
                    <para>An <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> expression can also be enclosed in curly braces and embedded in another <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> expression. This <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> has a document expression embedded in a node expression:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="21"/>
                    <para>It creates a new <teletype type="highlighted">&lt;html&gt;</teletype> element in the output and sets its <teletype type="highlighted">id</teletype> attribute to be the <teletype type="highlighted">id</teletype> attribute from an <teletype type="highlighted">&lt;html&gt;</teletype> element in the <teletype type="highlighted">other.html</teletype> file.</para>
                </section>
                <section id="using-path-expressions-to-match-and-select-items">
                    <heading level="1">Using Path Expressions To Match And Select Items</heading>
                    <para>In C++ and Java, we write nested <teletype type="highlighted">for</teletype> loops and recursive functions to traverse XML trees in search of elements of interest. In <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link>, we write these iterative and recursive algorithms with <italic>path expressions</italic>.</para>
                    <para>A path expression looks somewhat like a typical <italic>file pathname</italic> for locating a file in a hierarchical file system. It is a sequence of one or more <italic>steps</italic> separated by slash '/' or double slash '//'. Although path expressions are used for traversing XML trees, not file systems, in Qt XML Patterns we can model a file system to look like an XML tree, so in Qt XML Patterns we can use <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> to traverse a file system. See the <link raw="File System Example" href="qtxmlpatterns-filetree-example.html" type="page" page="File System Example">file system example</link>.</para>
                    <para>Think of a path expression as an algorithm for traversing an XML tree to find and collect items of interest. This algorithm is evaluated by evaluating each step moving from left to right through the sequence. A step is evaluated with a set of input items (nodes and atomic values), sometimes called the <italic>focus</italic>. The step is evaluated for each item in the focus. These evaluations produce a new set of items, called the <italic>result</italic>, which then becomes the focus that is passed to the next step. Evaluation of the final step produces the final result, which is the result of the <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link>. The items in the result set are presented in document order and without duplicates.</para>
                    <para>With Qt XML Patterns, a standard way to present the initial focus to a query is to call <link raw="QXmlQuery::setFocus()" href="qxmlquery.html#setFocus" type="function">QXmlQuery::setFocus()</link>. Another common way is to let the <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> itself create the initial focus by using the first step of the path expression to call the <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> <teletype type="highlighted">doc()</teletype> function. The <teletype type="highlighted">doc()</teletype> function loads an XML document and returns the <italic>document node</italic>. Note that the document node is <italic>not</italic> the same as the <italic>document element</italic>. The <italic>document node</italic> is a node constructed in memory, when the document is loaded. It represents the entire XML document, not the document element. The <italic>document element</italic> is the single, top-level XML element in the file. The <teletype type="highlighted">doc()</teletype> function returns the document node, which becomes the singleton node in the initial focus set. The document node will have one child node, and that child node will represent the document element. Consider the following <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link>:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="18"/>
                    <para>The <teletype type="highlighted">doc()</teletype> function loads the <teletype type="highlighted">cookbook.xml</teletype> file and returns the document node. The document node then becomes the focus for the next step <teletype type="highlighted">//recipe</teletype>. Here the double slash means select all <teletype type="highlighted">&lt;recipe&gt;</teletype> elements found below the document node, regardless of where they appear in the document tree. The query selects all <teletype type="highlighted">&lt;recipe&gt;</teletype> elements in the cookbook. See <link raw="Running The Cookbook Examples" href="xquery-introduction.html#running-the-cookbook-examples" type="page" page="A Short Path to XQuery">Running The Cookbook Examples</link> for instructions on how to run this query (and most of the ones that follow) from the command line.</para>
                    <para>Conceptually, evaluation of the steps of a path expression is similar to iterating through the same number of nested <italic>for</italic> loops. Consider the following <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link>, which builds on the previous one:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="19"/>
                    <para>This <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> is a single path expression composed of three steps. The first step creates the initial focus by calling the <teletype type="highlighted">doc()</teletype> function. We can paraphrase what the query engine does at each step:</para>
                    <list type="ordered" start="1">
                        <item>
                            <para>for each node in the initial focus (the document node)...</para>
                        </item>
                        <item>
                            <para>for each descendant node that is a <teletype type="highlighted">&lt;recipe&gt;</teletype> element...</para>
                        </item>
                        <item>
                            <para>collect the child nodes that are <teletype type="highlighted">&lt;title&gt;</teletype> elements.</para>
                        </item>
                    </list>
                    <para>Again the double slash means select all the <teletype type="highlighted">&lt;recipe&gt;</teletype> elements in the document. The single slash before the <teletype type="highlighted">&lt;title&gt;</teletype> element means select only those <teletype type="highlighted">&lt;title&gt;</teletype> elements that are <italic>child</italic> elements of a <teletype type="highlighted">&lt;recipe&gt;</teletype> element (i.e. not grandchildren, etc). The <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> evaluates to a final result set containing the <teletype type="highlighted">&lt;title&gt;</teletype> element of each <teletype type="highlighted">&lt;recipe&gt;</teletype> element in the cookbook.</para>
                </section>
                <section id="axis-steps">
                    <heading level="2">Axis Steps</heading>
                    <para>The most common kind of path step is called an <italic>axis step</italic>, which tells the query engine which way to navigate from the context node, and which test to perform when it encounters nodes along the way. An axis step has two parts, an <italic>axis specifier</italic>, and a <italic>node test</italic>. Conceptually, evaluation of an axis step proceeds as follows: For each node in the focus set, the query engine navigates out from the node along the specified axis and applies the node test to each node it encounters. The nodes selected by the node test are collected in the result set, which becomes the focus set for the next step.</para>
                    <para>In the example <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> above, the second and third steps are both axis steps. Both apply the <teletype type="highlighted">element(name)</teletype> node test to nodes encountered while traversing along some axis. But in this example, the two axis steps are written in a <link raw="Shorthand Form" href="xquery-introduction.html#shorthand-form" type="page" page="A Short Path to XQuery">shorthand form</link>, where the axis specifier and the node test are not written explicitly but are implied. XQueries are normally written in this shorthand form, but they can also be written in the longhand form. If we rewrite the <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> in the longhand form, it looks like this:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="22"/>
                    <para>The two axis steps have been expanded. The first step (<teletype type="highlighted">//recipe</teletype>) has been rewritten as <teletype type="highlighted">/descendant-or-self::element(recipe)</teletype>, where <teletype type="highlighted">descendant-or-self::</teletype> is the axis specifier and <teletype type="highlighted">element(recipe)</teletype> is the node test. The second step (<teletype type="highlighted">title</teletype>) has been rewritten as <teletype type="highlighted">/child::element(title)</teletype>, where <teletype type="highlighted">child::</teletype> is the axis specifier and <teletype type="highlighted">element(title)</teletype> is the node test. The output of the expanded <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> will be exactly the same as the output of the shorthand form.</para>
                    <para>To create an axis step, concatenate an axis specifier and a node test. The following sections list the axis specifiers and node tests that are available.</para>
                </section>
                <section id="axis-specifiers">
                    <heading level="2">Axis Specifiers</heading>
                    <para>An axis specifier defines the direction you want the query engine to take, when it navigates away from the context node. Qt XML Patterns supports the following axes.</para>
                    <table>
                        <header>
                            <item>
                                <para>Axis Specifier</para>
                            </item>
                            <item>
                                <para>refers to the axis containing...</para>
                            </item>
                        </header>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">self::</teletype></para>
                            </item>
                            <item>
                                <para>the context node itself</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">attribute::</teletype></para>
                            </item>
                            <item>
                                <para>all attribute nodes of the context node</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">child::</teletype></para>
                            </item>
                            <item>
                                <para>all child nodes of the context node (not attributes)</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">descendant::</teletype></para>
                            </item>
                            <item>
                                <para>all descendants of the context node (children, grandchildren, etc)</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">descendant-or-self::</teletype></para>
                            </item>
                            <item>
                                <para>all nodes in <teletype type="highlighted">descendant</teletype> + <teletype type="highlighted">self</teletype></para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">parent::</teletype></para>
                            </item>
                            <item>
                                <para>the parent node of the context node, or empty if there is no parent</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">ancestor::</teletype></para>
                            </item>
                            <item>
                                <para>all ancestors of the context node (parent, grandparent, etc)</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">ancestor-or-self::</teletype></para>
                            </item>
                            <item>
                                <para>all nodes in <teletype type="highlighted">ancestor</teletype> + <teletype type="highlighted">self</teletype></para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">following::</teletype></para>
                            </item>
                            <item>
                                <para>all nodes in the tree containing the context node, <italic>not</italic> including <teletype type="highlighted">descendant</teletype>, <italic>and</italic> that follow the context node in the document</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">preceding::</teletype></para>
                            </item>
                            <item>
                                <para>all nodes in the tree contianing the context node, <italic>not</italic> including <teletype type="highlighted">ancestor</teletype>, <italic>and</italic> that precede the context node in the document</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">following-sibling::</teletype></para>
                            </item>
                            <item>
                                <para>all children of the context node's <teletype type="highlighted">parent</teletype> that follow the context node in the document</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">preceding-sibling::</teletype></para>
                            </item>
                            <item>
                                <para>all children of the context node's <teletype type="highlighted">parent</teletype> that precede the context node in the document</para>
                            </item>
                        </row>
                    </table>
                </section>
                <section id="node-tests">
                    <heading level="2">Node Tests</heading>
                    <para>A node test is a conditional expression that must be true for a node if the node is to be selected by the axis step. The conditional expression can test just the <italic>kind</italic> of node, or it can test the <italic>kind</italic> of node and the <italic>name</italic> of the node. The <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> specification for node tests also defines a third condition, the node's <italic>Schema Type</italic>, but schema type tests are not supported in Qt XML Patterns.</para>
                    <para>Qt XML Patterns supports the following node tests. The tests that have a <teletype type="highlighted">name</teletype> parameter test the node's name in addition to its <italic>kind</italic> and are often called the <link raw="Name Tests" href="xquery-introduction.html#name-tests" type="page" page="A Short Path to XQuery">Name Tests</link>.</para>
                    <table>
                        <header>
                            <item>
                                <para>Node Test</para>
                            </item>
                            <item>
                                <para>matches all...</para>
                            </item>
                        </header>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">node()</teletype></para>
                            </item>
                            <item>
                                <para>nodes of any kind</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">text()</teletype></para>
                            </item>
                            <item>
                                <para>text nodes</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">comment()</teletype></para>
                            </item>
                            <item>
                                <para>comment nodes</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">element()</teletype></para>
                            </item>
                            <item>
                                <para>element nodes (same as star: *)</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">element(name)</teletype></para>
                            </item>
                            <item>
                                <para>element nodes named <teletype type="highlighted">name</teletype></para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">attribute()</teletype></para>
                            </item>
                            <item>
                                <para>attribute nodes</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">attribute(name)</teletype></para>
                            </item>
                            <item>
                                <para>attribute nodes named <teletype type="highlighted">name</teletype></para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">processing-instruction()</teletype></para>
                            </item>
                            <item>
                                <para>processing-instructions</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">processing-instruction(name)</teletype></para>
                            </item>
                            <item>
                                <para>processing-instructions named <teletype type="highlighted">name</teletype></para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">document-node()</teletype></para>
                            </item>
                            <item>
                                <para>document nodes (there is only one)</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">document-node(element(name))</teletype></para>
                            </item>
                            <item>
                                <para>document node with document element <teletype type="highlighted">name</teletype></para>
                            </item>
                        </row>
                    </table>
                    <target name="shorthand-form"/>
                </section>
                <section id="shorthand-form">
                    <heading level="2">Shorthand Form</heading>
                    <para>Writing axis steps using the longhand form with axis specifiers and node tests is semantically clear but syntactically verbose. The shorthand form is easy to learn and, once you learn it, just as easy to read. In the shorthand form, the axis specifier and node test are implied by the syntax. XQueries are normally written in the shorthand form. Here is a table of some frequently used shorthand forms:</para>
                    <table>
                        <header>
                            <item>
                                <para>Shorthand syntax</para>
                            </item>
                            <item>
                                <para>Short for...</para>
                            </item>
                            <item>
                                <para>matches all...</para>
                            </item>
                        </header>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">name</teletype></para>
                            </item>
                            <item>
                                <para>
                                    <teletype type="highlighted">child::element(name)</teletype></para>
                            </item>
                            <item>
                                <para>child nodes that are <teletype type="highlighted">name</teletype> elements</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">*</teletype></para>
                            </item>
                            <item>
                                <para>
                                    <teletype type="highlighted">child::element()</teletype></para>
                            </item>
                            <item>
                                <para>child nodes that are elements (<teletype type="highlighted">node()</teletype> matches <italic>all</italic> child nodes)</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">..</teletype></para>
                            </item>
                            <item>
                                <para>
                                    <teletype type="highlighted">parent::node()</teletype></para>
                            </item>
                            <item>
                                <para>parent nodes (there is only one)</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">@*</teletype></para>
                            </item>
                            <item>
                                <para>
                                    <teletype type="highlighted">attribute::attribute()</teletype></para>
                            </item>
                            <item>
                                <para>attribute nodes</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">@name</teletype></para>
                            </item>
                            <item>
                                <para>
                                    <teletype type="highlighted">attribute::attribute(name)</teletype></para>
                            </item>
                            <item>
                                <para>
                                    <teletype type="highlighted">name</teletype> attributes</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>
                                    <teletype type="highlighted">//</teletype></para>
                            </item>
                            <item>
                                <para>
                                    <teletype type="highlighted">descendant-or-self::node()</teletype></para>
                            </item>
                            <item>
                                <para>descendent nodes (when used instead of '/')</para>
                            </item>
                        </row>
                    </table>
                    <para>The <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> language specification has a more detailed section on the shorthand form, which it calls the abbreviated syntax. More examples of path expressions written in the shorthand form are found there. There is also a section listing examples of path expressions written in the longhand form.</para>
                    <target name="name-tests"/>
                </section>
                <section id="name-tests">
                    <heading level="2">Name Tests</heading>
                    <para>The name tests are the <link raw="Node Tests" href="xquery-introduction.html#node-tests" type="page" page="A Short Path to XQuery">Node Tests</link> that have the <teletype type="highlighted">name</teletype> parameter. A name test must match the node <italic>name</italic> in addition to the node <italic>kind</italic>. We have already seen name tests used:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="19"/>
                    <para>In this path expression, both <teletype type="highlighted">recipe</teletype> and <teletype type="highlighted">title</teletype> are name tests written in the shorthand form. <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> resolves these names (QNames) to their expanded form using whatever namespace declarations it knows about. Resolving a name to its expanded form means replacing its namespace prefix, if one is present (there aren't any present in the example), with a namespace URI. The expanded name then consists of the namespace URI and the local name.</para>
                    <para>But the names in the example above don't have namespace prefixes, because we didn't include a namespace declaration in our <teletype type="highlighted">cookbook.xml</teletype> file. However, we will often use <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> to query XML documents that use namespaces. Forgetting to declare the correct namespace(s) in an <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> is a common cause of <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> failures. Let's add a <italic>default</italic> namespace to <teletype type="highlighted">cookbook.xml</teletype> now. Change the <italic>document element</italic> in <teletype type="highlighted">cookbook.xml</teletype> from:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="23"/>
                    <para>to...</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="24"/>
                    <para>This is called a <italic>default namespace</italic> declaration because it doesn't include a namespace prefix. By including this default namespace declaration in the document element, we mean that all unprefixed <italic>element</italic> names in the document, including the document element itself (<teletype type="highlighted">cookbook</teletype>), are automatically in the default namespace <teletype type="highlighted">http://cookbook/namespace</teletype>. Note that unprefixed <italic>attribute</italic> names are not affected by the default namespace declaration. They are always considered to be in <italic>no namespace</italic>. Note also that the URL we choose as our namespace URI need not refer to an actual location, and doesn't refer to one in this case. But click on http://www.w3.org/XML/1998/namespace, for example, which is the namespace URI for elements and attributes prefixed with <teletype type="highlighted">xml:</teletype>.</para>
                    <para>Now when we try to run the previous <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> example, no output is produced! The path expression no longer matches anything in the cookbook file because our <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> doesn't yet know about the namespace declaration we added to the cookbook document. There are two ways we can declare the namespace in the <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link>. We can give it a <italic>namespace prefix</italic> (e.g. <teletype type="highlighted">c</teletype> for cookbook) and prefix each name test with the namespace prefix:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="3"/>
                    <para>Or we can declare the namespace to be the <italic>default element namespace</italic>, and then we can still run the original <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link>:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="4"/>
                    <para>Both methods will work and produce the same output, all the <teletype type="highlighted">&lt;title&gt;</teletype> elements:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="5"/>
                    <para>But note how the output is slightly different from the output we saw before we added the default namespace declaration to the cookbook file. Qt XML Patterns automatically includes the correct namespace attribute in each <teletype type="highlighted">&lt;title&gt;</teletype> element in the output. When Qt XML Patterns loads a document and expands a QName, it creates an instance of <link raw="QXmlName" href="qxmlname.html" type="class">QXmlName</link>, which retains the namespace prefix along with the namespace URI and the local name. See <link raw="QXmlName" href="qxmlname.html" type="class">QXmlName</link> for further details.</para>
                    <para>One thing to keep in mind from this namespace discussion, whether you run XQueries in a Qt program using Qt XML Patterns, or you run them from the command line using xmlpatterns, is that if you don't get the output you expect, it might be because the data you are querying uses namespaces, but you didn't declare those namespaces in your <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link>.</para>
                </section>
                <section id="wildcards-in-name-tests">
                    <heading level="3">Wildcards in Name Tests</heading>
                    <para>The wildcard <teletype type="highlighted">'*'</teletype> can be used in a name test. To find all the attributes in the cookbook but select only the ones in the <teletype type="highlighted">xml</teletype> namespace, use the <teletype type="highlighted">xml:</teletype> namespace prefix but replace the <italic>local name</italic> (the attribute name) with the wildcard:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="7"/>
                    <para>Oops! If you save this <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> in <teletype type="highlighted">file.xq</teletype> and run it through <teletype type="highlighted">xmlpatterns</teletype>, it doesn't work. You get an error message instead, something like this: <italic>Error SENR0001 in file:///...file.xq, at line 1, column 1: Attribute xml:id can't be serialized because it appears at the top level.</italic> The <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> actually ran correctly. It selected a bunch of <teletype type="highlighted">xml:id</teletype> attributes and put them in the result set. But then <teletype type="highlighted">xmlpatterns</teletype> sent the result set to a <link raw="QXmlSerializer" href="qxmlserializer.html" type="class">serializer</link>, which tried to output it as well-formed XML. Since the result set contains only attributes and attributes alone are not well-formed XML, the <link raw="QXmlSerializer" href="qxmlserializer.html" type="class">serializer</link> reports a serialization error.</para>
                    <para>Fear not. <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> can do more than just find and select elements and attributes. It can <link raw="Constructing Elements" href="xquery-introduction.html#constructing-elements" type="page" page="A Short Path to XQuery">construct new ones on the fly</link> as well, which is what we need to do here if we want <teletype type="highlighted">xmlpatterns</teletype> to let us see the attributes we selected. The example above and the ones below are revisited in the <link raw="Constructing Elements" href="xquery-introduction.html#constructing-elements" type="page" page="A Short Path to XQuery">Constructing Elements</link> section. You can jump ahead to see the modified examples now, and then come back, or you can press on from here.</para>
                    <para>To find all the <teletype type="highlighted">name</teletype> attributes in the cookbook and select them all regardless of their namespace, replace the namespace prefix with the wildcard and write <teletype type="highlighted">name</teletype> (the attribute name) as the local name:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="8"/>
                    <para>To find and select all the attributes of the <italic>document element</italic> in the cookbook, replace the entire name test with the wildcard:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="9"/>
                </section>
                <section id="using-predicates-in-path-expressions">
                    <heading level="1">Using Predicates In Path Expressions</heading>
                    <para>Predicates can be used to further filter the nodes selected by a path expression. A predicate is an expression in square brackets ('[' and ']') that either returns a boolean value or a number. A predicate can appear at the end of any path step in a path expression. The predicate is applied to each node in the focus set. If a node passes the filter, the node is included in the result set. The query below selects the recipe element that has the <teletype type="highlighted">&lt;title&gt;</teletype> element <teletype type="highlighted">&quot;Hard-Boiled Eggs&quot;</teletype>.</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="10"/>
                    <para>The dot expression ('.') can be used in predicates and path expressions to refer to the current context node. The following query uses the dot expression to refer to the current <teletype type="highlighted">&lt;method&gt;</teletype> element. The query selects the empty <teletype type="highlighted">&lt;method&gt;</teletype> elements from the cookbook.</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="11"/>
                    <para>Note that passing the dot expression to the string-<link raw="length()" href="stylesheet-reference.html#length" type="page" page="Qt Style Sheets Reference">length()</link> function is optional. When string-<link raw="length()" href="stylesheet-reference.html#length" type="page" page="Qt Style Sheets Reference">length()</link> is called with no parameter, the context node is assumed:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="12"/>
                    <para>Actually, selecting an empty <teletype type="highlighted">&lt;method&gt;</teletype> element might not be very useful by itself. It doesn't tell you which recipe has the empty method:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="31"/>
                    <target name="empty-method-not-robust"/>
                    <para>What you probably want to see instead are the <teletype type="highlighted">&lt;recipe&gt;</teletype> elements that have empty <teletype type="highlighted">&lt;method&gt;</teletype> elements:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="32"/>
                    <para>The predicate uses the string-<link raw="length()" href="stylesheet-reference.html#length" type="page" page="Qt Style Sheets Reference">length()</link> function to test the length of each <teletype type="highlighted">&lt;method&gt;</teletype> element in each <teletype type="highlighted">&lt;recipe&gt;</teletype> element found by the node test. If a <teletype type="highlighted">&lt;method&gt;</teletype> contains no text, the predicate evaluates to <teletype type="highlighted">true</teletype> and the <teletype type="highlighted">&lt;recipe&gt;</teletype> element is selected. If the method contains some text, the predicate evaluates to <teletype type="highlighted">false</teletype>, and the <teletype type="highlighted">&lt;recipe&gt;</teletype> element is discarded. The output is the entire recipe that has no instructions for preparation:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="33"/>
                    <para>The astute reader will have noticed that this use of <teletype type="highlighted">string-length()</teletype> to find an empty element is unreliable. It works in this case, because the method element is written as <teletype type="highlighted">&lt;method/&gt;</teletype>, guaranteeing that its string length will be 0. It will still work if the method element is written as <teletype type="highlighted">&lt;method&gt;&lt;/method&gt;</teletype>, but it will fail if there is any whitespace between the opening and ending <teletype type="highlighted">&lt;method&gt;</teletype> tags. A more robust way to find the recipes with empty methods is presented in the section on <link raw="Boolean Predicates" href="xquery-introduction.html#boolean-predicates" type="page" page="A Short Path to XQuery">Boolean Predicates</link>.</para>
                    <para>There are many more functions and operators defined for <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> and XPath. They are all documented in the specification.</para>
                </section>
                <section id="positional-predicates">
                    <heading level="2">Positional Predicates</heading>
                    <para>Predicates are often used to filter items based on their position in a sequence. For path expressions processing items loaded from XML documents, the normal sequence is document order. This query returns the second <teletype type="highlighted">&lt;recipe&gt;</teletype> element in the <teletype type="highlighted">cookbook.xml</teletype> file:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="13"/>
                    <para>The other frequently used positional function is last(), which returns the numeric position of the last item in the focus set. Stated another way, last() returns the size of the focus set. This query returns the last recipe in the cookbook:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="16"/>
                    <para>And this query returns the next to last <teletype type="highlighted">&lt;recipe&gt;</teletype>:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="17"/>
                </section>
                <section id="boolean-predicates">
                    <heading level="2">Boolean Predicates</heading>
                    <para>The other kind of predicate evaluates to <italic>true</italic> or <italic>false</italic>. A boolean predicate takes the value of its expression and determines its <italic>effective boolean value</italic> according to the following rules:</para>
                    <list type="bullet">
                        <item>
                            <para>An expression that evaluates to a single node is <teletype type="highlighted">true</teletype>.</para>
                        </item>
                        <item>
                            <para>An expression that evaluates to a string is <teletype type="highlighted">false</teletype> if the string is empty and <teletype type="highlighted">true</teletype> if the string is not empty.</para>
                        </item>
                        <item>
                            <para>An expression that evaluates to a boolean value (i.e. type <teletype type="highlighted">xs:boolean</teletype>) is that value.</para>
                        </item>
                        <item>
                            <para>If the expression evaluates to anything else, it's an error (e.g. type <teletype type="highlighted">xs:date</teletype>).</para>
                        </item>
                    </list>
                    <para>We have already seen some boolean predicates in use. Earlier, we saw a <italic>not so robust</italic> way to find the <link raw="Empty Method Not Robust" href="xquery-introduction.html#empty-method-not-robust" type="page" page="A Short Path to XQuery">recipes that have no instructions</link>. <teletype type="highlighted">[string-length(method) = 0]</teletype> is a boolean predicate that would fail in the example if the empty method element was written with both opening and closing tags and there was whitespace between the tags. Here is a more robust way that uses a different boolean predicate.</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="34"/>
                    <para>This one uses the empty() and function to test whether the method contains any steps. If the method contains no steps, then <teletype type="highlighted">empty(step)</teletype> will return <teletype type="highlighted">true</teletype>, and hence the predicate will evaluate to <teletype type="highlighted">true</teletype>.</para>
                    <para>But even that version isn't foolproof. Suppose the method does contain steps, but all the steps themselves are empty. That's still a case of a recipe with no instructions that won't be detected. There is a better way:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="35"/>
                    <para>This version uses the not and normalize-space() functions. <teletype type="highlighted">normalize-space(method))</teletype> returns the contents of the method element as a string, but with all the whitespace normalized, i.e., the string value of each <teletype type="highlighted">&lt;step&gt;</teletype> element will have its whitespace normalized, and then all the normalized step values will be concatenated. If that string is empty, then <teletype type="highlighted">not()</teletype> returns <teletype type="highlighted">true</teletype> and the predicate is <teletype type="highlighted">true</teletype>.</para>
                    <para>We can also use the position() function in a comparison to inspect positions with conditional logic. The position() function returns the position index of the current context item in the sequence of items:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="14"/>
                    <para>Note that the first position in the sequence is position 1, not 0. We can also select <italic>all</italic> the recipes after the first one:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="15"/>
                    <target name="constructing-elements"/>
                </section>
                <section id="constructing-elements">
                    <heading level="1">Constructing Elements</heading>
                    <para>In the section about <link raw="Wildcards in Name Tests" href="xquery-introduction.html#wildcards-in-name-tests" type="page" page="A Short Path to XQuery">using wildcards in name tests</link>, we saw three simple example XQueries, each of which selected a different list of XML attributes from the cookbook. We couldn't use <teletype type="highlighted">xmlpatterns</teletype> to run these queries, however, because <teletype type="highlighted">xmlpatterns</teletype> sends the <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> results to a <link raw="QXmlSerializer" href="qxmlserializer.html" type="class">serializer</link>, which expects to serialize the results as well-formed XML. Since a list of XML attributes by itself is not well-formed XML, the serializer reported an error for each <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link>.</para>
                    <para>Since an attribute must appear in an element, for each attribute in the result set, we must create an XML element. We can do that using a <italic>for</italic> clause with a bound variable, and a <italic>return</italic> clause with an element constructor:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="25"/>
                    <para>The <italic>for</italic> clause produces a sequence of attribute nodes from the result of the path expression. Each attribute node in the sequence is bound to the variable <teletype type="highlighted">$i</teletype>. The <italic>return</italic> clause then constructs a <teletype type="highlighted">&lt;p&gt;</teletype> element around the attribute node. Here is the output:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="28"/>
                    <para>The output contains one <teletype type="highlighted">&lt;p&gt;</teletype> element for each <teletype type="highlighted">xml:id</teletype> attribute in the cookbook. Note that <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> puts each attribute in the right place in its <teletype type="highlighted">&lt;p&gt;</teletype> element, despite the fact that in the <italic>return</italic> clause, the <teletype type="highlighted">$i</teletype> variable is positioned as if it is meant to become <teletype type="highlighted">&lt;p&gt;</teletype> element content.</para>
                    <para>The other two examples from the <link raw="Wildcards in Name Tests" href="xquery-introduction.html#wildcards-in-name-tests" type="page" page="A Short Path to XQuery">wildcard</link> section can be rewritten the same way. Here is the <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> that selects all the <teletype type="highlighted">name</teletype> attributes, regardless of namespace:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="26"/>
                    <para>And here is its output:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="29"/>
                    <para>And here is the <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> that selects all the attributes from the <italic>document element</italic>:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="27"/>
                    <para>And here is its output:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="30"/>
                </section>
                <section id="element-constructors-are-expressions">
                    <heading level="2">Element Constructors are Expressions</heading>
                    <para>Because node constructors are expressions, they can be used in XQueries wherever expressions are allowed.</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="40"/>
                    <para>If <teletype type="highlighted">cookbook.xml</teletype> is loaded without error, a <teletype type="highlighted">&lt;oppskrift&gt;</teletype> element (Norwegian word for recipe) is constructed for each <teletype type="highlighted">&lt;recipe&gt;</teletype> element in the cookbook, and the child nodes of the <teletype type="highlighted">&lt;recipe&gt;</teletype> are copied into the <teletype type="highlighted">&lt;oppskrift&gt;</teletype> element. But if the cookbook document doesn't exist or does not contain well-formed XML, a single <teletype type="highlighted">&lt;oppskrift&gt;</teletype> element is constructed containing an error message.</para>
                </section>
                <section id="constructing-atomic-values">
                    <heading level="1">Constructing Atomic Values</heading>
                    <para>
                        <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> also has atomic values. An atomic value is a value in the value space of one of the built-in datatypes in the XML Schema language. These <italic>atomic types</italic> have built-in operators for doing arithmetic, comparisons, and for converting values to other atomic types. See the Built-in Datatype Hierarchy for the entire tree of built-in, primitive and derived atomic types.</para>
                    <para>
                        <bold>Note:</bold> Click on a data type in the tree for its detailed specification.</para>
                    <para>To construct an atomic value as element content, enclose an expression in curly braces and embed it in the element constructor:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="36"/>
                    <para>Sending this <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> through xmlpatterns produces:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="37"/>
                    <para>To compute the value of an attribute, enclose the expression in curly braces and embed it in the attribute value:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="38"/>
                    <para>Sending this <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> through xmlpatterns produces:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="39"/>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="40"/>
                    <para>If <teletype type="highlighted">cookbook.xml</teletype> is loaded without error, a <teletype type="highlighted">&lt;oppskrift&gt;</teletype> element (Norweigian word for recipe) is constructed for each <teletype type="highlighted">&lt;recipe&gt;</teletype> element in the cookbook, and the child nodes of the <teletype type="highlighted">&lt;recipe&gt;</teletype> are copied into the <teletype type="highlighted">&lt;oppskrift&gt;</teletype> element. But if the cookbook document doesn't exist or does not contain well-formed XML, a single <teletype type="highlighted">&lt;oppskrift&gt;</teletype> element is constructed containing an error message.</para>
                </section>
                <section id="running-the-cookbook-examples">
                    <heading level="1">Running The Cookbook Examples</heading>
                    <para>Most of the <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> examples in this document refer to the <teletype type="highlighted">cookbook.xml</teletype> example file from the <link raw="Recipes Example" href="qtxmlpatterns-recipes-example.html" type="page" page="Recipes Example">Recipes Example</link>. Copy the <teletype type="highlighted">cookbook.xml</teletype> to your current directory, save one of the cookbook <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> examples in a <teletype type="highlighted">.xq</teletype> file (e.g., <teletype type="highlighted">file.xq</teletype>), and run the <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> using Qt's command line utility:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="6"/>
                </section>
                <section id="further-reading">
                    <heading level="1">Further Reading</heading>
                    <para>There is much more to the <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> language than we have presented in this short introduction. We will be adding more here in later releases. In the meantime, playing with the <teletype type="highlighted">xmlpatterns</teletype> utility and making modifications to the <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> examples provided here will be quite informative. An <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> textbook will be a good investment.</para>
                    <para>You can also ask questions on <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> mail lists:</para>
                    <list type="bullet">
                        <item>
                            <para>qt-interest</para>
                        </item>
                        <item>
                            <para>talk at x-query.com.</para>
                        </item>
                    </list>
                    <para>FunctX has a collection of <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> functions that can be both useful and educational.</para>
                    <para>This introduction contains many links to the specifications, which, of course, are the ultimate source of information about <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link>. They can be a bit difficult, though, so consider investing in a textbook:</para>
                    <list type="bullet">
                        <item>
                            <para>
                                <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> 1.0: An XML Query Language - the main source for syntax and semantics.</para>
                        </item>
                        <item>
                            <para>
                                <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> 1.0 and XPath 2.0 Functions and Operators - the builtin functions and operators.</para>
                        </item>
                    </list>
                </section>
                <section id="faq">
                    <heading level="1">FAQ</heading>
                    <para>The answers to these frequently asked questions explain the causes of several common mistakes that most beginners make. Reading through the answers ahead of time might save you a lot of head scratching.</para>
                </section>
                <section id="why-didn-t-my-path-expression-match-anything">
                    <heading level="2">Why didn't my path expression match anything?</heading>
                    <para>The most common cause of this bug is failure to declare one or more namespaces in your <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link>. Consider the following query for selecting all the examples in an XHTML document:</para>
                    <quotefile>patternist/simpleHTML.xq</quotefile>
                    <para>It won't match anything because <teletype type="highlighted">index.html</teletype> is an XHTML file, and all XHTML files declare the default namespace <teletype type="highlighted">&quot;http://www.w3.org/1999/xhtml&quot;</teletype> in their top (<teletype type="highlighted">&lt;html&gt;</teletype>) element. But the query doesn't declare this namespace, so the path expression expands <teletype type="highlighted">html</teletype> to <teletype type="highlighted">{}html</teletype> and tries to match that expanded name. But the actual expanded name is <teletype type="highlighted">{http://www.w3.org/1999/xhtml}html</teletype>. One possible fix is to declare the correct default namespace in the <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link>:</para>
                    <quotefile>patternist/simpleXHTML.xq</quotefile>
                    <para>Another common cause of this bug is to confuse the <italic>document node</italic> with the top element node. They are different. This query won't match anything:</para>
                    <quotefile>patternist/docPlainHTML.xq</quotefile>
                    <para>The <teletype type="highlighted">doc()</teletype> function returns the <italic>document node</italic>, not the top element node (<teletype type="highlighted">&lt;html&gt;</teletype>). Don't forget to match the top element node in the path expression:</para>
                    <quotefile>patternist/docPlainHTML2.xq</quotefile>
                </section>
                <section id="what-if-my-input-namespace-is-different-from-my-output-namespace">
                    <heading level="2">What if my input namespace is different from my output namespace?</heading>
                    <para>Just remember to declare both namespaces in your <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> and use them properly. Consider the following query, which is meant to generate XHTML output from XML input:</para>
                    <quotefile>patternist/embedDataInXHTML.xq</quotefile>
                    <para>We want the <teletype type="highlighted">&lt;html&gt;</teletype>, <teletype type="highlighted">&lt;body&gt;</teletype>, and <teletype type="highlighted">&lt;p&gt;</teletype> nodes we create in the output to be in the standard XHTML namespace, so we declare the default namespace to be <teletype type="highlighted">http://www.w3.org/1999/xhtml</teletype>. That's correct for the output, but that same default namespace will also be applied to the node names in the path expression we're trying to match in the input (<teletype type="highlighted">/tests/test[@status = &quot;failure&quot;]</teletype>), which is wrong, because the namespace used in <teletype type="highlighted">testResult.xml</teletype> is perhaps in the empty namespace. So we must declare that namespace too, with a namespace prefix, and then use the prefix with the node names in the path expression. This one will probably work better:</para>
                    <quotefile>patternist/embedDataInXHTML2.xq</quotefile>
                </section>
                <section id="why-doesn-t-my-return-clause-work">
                    <heading level="2">Why doesn't my return clause work?</heading>
                    <para>Recall that <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> is an <italic>expression-based</italic> language, not <italic>statement-based</italic>. Because an <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> is a lot of expressions, understanding <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> expression precedence is very important. Consider the following query:</para>
                    <quotefile>patternist/forClause2.xq</quotefile>
                    <para>It looks ok, but it isn't. It is supposed to be a FLWOR expression comprising a <italic>for</italic> clause and a <italic>return</italic> clause, but it isn't just that. It <italic>has</italic> a FLWOR expression, certainly (with the <italic>for</italic> and <italic>return</italic> clauses), but it <italic>also</italic> has an arithmetic expression (<italic>+ $d</italic>) dangling at the end because we didn't enclose the return expression in parentheses.</para>
                    <para>Using parentheses to establish precedence is more important in <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> than in other languages, because <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> is <italic>expression-based</italic>. In In this case, without parantheses enclosing <teletype type="highlighted">$i + $d</teletype>, the return clause only returns <teletype type="highlighted">$i</teletype>. The <teletype type="highlighted">+$d</teletype> will have the result of the FLWOR expression as its left operand. And, since the scope of variable <teletype type="highlighted">$d</teletype> ends at the end of the <italic>return</italic> clause, a variable out of scope error will be reported. Correct these problems by using parentheses.</para>
                    <quotefile>patternist/forClause.xq</quotefile>
                </section>
                <section id="why-didn-t-my-expression-get-evaluated">
                    <heading level="2">Why didn't my expression get evaluated?</heading>
                    <para>You probably misplaced some curly braces. When you want an expression evaluated inside an element constructor, enclose the expression in curly braces. Without the curly braces, the expression will be interpreted as text. Here is a <teletype type="highlighted">sum()</teletype> expression used in an <teletype type="highlighted">&lt;e&gt;</teletype> element. The table shows cases where the curly braces are missing, misplaced, and placed correctly:</para>
                    <table>
                        <header>
                            <item>
                                <para>element constructor with expression...</para>
                            </item>
                            <item>
                                <para>evaluates to...</para>
                            </item>
                        </header>
                        <row>
                            <item>
                                <para>&lt;e&gt;sum((1, 2, 3))&lt;/e&gt;</para>
                            </item>
                            <item>
                                <para>&lt;e&gt;sum((1, 2, 3))&lt;/e&gt;</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>&lt;e&gt;sum({(1, 2, 3)})&lt;/e&gt;</para>
                            </item>
                            <item>
                                <para>&lt;e&gt;sum(1 2 3)&lt;/e&gt;</para>
                            </item>
                        </row>
                        <row>
                            <item>
                                <para>&lt;e&gt;{sum((1, 2, 3))}&lt;/e&gt;</para>
                            </item>
                            <item>
                                <para>&lt;e&gt;6&lt;/e&gt;</para>
                            </item>
                        </row>
                    </table>
                </section>
                <section id="my-predicate-is-correct-so-why-doesn-t-it-select-the-right-stuff">
                    <heading level="2">My predicate is correct, so why doesn't it select the right stuff?</heading>
                    <para>Either you put your predicate in the wrong place in your path expression, or you forgot to add some parentheses. Consider this input file <teletype type="highlighted">doc.txt</teletype>:</para>
                    <quotefile>patternist/doc.txt</quotefile>
                    <para>Suppose you want the first <teletype type="highlighted">&lt;span&gt;</teletype> element of every <teletype type="highlighted">&lt;p&gt;</teletype> element. Apply a position filter (<teletype type="highlighted">[1]</teletype>) to the <teletype type="highlighted">/span</teletype> path step:</para>
                    <quotefile>patternist/filterOnStep.xq</quotefile>
                    <para>Applying the <teletype type="highlighted">[1]</teletype> filter to the <teletype type="highlighted">/span</teletype> step returns the first <teletype type="highlighted">&lt;span&gt;</teletype> element of each <teletype type="highlighted">&lt;p&gt;</teletype> element:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="41"/>
                    <para>
                        <bold>Note:</bold> : You can write the same query this way:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="44"/>
                    <para>Or you can reduce it right down to this:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="45"/>
                    <para>On the other hand, suppose you really want only one <teletype type="highlighted">&lt;span&gt;</teletype> element, the first one in the document (i.e., you only want the first <teletype type="highlighted">&lt;span&gt;</teletype> element in the first <teletype type="highlighted">&lt;p&gt;</teletype> element). Then you have to do more filtering. There are two ways you can do it. You can apply the <teletype type="highlighted">[1]</teletype> filter in the same place as above but enclose the path expression in parentheses:</para>
                    <quotefile>patternist/filterOnPath.xq</quotefile>
                    <para>Or you can apply a second position filter (<teletype type="highlighted">[1]</teletype> again) to the <teletype type="highlighted">/p</teletype> path step:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="43"/>
                    <para>Either way the query will return only the first <teletype type="highlighted">&lt;span&gt;</teletype> element in the document:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="42"/>
                </section>
                <section id="why-doesn-t-my-flwor-behave-as-expected">
                    <heading level="2">Why doesn't my FLWOR behave as expected?</heading>
                    <para>The quick answer is you probably expected your <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link> FLWOR to behave just like a C++ <italic>for</italic> loop. But they aren't the same. Consider a simple example:</para>
                    <quotefile>patternist/letOrderBy.xq</quotefile>
                    <para>This query evaluates to <italic>4 -4 -2 2 -8 8</italic>. The <italic>for</italic> clause does set up a <italic>for</italic> loop style iteration, which does evaluate the rest of the FLWOR multiple times, one time for each value returned by the <italic>in</italic> expression. That much is similar to the C++ <italic>for</italic> loop.</para>
                    <para>But consider the <italic>return</italic> clause. In C++ if you hit a <italic>return</italic> statement, you break out of the <italic>for</italic> loop and return from the function with one value. Not so in <link raw="XQuery" href="xmlprocessing.html" type="page" page="XQuery">XQuery</link>. The <italic>return</italic> clause is the last clause of the FLWOR, and it means: <italic>Append the return value to the result list and then begin the next iteration of the FLWOR</italic>. When the <italic>for</italic> clause's <italic>in</italic> expression no longer returns a value, the entire result list is returned.</para>
                    <para>Next, consider the <italic>order by</italic> clause. It doesn't do any sorting on each iteration of the FLWOR. It just evaluates its expression on each iteration (<teletype type="highlighted">$a</teletype> in this case) to get an ordering value to map to the result item from each iteration. These ordering values are kept in a parallel list. The result list is sorted at the end using the parallel list of ordering values.</para>
                    <para>The last difference to note here is that the <italic>let</italic> clause does <italic>not</italic> set up an iteration through a sequence of values like the <italic>for</italic> clause does. The <italic>let</italic> clause isn't a sort of nested loop. It isn't a loop at all. It is just a variable binding. On each iteration, it binds the <italic>entire</italic> sequence of values on the right to the variable on the left. In the example above, it binds (4 -4) to <teletype type="highlighted">$b</teletype> on the first iteration, (-2 2) on the second iteration, and (-8 8) on the third iteration. So the following query doesn't iterate through anything, and doesn't do any ordering:</para>
                    <quotefile>patternist/invalidLetOrderBy.xq</quotefile>
                    <para>It binds the entire sequence (2, 3, 1) to <teletype type="highlighted">$i</teletype> one time only; the <italic>order by</italic> clause only has one thing to order and hence does nothing, and the query evaluates to 2 3 1, the sequence assigned to <teletype type="highlighted">$i</teletype>.</para>
                    <para>
                        <bold>Note:</bold> We didn't include a <italic>where</italic> clause in the example. The <italic>where</italic> clause is for filtering results.</para>
                </section>
                <section id="why-are-my-elements-created-in-the-wrong-order">
                    <heading level="2">Why are my elements created in the wrong order?</heading>
                    <para>The short answer is your elements are <italic>not</italic> created in the wrong order, because when appearing as operands to a path expression, there is no correct order. Consider the following query, which again uses the input file <teletype type="highlighted">doc.txt</teletype>:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="46"/>
                    <para>The query finds all the <teletype type="highlighted">&lt;p&gt;</teletype> elements in the file. For each <teletype type="highlighted">&lt;p&gt;</teletype> element, it builds a <teletype type="highlighted">&lt;p&gt;</teletype> element in the output containing the concatenated contents of all the <teletype type="highlighted">&lt;p&gt;</teletype> element's child <teletype type="highlighted">&lt;span&gt;</teletype> elements. Running the query through <teletype type="highlighted">xmlpatterns</teletype> might produce the following output, which is not sorted in the expected order.</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="47"/>
                    <para>You can use a <italic>for</italic> loop to ensure that the order of the result set corresponds to the order of the input sequence:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="48"/>
                    <para>This version produces the same result set but in the expected order:</para>
                    <snippet location="code/doc_src_qtxmlpatterns.qdoc" path="C:/Qt/5.11.1/Src/qtxmlpatterns/src/xmlpatterns/doc/snippets/code/doc_src_qtxmlpatterns.qdoc" identifier="49"/>
                </section>
                <section id="why-can-t-i-use-keyword-true-keyword-and-keyword-false-keyword-in-my-xquery">
                    <heading level="2">Why can't I use <teletype type="highlighted">true</teletype> and <teletype type="highlighted">false</teletype> in my XQuery?</heading>
                    <para>You can, but not by just using the names <teletype type="highlighted">true</teletype> and <teletype type="highlighted">false</teletype> directly, because they are <link raw="Name Tests" href="xquery-introduction.html#name-tests" type="page" page="A Short Path to XQuery">name tests</link> although they look like boolean constants. The simple way to create the boolean values is to use the builtin functions <teletype type="highlighted">true()</teletype> and <teletype type="highlighted">false()</teletype> wherever you want to use <teletype type="highlighted">true</teletype> and <teletype type="highlighted">false</teletype>. The other way is to invoke the boolean constructor:</para>
                    <quotefile>patternist/xsBooleanTrue.xq</quotefile>
                </section>
            </description>
        </page>
    </document>
</WebXML>
