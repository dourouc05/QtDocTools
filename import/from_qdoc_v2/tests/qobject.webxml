<?xml version="1.0" encoding="UTF-8"?>
<WebXML>
    <document>
        <class threadsafety="reentrant" name="QObject" href="qobject.html" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="117" module="QtCore" groups="objectmodel" brief="The base class of all Qt objects">
            <target name="no-copy-constructor" title="No copy constructor"/>
            <contents name="thread-affinity" title="Thread Affinity" level="1"/>
            <contents name="no-copy-constructor-or-assignment-operator" title="No Copy Constructor or Assignment Operator" level="1"/>
            <contents name="auto-connection" title="Auto-Connection" level="1"/>
            <contents name="dynamic-properties" title="Dynamic Properties" level="1"/>
            <contents name="internationalization-i18n" title="Internationalization (I18n)" level="1"/>
            <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="607" column="4">
                <brief>The <link raw="QObject" href="qobject.html" type="class">QObject</link> class is the base class of all Qt objects.</brief>
                <para>
                    <link raw="QObject" href="qobject.html" type="class">QObject</link> is the heart of the Qt <link raw="Object Model" href="object.html" type="page" page="Object Model">Object Model</link>. The central feature in this model is a very powerful mechanism for seamless object communication called <link raw="signals and slots" href="signalsandslots.html" type="page" page="Signals &amp; Slots">signals and slots</link>. You can connect a signal to a slot with <link raw="connect()" href="qobject.html#connect" type="function">connect()</link> and destroy the connection with <link raw="disconnect()" href="qobject.html#disconnect" type="function">disconnect()</link>. To avoid never ending notification loops you can temporarily block signals with <link raw="blockSignals()" href="qobject.html#blockSignals" type="function">blockSignals()</link>. The protected functions <link raw="connectNotify()" href="qobject.html#connectNotify" type="function">connectNotify()</link> and <link raw="disconnectNotify()" href="qobject.html#disconnectNotify" type="function">disconnectNotify()</link> make it possible to track connections.</para>
                <para>QObjects organize themselves in <link raw="Object Trees &amp; Ownership" href="objecttrees.html" type="page" page="Object Trees &amp; Ownership">object trees</link>. When you create a <link raw="QObject" href="qobject.html" type="class">QObject</link> with another object as parent, the object will automatically add itself to the parent's <link raw="children()" href="qobject.html#children" type="function">children()</link> list. The parent takes ownership of the object; i.e., it will automatically delete its children in its destructor. You can look for an object by name and optionally type using <link raw="findChild()" href="qobject.html#findChild" type="function">findChild()</link> or <link raw="findChildren()" href="qobject.html#findChildren" type="function">findChildren()</link>.</para>
                <para>Every object has an <link raw="objectName()" href="qobject.html#objectName-prop" type="function">objectName()</link> and its class name can be found via the corresponding <link raw="metaObject()" href="qobject.html#metaObject" type="function">metaObject()</link> (see <link raw="QMetaObject::className()" href="qmetaobject.html#className" type="function">QMetaObject::className()</link>). You can determine whether the object's class inherits another class in the <link raw="QObject" href="qobject.html" type="class">QObject</link> inheritance hierarchy by using the <link raw="inherits()" href="qobject.html#inherits" type="function">inherits()</link> function.</para>
                <para>When an object is deleted, it emits a <link raw="destroyed()" href="qobject.html#destroyed" type="function">destroyed()</link> signal. You can catch this signal to avoid dangling references to QObjects.</para>
                <para>QObjects can receive events through <link raw="event()" href="qobject.html#event" type="function">event()</link> and filter the events of other objects. See <link raw="installEventFilter()" href="qobject.html#installEventFilter" type="function">installEventFilter()</link> and <link raw="eventFilter()" href="qobject.html#eventFilter" type="function">eventFilter()</link> for details. A convenience handler, <link raw="childEvent()" href="qobject.html#childEvent" type="function">childEvent()</link>, can be reimplemented to catch child events.</para>
                <para>Last but not least, <link raw="QObject" href="qobject.html" type="class">QObject</link> provides the basic timer support in Qt; see <link raw="QTimer" href="qtimer.html" type="class">QTimer</link> for high-level support for timers.</para>
                <para>Notice that the <link raw="Q_OBJECT" href="qobject.html#Q_OBJECT" type="function">Q_OBJECT</link> macro is mandatory for any object that implements signals, slots or properties. You also need to run the <link raw="moc" href="moc.html" type="page" page="Using the Meta-Object Compiler (moc)">Meta Object Compiler</link> on the source file. We strongly recommend the use of this macro in all subclasses of <link raw="QObject" href="qobject.html" type="class">QObject</link> regardless of whether or not they actually use signals, slots and properties, since failure to do so may lead certain functions to exhibit strange behavior.</para>
                <para>All Qt widgets inherit <link raw="QObject" href="qobject.html" type="class">QObject</link>. The convenience function <link raw="isWidgetType()" href="qobject.html#isWidgetType" type="function">isWidgetType()</link> returns whether an object is actually a widget. It is much faster than qobject_cast&lt;<link raw="QWidget" href="qwidget.html" type="class">QWidget</link> *&gt;(<italic>obj</italic>) or <italic>obj</italic>-&gt;<link raw="inherits()" href="qobject.html#inherits" type="function">inherits</link>(&quot;<link raw="QWidget" href="qwidget.html" type="class">QWidget</link>&quot;).</para>
                <para>Some <link raw="QObject" href="qobject.html" type="class">QObject</link> functions, e.g. <link raw="children()" href="qobject.html#children" type="function">children()</link>, return a <link raw="QObjectList" href="qobject.html#QObjectList-typedef" type="typedef">QObjectList</link>. <link raw="QObjectList" href="qobject.html#QObjectList-typedef" type="typedef">QObjectList</link> is a typedef for <link raw="QList" href="qlist.html" type="class">QList</link>&lt;<link raw="QObject" href="qobject.html" type="class">QObject</link> *&gt;.</para>
                <section id="thread-affinity">
                    <heading level="1">Thread Affinity</heading>
                    <para>A <link raw="QObject" href="qobject.html" type="class">QObject</link> instance is said to have a <italic>thread affinity</italic>, or that it <italic>lives</italic> in a certain thread. When a <link raw="QObject" href="qobject.html" type="class">QObject</link> receives a <link raw="Qt::QueuedConnection" href="qt.html#ConnectionType-enum" type="enum" enum="Qt::ConnectionType">queued signal</link> or a <link raw="The Event System#Sending Events" href="eventsandfilters.html#sending-events" type="page" page="The Event System">posted event</link>, the slot or event handler will run in the thread that the object lives in.</para>
                    <para>
                        <bold>Note:</bold> If a <link raw="QObject" href="qobject.html" type="class">QObject</link> has no thread affinity (that is, if <link raw="thread()" href="qobject.html#thread" type="function">thread()</link> returns zero), or if it lives in a thread that has no running event loop, then it cannot receive queued signals or posted events.</para>
                    <para>By default, a <link raw="QObject" href="qobject.html" type="class">QObject</link> lives in the thread in which it is created. An object's thread affinity can be queried using <link raw="thread()" href="qobject.html#thread" type="function">thread()</link> and changed using <link raw="moveToThread()" href="qobject.html#moveToThread" type="function">moveToThread()</link>.</para>
                    <para>All QObjects must live in the same thread as their parent. Consequently:</para>
                    <list type="bullet">
                        <item>
                            <para>
                                <link raw="setParent()" href="qobject.html#setParent" type="function">setParent()</link> will fail if the two QObjects involved live in different threads.</para>
                        </item>
                        <item>
                            <para>When a <link raw="QObject" href="qobject.html" type="class">QObject</link> is moved to another thread, all its children will be automatically moved too.</para>
                        </item>
                        <item>
                            <para>
                                <link raw="moveToThread()" href="qobject.html#moveToThread" type="function">moveToThread()</link> will fail if the <link raw="QObject" href="qobject.html" type="class">QObject</link> has a parent.</para>
                        </item>
                        <item>
                            <para>If QObjects are created within <link raw="QThread::run()" href="qthread.html#run" type="function">QThread::run()</link>, they cannot become children of the <link raw="QThread" href="qthread.html" type="class">QThread</link> object because the <link raw="QThread" href="qthread.html" type="class">QThread</link> does not live in the thread that calls <link raw="QThread::run()" href="qthread.html#run" type="function">QThread::run()</link>.</para>
                        </item>
                    </list>
                    <para>
                        <bold>Note:</bold> A <link raw="QObject" href="qobject.html" type="class">QObject</link>'s member variables <italic>do not</italic> automatically become its children. The parent-child relationship must be set by either passing a pointer to the child's <link raw="QObject()" href="qobject.html#QObject" type="function">constructor</link>, or by calling <link raw="setParent()" href="qobject.html#setParent" type="function">setParent()</link>. Without this step, the object's member variables will remain in the old thread when <link raw="moveToThread()" href="qobject.html#moveToThread" type="function">moveToThread()</link> is called.</para>
                    <target name="no-copy-constructor"/>
                </section>
                <section id="no-copy-constructor-or-assignment-operator">
                    <heading level="1">No Copy Constructor or Assignment Operator</heading>
                    <para>
                        <link raw="QObject" href="qobject.html" type="class">QObject</link> has neither a copy constructor nor an assignment operator. This is by design. Actually, they are declared, but in a <teletype type="highlighted">private</teletype> section with the macro <link raw="Q_DISABLE_COPY()" href="qobject.html#Q_DISABLE_COPY" type="function">Q_DISABLE_COPY()</link>. In fact, all Qt classes derived from <link raw="QObject" href="qobject.html" type="class">QObject</link> (direct or indirect) use this macro to declare their copy constructor and assignment operator to be private. The reasoning is found in the discussion on <link raw="Identity vs Value" href="object.html#identity-vs-value" type="page" page="Object Model">Identity vs Value</link> on the Qt <link raw="Object Model" href="object.html" type="page" page="Object Model">Object Model</link> page.</para>
                    <para>The main consequence is that you should use pointers to <link raw="QObject" href="qobject.html" type="class">QObject</link> (or to your <link raw="QObject" href="qobject.html" type="class">QObject</link> subclass) where you might otherwise be tempted to use your <link raw="QObject" href="qobject.html" type="class">QObject</link> subclass as a value. For example, without a copy constructor, you can't use a subclass of <link raw="QObject" href="qobject.html" type="class">QObject</link> as the value to be stored in one of the container classes. You must store pointers.</para>
                </section>
                <section id="auto-connection">
                    <heading level="1">Auto-Connection</heading>
                    <para>Qt's meta-object system provides a mechanism to automatically connect signals and slots between <link raw="QObject" href="qobject.html" type="class">QObject</link> subclasses and their children. As long as objects are defined with suitable object names, and slots follow a simple naming convention, this connection can be performed at run-time by the <link raw="QMetaObject::connectSlotsByName()" href="qmetaobject.html#connectSlotsByName" type="function">QMetaObject::connectSlotsByName()</link> function.</para>
                    <para>
                        <link raw="uic" href="uic.html" type="page" page="User Interface Compiler (uic)">uic</link> generates code that invokes this function to enable auto-connection to be performed between widgets on forms created with <italic>Qt Designer</italic>. More information about using auto-connection with <italic>Qt Designer</italic> is given in the <link raw="Using a Designer UI File in Your Application" href="designer-using-a-ui-file.html" type="page" page="Using a Designer UI File in Your Application">Using a Designer UI File in Your Application</link> section of the <italic>Qt Designer</italic> manual.</para>
                </section>
                <section id="dynamic-properties">
                    <heading level="1">Dynamic Properties</heading>
                    <para>From Qt 4.2, dynamic properties can be added to and removed from <link raw="QObject" href="qobject.html" type="class">QObject</link> instances at run-time. Dynamic properties do not need to be declared at compile-time, yet they provide the same advantages as static properties and are manipulated using the same API - using <link raw="property()" href="qobject.html#property" type="function">property()</link> to read them and <link raw="setProperty()" href="qobject.html#setProperty" type="function">setProperty()</link> to write them.</para>
                    <para>From Qt 4.3, dynamic properties are supported by <link raw="Qt Designer's Widget Editing Mode#The Property Editor" href="designer-widget-mode.html#the-property-editor" type="page" page="Qt Designer's Widget Editing Mode">Qt Designer</link>, and both standard Qt widgets and user-created forms can be given dynamic properties.</para>
                </section>
                <section id="internationalization-i18n">
                    <heading level="1">Internationalization (I18n)</heading>
                    <para>All <link raw="QObject" href="qobject.html" type="class">QObject</link> subclasses support Qt's translation features, making it possible to translate an application's user interface into different languages.</para>
                    <para>To make user-visible text translatable, it must be wrapped in calls to the <link raw="tr()" href="qobject.html#tr" type="function">tr()</link> function. This is explained in detail in the <link raw="Writing Source Code for Translation" href="i18n-source-translation.html" type="page" page="Writing Source Code for Translation">Writing Source Code for Translation</link> document.</para>
                </section>
                <see-also>
                    <link raw="QMetaObject" href="qmetaobject.html" type="class">QMetaObject</link>
                    <link raw="QPointer" href="qpointer.html" type="class">QPointer</link>
                    <link raw="QObjectCleanupHandler" href="qobjectcleanuphandler.html" type="class">QObjectCleanupHandler</link>
                    <link raw="Q_DISABLE_COPY()" href="qobject.html#Q_DISABLE_COPY" type="function">Q_DISABLE_COPY()</link>
                    <link raw="Object Trees &amp; Ownership" href="objecttrees.html" type="page" page="Object Trees &amp; Ownership">Object Trees &amp; Ownership</link>
                </see-also>
            </description>
            <variable threadsafety="unspecified" name="staticMetaObject" fullname="QObject::staticMetaObject" href="qobject.html#staticMetaObject-var" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="119" type="const QMetaObject" static="true">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="1074" column="4">
                    <para>This variable stores the meta-object for the class.</para>
                    <para>A meta-object contains information about a class that inherits <link raw="QObject" href="qobject.html" type="class">QObject</link>, e.g. class name, superclass name, properties, signals and slots. Every class that contains the <link raw="Q_OBJECT" href="qobject.html#Q_OBJECT" type="function">Q_OBJECT</link> macro will also have a meta-object.</para>
                    <para>The meta-object information is required by the signal/slot connection mechanism and the property system. The <link raw="inherits()" href="qobject.html#inherits" type="function">inherits()</link> function also makes use of the meta-object.</para>
                    <para>If you have a pointer to an object, you can use <link raw="metaObject()" href="qobject.html#metaObject" type="function">metaObject()</link> to retrieve the meta-object associated with that object.</para>
                    <para>Example:</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="2"/>
                    <see-also>
                        <link raw="metaObject()" href="qobject.html#metaObject" type="function">metaObject()</link>
                    </see-also>
                </description>
            </variable>
            <function threadsafety="unspecified" name="metaObject" fullname="QObject::metaObject" href="qobject.html#metaObject" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="119" virtual="virtual" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="const QMetaObject *" signature="const QMetaObject * metaObject() const">
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="qt_metacast" fullname="QObject::qt_metacast" href="qobject.html#qt_metacast" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="119" virtual="virtual" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="void *" signature="void * qt_metacast(const char *)">
                <parameter type="const char *" name="" default=""/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="qt_metacall" fullname="QObject::qt_metacall" href="qobject.html#qt_metacall" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="119" virtual="virtual" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="int" signature="int qt_metacall(QMetaObject::Call , int , void **)">
                <parameter type="QMetaObject::Call" name="" default=""/>
                <parameter type="int" name="" default=""/>
                <parameter type="void **" name="" default=""/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="tr" fullname="QObject::tr" href="qobject.html#tr" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="119" virtual="non" meta="plain" const="false" static="true" overload="false" delete="false" default="false" final="false" override="false" type="QString" signature="QString tr(const char *s, const char *c, int n)">
                <parameter type="const char *" name="s" default=""/>
                <parameter type="const char *" name="c" default="Q_OBJECT"/>
                <parameter type="int" name="n" default="Q_OBJECT"/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="trUtf8" fullname="QObject::trUtf8" href="qobject.html#trUtf8" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="119" virtual="non" meta="plain" const="false" static="true" overload="false" delete="false" default="false" final="false" override="false" type="QString" signature="QString trUtf8(const char *s, const char *c, int n)">
                <parameter type="const char *" name="s" default=""/>
                <parameter type="const char *" name="c" default="Q_OBJECT"/>
                <parameter type="int" name="n" default="Q_OBJECT"/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="qt_static_metacall" fullname="QObject::qt_static_metacall" href="qobject.html#qt_static_metacall" status="active" access="private" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="119" virtual="non" meta="plain" const="false" static="true" overload="false" delete="false" default="false" final="false" override="false" type="void" signature="void qt_static_metacall(QObject *, QMetaObject::Call , int , void **)">
                <parameter type="QObject *" name="" default=""/>
                <parameter type="QMetaObject::Call" name="" default=""/>
                <parameter type="int" name="" default=""/>
                <parameter type="void **" name="" default=""/>
                <description path="" line="0" column="0"/>
            </function>
            <class threadsafety="unspecified" name="QPrivateSignal" fullname="QObject::QPrivateSignal" href="qobject-qprivatesignal.html" status="active" access="private" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="119">
                <description path="" line="0" column="0"/>
            </class>
            <property threadsafety="unspecified" name="objectName" fullname="QObject::objectName" href="qobject.html#objectName-prop" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="120" type="QString" brief="The name of this object">
                <getter name="objectName"/>
                <setter name="setObjectName"/>
                <notifier name="objectNameChanged"/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="1149" column="4">
                    <brief>This property holds the name of this object.</brief>
                    <para>You can find an object by name (and type) using <link raw="findChild()" href="qobject.html#findChild" type="function">findChild()</link>. You can find a set of objects with <link raw="findChildren()" href="qobject.html#findChildren" type="function">findChildren()</link>.</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="5"/>
                    <para>By default, this property contains an empty string.</para>
                    <see-also>
                        <link raw="metaObject()" href="qobject.html#metaObject" type="function">metaObject()</link>
                        <link raw="QMetaObject::className()" href="qmetaobject.html#className" type="function">QMetaObject::className()</link>
                    </see-also>
                </description>
            </property>
            <function threadsafety="unspecified" name="d_func" fullname="QObject::d_func" href="qobject.html#d_func" status="active" access="private" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="121" virtual="non" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="QObjectPrivate *" signature="QObjectPrivate * d_func()">
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="d_func" fullname="QObject::d_func" href="qobject.html#d_func-1" status="active" access="private" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="121" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="const QObjectPrivate *" signature="const QObjectPrivate * d_func() const">
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="QObject" fullname="QObject::QObject" href="qobject.html#QObject" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="124" virtual="non" meta="constructor" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="" signature="QObject(QObject *parent)">
                <parameter type="QObject *" name="parent" default="nullptr"/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="786" column="4">
                    <para>Constructs an object with parent object <argument>parent</argument>.</para>
                    <para>The parent of an object may be viewed as the object's owner. For instance, a <link raw="QDialog" href="qdialog.html" type="class">dialog box</link> is the parent of the OK and Cancel buttons it contains.</para>
                    <para>The destructor of a parent object destroys all child objects.</para>
                    <para>Setting <argument>parent</argument> to 0 constructs an object with no parent. If the object is a widget, it will become a top-level window.</para>
                    <see-also>
                        <link raw="parent()" href="qobject.html#parent" type="function">parent()</link>
                        <link raw="findChild()" href="qobject.html#findChild" type="function">findChild()</link>
                        <link raw="findChildren()" href="qobject.html#findChildren" type="function">findChildren()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="~QObject" fullname="QObject::~QObject" href="qobject.html#dtor.QObject" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="125" virtual="virtual" meta="destructor" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="" signature="~QObject()">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="860" column="4">
                    <para>Destroys the object, deleting all its child objects.</para>
                    <para>All signals to and from the object are automatically disconnected, and any pending posted events for the object are removed from the event queue. However, it is often safer to use <link raw="deleteLater()" href="qobject.html#deleteLater" type="function">deleteLater()</link> rather than deleting a <link raw="QObject" href="qobject.html" type="class">QObject</link> subclass directly.</para>
                    <para>
                        <bold>Warning:</bold> All child objects are deleted. If any of these objects are on the stack or global, sooner or later your program will crash. We do not recommend holding pointers to child objects from outside the parent. If you still do, the <link raw="destroyed()" href="qobject.html#destroyed" type="function">destroyed()</link> signal gives you an opportunity to detect when an object is destroyed.</para>
                    <para>
                        <bold>Warning:</bold> Deleting a <link raw="QObject" href="qobject.html" type="class">QObject</link> while pending events are waiting to be delivered can cause a crash. You must not delete the <link raw="QObject" href="qobject.html" type="class">QObject</link> directly if it exists in a different thread than the one currently executing. Use <link raw="deleteLater()" href="qobject.html#deleteLater" type="function">deleteLater()</link> instead, which will cause the event loop to delete the object after all pending events have been delivered to it.</para>
                    <see-also>
                        <link raw="deleteLater()" href="qobject.html#deleteLater" type="function">deleteLater()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="event" fullname="QObject::event" href="qobject.html#event" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="127" virtual="virtual" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="bool" signature="bool event(QEvent *e)">
                <parameter type="QEvent *" name="e" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="1210" column="4">
                    <para>This virtual function receives events to an object and should return true if the event <argument>e</argument> was recognized and processed.</para>
                    <para>The  function can be reimplemented to customize the behavior of an object.</para>
                    <para>Make sure you call the parent event class implementation for all the events you did not handle.</para>
                    <para>Example:</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="52"/>
                    <see-also>
                        <link raw="installEventFilter()" href="qobject.html#installEventFilter" type="function">installEventFilter()</link>
                        <link raw="timerEvent()" href="qobject.html#timerEvent" type="function">timerEvent()</link>
                        <link raw="QCoreApplication::sendEvent()" href="qcoreapplication.html#sendEvent" type="function">QCoreApplication::sendEvent()</link>
                        <link raw="QCoreApplication::postEvent()" href="qcoreapplication.html#postEvent" type="function">QCoreApplication::postEvent()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="eventFilter" fullname="QObject::eventFilter" href="qobject.html#eventFilter" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="128" virtual="virtual" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="bool" signature="bool eventFilter(QObject *watched, QEvent *event)">
                <parameter type="QObject *" name="watched" default=""/>
                <parameter type="QEvent *" name="event" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="1352" column="4">
                    <para>Filters events if this object has been installed as an event filter for the <argument>watched</argument> object.</para>
                    <para>In your reimplementation of this function, if you want to filter the <argument>event</argument> out, i.e. stop it being handled further, return true; otherwise return false.</para>
                    <para>Example:</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="6"/>
                    <para>Notice in the example above that unhandled events are passed to the base class's  function, since the base class might have reimplemented  for its own internal purposes.</para>
                    <para>
                        <bold>Warning:</bold> If you delete the receiver object in this function, be sure to return true. Otherwise, Qt will forward the event to the deleted object and the program might crash.</para>
                    <see-also>
                        <link raw="installEventFilter()" href="qobject.html#installEventFilter" type="function">installEventFilter()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="objectName" fullname="QObject::objectName" href="qobject.html#objectName-prop" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="139" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" associated-property="objectName" type="QString" signature="QString objectName() const">
                <description path="" line="0" column="0">
                    <see-also>setObjectName()</see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="setObjectName" fullname="QObject::setObjectName" href="qobject.html#objectName-prop" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="140" virtual="non" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" associated-property="objectName" type="void" signature="void setObjectName(const QString &amp;name)">
                <parameter type="const QString &amp;" name="name" default=""/>
                <description path="" line="0" column="0">
                    <see-also>objectName()</see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="isWidgetType" fullname="QObject::isWidgetType" href="qobject.html#isWidgetType" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="142" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="bool" signature="bool isWidgetType() const">
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="isWindowType" fullname="QObject::isWindowType" href="qobject.html#isWindowType" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="143" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="bool" signature="bool isWindowType() const">
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="signalsBlocked" fullname="QObject::signalsBlocked" href="qobject.html#signalsBlocked" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="145" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="bool" signature="bool signalsBlocked() const">
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="blockSignals" fullname="QObject::blockSignals" href="qobject.html#blockSignals" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="146" virtual="non" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="bool" signature="bool blockSignals(bool block)">
                <parameter type="bool" name="block" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="1390" column="4">
                    <para>If <argument>block</argument> is true, signals emitted by this object are blocked (i.e., emitting a signal will not invoke anything connected to it). If <argument>block</argument> is false, no such blocking will occur.</para>
                    <para>The return value is the previous value of <link raw="signalsBlocked()" href="qobject.html#signalsBlocked" type="function">signalsBlocked()</link>.</para>
                    <para>Note that the <link raw="destroyed()" href="qobject.html#destroyed" type="function">destroyed()</link> signal will be emitted even if the signals for this object have been blocked.</para>
                    <para>Signals emitted while being blocked are not buffered.</para>
                    <see-also>
                        <link raw="signalsBlocked()" href="qobject.html#signalsBlocked" type="function">signalsBlocked()</link>
                        <link raw="QSignalBlocker" href="qsignalblocker.html" type="class">QSignalBlocker</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="thread" fullname="QObject::thread" href="qobject.html#thread" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="148" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="QThread *" signature="QThread * thread() const">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="1413" column="4">
                    <para>Returns the thread in which the object lives.</para>
                    <see-also>
                        <link raw="moveToThread()" href="qobject.html#moveToThread" type="function">moveToThread()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="moveToThread" fullname="QObject::moveToThread" href="qobject.html#moveToThread" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="149" virtual="non" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="void" signature="void moveToThread(QThread *targetThread)">
                <parameter type="QThread *" name="targetThread" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="1423" column="4">
                    <para>Changes the thread affinity for this object and its children. The object cannot be moved if it has a parent. Event processing will continue in the <argument>targetThread</argument>.</para>
                    <para>To move an object to the main thread, use <link raw="QApplication::instance()" href="qcoreapplication.html#instance" type="function">QApplication::instance()</link> to retrieve a pointer to the current application, and then use <link raw="QApplication::thread()" href="qobject.html#thread" type="function">QApplication::thread()</link> to retrieve the thread in which the application lives. For example:</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="7"/>
                    <para>If <argument>targetThread</argument> is zero, all event processing for this object and its children stops.</para>
                    <para>Note that all active timers for the object will be reset. The timers are first stopped in the current thread and restarted (with the same interval) in the <argument>targetThread</argument>. As a result, constantly moving an object between threads can postpone timer events indefinitely.</para>
                    <para>A <link raw="QEvent::ThreadChange" href="qevent.html#Type-enum" type="enum" enum="QEvent::Type">QEvent::ThreadChange</link> event is sent to this object just before the thread affinity is changed. You can handle this event to perform any special processing. Note that any new events that are posted to this object will be handled in the <argument>targetThread</argument>.</para>
                    <para>
                        <bold>Warning:</bold> This function is <italic>not</italic> thread-safe; the current thread must be same as the current thread affinity. In other words, this function can only &quot;push&quot; an object from the current thread to another thread, it cannot &quot;pull&quot; an object from any arbitrary thread to the current thread.</para>
                    <see-also>
                        <link raw="thread()" href="qobject.html#thread" type="function">thread()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="startTimer" fullname="QObject::startTimer" href="qobject.html#startTimer" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="151" virtual="non" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="int" signature="int startTimer(int interval, Qt::TimerType timerType)">
                <parameter type="int" name="interval" default=""/>
                <parameter type="Qt::TimerType" name="timerType" default="Qt::CoarseTimer"/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="1583" column="4">
                    <para>Starts a timer and returns a timer identifier, or returns zero if it could not start a timer.</para>
                    <para>A timer event will occur every <argument>interval</argument> milliseconds until <link raw="killTimer()" href="qobject.html#killTimer" type="function">killTimer()</link> is called. If <argument>interval</argument> is 0, then the timer event occurs once every time there are no more window system events to process.</para>
                    <para>The virtual <link raw="timerEvent()" href="qobject.html#timerEvent" type="function">timerEvent()</link> function is called with the <link raw="QTimerEvent" href="qtimerevent.html" type="class">QTimerEvent</link> event parameter class when a timer event occurs. Reimplement this function to get timer events.</para>
                    <para>If multiple timers are running, the <link raw="QTimerEvent::timerId()" href="qtimerevent.html#timerId" type="function">QTimerEvent::timerId()</link> can be used to find out which timer was activated.</para>
                    <para>Example:</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="8"/>
                    <para>Note that <link raw="QTimer" href="qtimer.html" type="class">QTimer</link>'s accuracy depends on the underlying operating system and hardware. The <argument>timerType</argument> argument allows you to customize the accuracy of the timer. See <link raw="Qt::TimerType" href="qt.html#TimerType-enum" type="enum" enum="Qt::TimerType">Qt::TimerType</link> for information on the different timer types. Most platforms support an accuracy of 20 milliseconds; some provide more. If Qt is unable to deliver the requested number of timer events, it will silently discard some.</para>
                    <para>The <link raw="QTimer" href="qtimer.html" type="class">QTimer</link> class provides a high-level programming interface with single-shot timers and timer signals instead of events. There is also a <link raw="QBasicTimer" href="qbasictimer.html" type="class">QBasicTimer</link> class that is more lightweight than <link raw="QTimer" href="qtimer.html" type="class">QTimer</link> and less clumsy than using timer IDs directly.</para>
                    <see-also>
                        <link raw="timerEvent()" href="qobject.html#timerEvent" type="function">timerEvent()</link>
                        <link raw="killTimer()" href="qobject.html#killTimer" type="function">killTimer()</link>
                        <link raw="QTimer::singleShot()" href="qtimer.html#singleShot" type="function">QTimer::singleShot()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="startTimer" fullname="QObject::startTimer" href="qobject.html#startTimer-1" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="154" virtual="non" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="int" signature="int startTimer(std::chrono::milliseconds time, Qt::TimerType timerType)">
                <parameter type="std::chrono::milliseconds" name="time" default=""/>
                <parameter type="Qt::TimerType" name="timerType" default="Qt::CoarseTimer"/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="killTimer" fullname="QObject::killTimer" href="qobject.html#killTimer" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="159" virtual="non" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="void" signature="void killTimer(int id)">
                <parameter type="int" name="id" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="1680" column="4">
                    <para>Kills the timer with timer identifier, <argument>id</argument>.</para>
                    <para>The timer identifier is returned by <link raw="startTimer()" href="qobject.html#startTimer" type="function">startTimer()</link> when a timer event is started.</para>
                    <see-also>
                        <link raw="timerEvent()" href="qobject.html#timerEvent" type="function">timerEvent()</link>
                        <link raw="startTimer()" href="qobject.html#startTimer" type="function">startTimer()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="findChild" fullname="QObject::findChild" href="qobject.html#findChild" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="162" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="T" signature="T findChild(const QString &amp;aName, Qt::FindChildOptions options) const">
                <parameter type="const QString &amp;" name="aName" default="QString()"/>
                <parameter type="Qt::FindChildOptions" name="options" default="Qt::FindChildrenRecursively"/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="findChildren" fullname="QObject::findChildren" href="qobject.html#findChildren" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="169" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="QList&lt;T&gt;" signature="QList&lt;T&gt; findChildren(const QString &amp;aName, Qt::FindChildOptions options) const">
                <parameter type="const QString &amp;" name="aName" default="QString()"/>
                <parameter type="Qt::FindChildOptions" name="options" default="Qt::FindChildrenRecursively"/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="findChildren" fullname="QObject::findChildren" href="qobject.html#findChildren-1" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="180" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="QList&lt;T&gt;" signature="QList&lt;T&gt; findChildren(const QRegExp &amp;re, Qt::FindChildOptions options) const">
                <parameter type="const QRegExp &amp;" name="re" default=""/>
                <parameter type="Qt::FindChildOptions" name="options" default="Qt::FindChildrenRecursively"/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="findChildren" fullname="QObject::findChildren" href="qobject.html#findChildren-2" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="192" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="QList&lt;T&gt;" signature="QList&lt;T&gt; findChildren(const QRegularExpression &amp;re, Qt::FindChildOptions options) const">
                <parameter type="const QRegularExpression &amp;" name="re" default=""/>
                <parameter type="Qt::FindChildOptions" name="options" default="Qt::FindChildrenRecursively"/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="children" fullname="QObject::children" href="qobject.html#children" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="202" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="const QObjectList &amp;" signature="const QObjectList &amp; children() const">
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="setParent" fullname="QObject::setParent" href="qobject.html#setParent" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="204" virtual="non" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="void" signature="void setParent(QObject *parent)">
                <parameter type="QObject *" name="parent" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="1975" column="4">
                    <para>Makes the object a child of <argument>parent</argument>.</para>
                    <see-also>
                        <link raw="parent()" href="qobject.html#parent" type="function">parent()</link>
                        <link raw="children()" href="qobject.html#children" type="function">children()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="installEventFilter" fullname="QObject::installEventFilter" href="qobject.html#installEventFilter" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="205" virtual="non" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="void" signature="void installEventFilter(QObject *filterObj)">
                <parameter type="QObject *" name="filterObj" default=""/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="removeEventFilter" fullname="QObject::removeEventFilter" href="qobject.html#removeEventFilter" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="206" virtual="non" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="void" signature="void removeEventFilter(QObject *obj)">
                <parameter type="QObject *" name="obj" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="2109" column="4">
                    <para>Removes an event filter object <argument>obj</argument> from this object. The request is ignored if such an event filter has not been installed.</para>
                    <para>All event filters for this object are automatically removed when this object is destroyed.</para>
                    <para>It is always safe to remove an event filter, even during event filter activation (i.e. from the <link raw="eventFilter()" href="qobject.html#eventFilter" type="function">eventFilter()</link> function).</para>
                    <see-also>
                        <link raw="installEventFilter()" href="qobject.html#installEventFilter" type="function">installEventFilter()</link>
                        <link raw="eventFilter()" href="qobject.html#eventFilter" type="function">eventFilter()</link>
                        <link raw="event()" href="qobject.html#event" type="function">event()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="thread safe" name="connect" fullname="QObject::connect" href="qobject.html#connect" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="208" virtual="non" meta="plain" const="false" static="true" overload="false" delete="false" default="false" final="false" override="false" type="QMetaObject::Connection" signature="QMetaObject::Connection connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)">
                <parameter type="const QObject *" name="sender" default=""/>
                <parameter type="const char *" name="signal" default=""/>
                <parameter type="const QObject *" name="receiver" default=""/>
                <parameter type="const char *" name="method" default=""/>
                <parameter type="Qt::ConnectionType" name="type" default="Qt::AutoConnection"/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="2593" column="4">
                    <para>Creates a connection of the given <argument>type</argument> from the <argument>signal</argument> in the <argument>sender</argument> object to the <argument>method</argument> in the <argument>receiver</argument> object. Returns a handle to the connection that can be used to disconnect it later.</para>
                    <para>You must use the <teletype type="highlighted">SIGNAL()</teletype> and <teletype type="highlighted">SLOT()</teletype> macros when specifying the <argument>signal</argument> and the <argument>method</argument>, for example:</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="22"/>
                    <para>This example ensures that the label always displays the current scroll bar value. Note that the signal and slots parameters must not contain any variable names, only the type. E.g. the following would not work and return false:</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="23"/>
                    <para>A signal can also be connected to another signal:</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="24"/>
                    <para>In this example, the <teletype type="highlighted">MyWidget</teletype> constructor relays a signal from a private member variable, and makes it available under a name that relates to <teletype type="highlighted">MyWidget</teletype>.</para>
                    <para>A signal can be connected to many slots and signals. Many signals can be connected to one slot.</para>
                    <para>If a signal is connected to several slots, the slots are activated in the same order in which the connections were made, when the signal is emitted.</para>
                    <para>The function returns a <link raw="QMetaObject::Connection" href="qmetaobject-connection.html" type="class">QMetaObject::Connection</link> that represents a handle to a connection if it successfully connects the signal to the slot. The connection handle will be invalid if it cannot create the connection, for example, if <link raw="QObject" href="qobject.html" type="class">QObject</link> is unable to verify the existence of either <argument>signal</argument> or <argument>method</argument>, or if their signatures aren't compatible. You can check if the handle is valid by casting it to a bool.</para>
                    <para>By default, a signal is emitted for every connection you make; two signals are emitted for duplicate connections. You can break all of these connections with a single <link raw="disconnect()" href="qobject.html#disconnect" type="function">disconnect()</link> call. If you pass the <link raw="Qt::UniqueConnection" href="qt.html#ConnectionType-enum" type="enum" enum="Qt::ConnectionType">Qt::UniqueConnection</link> <argument>type</argument>, the connection will only be made if it is not a duplicate. If there is already a duplicate (exact same signal to the exact same slot on the same objects), the connection will fail and connect will return an invalid <link raw="QMetaObject::Connection" href="qmetaobject-connection.html" type="class">QMetaObject::Connection</link>.</para>
                    <para>
                        <bold>Note:</bold> Qt::UniqueConnections do not work for lambdas, non-member functions and functors; they only apply to connecting to member functions.</para>
                    <para>The optional <argument>type</argument> parameter describes the type of connection to establish. In particular, it determines whether a particular signal is delivered to a slot immediately or queued for delivery at a later time. If the signal is queued, the parameters must be of types that are known to Qt's meta-object system, because Qt needs to copy the arguments to store them in an event behind the scenes. If you try to use a queued connection and get the error message</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="25"/>
                    <para>call <link raw="qRegisterMetaType()" href="qmetatype.html#qRegisterMetaType-1" type="function">qRegisterMetaType()</link> to register the data type before you establish the connection.</para>
                    <see-also>
                        <link raw="disconnect()" href="qobject.html#disconnect" type="function">disconnect()</link>
                        <link raw="sender()" href="qobject.html#sender" type="function">sender()</link>
                        <link raw="qRegisterMetaType()" href="qmetatype.html#qRegisterMetaType-1" type="function">qRegisterMetaType()</link>
                        <link raw="Q_DECLARE_METATYPE()" href="qmetatype.html#Q_DECLARE_METATYPE" type="function">Q_DECLARE_METATYPE()</link>
                        <link raw="Differences between String-Based and Functor-Based Connections" href="signalsandslots-syntaxes.html" type="page" page="Differences between String-Based and Functor-Based Connections">Differences between String-Based and Functor-Based Connections</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="connect" fullname="QObject::connect" href="qobject.html#connect-1" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="211" since="4.8" virtual="non" meta="plain" const="false" static="true" overload="false" delete="false" default="false" final="false" override="false" type="QMetaObject::Connection" signature="QMetaObject::Connection connect(const QObject *sender, const QMetaMethod &amp;signal, const QObject *receiver, const QMetaMethod &amp;method, Qt::ConnectionType type)">
                <parameter type="const QObject *" name="sender" default=""/>
                <parameter type="const QMetaMethod &amp;" name="signal" default=""/>
                <parameter type="const QObject *" name="receiver" default=""/>
                <parameter type="const QMetaMethod &amp;" name="method" default=""/>
                <parameter type="Qt::ConnectionType" name="type" default="Qt::AutoConnection"/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="2782" column="4">
                    <para>Creates a connection of the given <argument>type</argument> from the <argument>signal</argument> in the <argument>sender</argument> object to the <argument>method</argument> in the <argument>receiver</argument> object. Returns a handle to the connection that can be used to disconnect it later.</para>
                    <para>The Connection handle will be invalid if it cannot create the connection, for example, the parameters were invalid. You can check if the <link raw="QMetaObject::Connection" href="qmetaobject-connection.html" type="class">QMetaObject::Connection</link> is valid by casting it to a bool.</para>
                    <para>This function works in the same way as <teletype type="highlighted">connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)</teletype> but it uses <link raw="QMetaMethod" href="qmetamethod.html" type="class">QMetaMethod</link> to specify signal and method.</para>
                    <see-also>
                        <link raw="connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)" href="qobject.html#connect" type="function">connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="connect" fullname="QObject::connect" href="qobject.html#connect-2" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="215" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="QMetaObject::Connection" signature="QMetaObject::Connection connect(const QObject *sender, const char *signal, const char *member, Qt::ConnectionType type) const">
                <parameter type="const QObject *" name="sender" default=""/>
                <parameter type="const char *" name="signal" default=""/>
                <parameter type="const char *" name="member" default=""/>
                <parameter type="Qt::ConnectionType" name="type" default="Qt::AutoConnection"/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="connect" fullname="QObject::connect" href="qobject.html#connect-3" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="220" virtual="non" meta="plain" const="false" static="true" overload="false" delete="false" default="false" final="false" override="false" type="QMetaObject::Connection" signature="QMetaObject::Connection connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type)">
                <parameter type="const QObject *" name="sender" default=""/>
                <parameter type="PointerToMemberFunction" name="signal" default=""/>
                <parameter type="const QObject *" name="receiver" default=""/>
                <parameter type="PointerToMemberFunction" name="method" default=""/>
                <parameter type="Qt::ConnectionType" name="type" default="Qt::AutoConnection"/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="connect" fullname="QObject::connect" href="qobject.html#connect-4" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="222" virtual="non" meta="plain" const="false" static="true" overload="false" delete="false" default="false" final="false" override="false" type="QMetaObject::Connection" signature="QMetaObject::Connection connect(const QObject *sender, PointerToMemberFunction signal, Functor functor)">
                <parameter type="const QObject *" name="sender" default=""/>
                <parameter type="PointerToMemberFunction" name="signal" default=""/>
                <parameter type="Functor" name="functor" default=""/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="connect" fullname="QObject::connect" href="qobject.html#connect-5" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="224" virtual="non" meta="plain" const="false" static="true" overload="false" delete="false" default="false" final="false" override="false" type="QMetaObject::Connection" signature="QMetaObject::Connection connect(const QObject *sender, PointerToMemberFunction signal, const QObject *context, Functor functor, Qt::ConnectionType type)">
                <parameter type="const QObject *" name="sender" default=""/>
                <parameter type="PointerToMemberFunction" name="signal" default=""/>
                <parameter type="const QObject *" name="context" default=""/>
                <parameter type="Functor" name="functor" default=""/>
                <parameter type="Qt::ConnectionType" name="type" default="Qt::AutoConnection"/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="thread safe" name="disconnect" fullname="QObject::disconnect" href="qobject.html#disconnect" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="337" virtual="non" meta="plain" const="false" static="true" overload="false" delete="false" default="false" final="false" override="false" type="bool" signature="bool disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)">
                <parameter type="const QObject *" name="sender" default=""/>
                <parameter type="const char *" name="signal" default=""/>
                <parameter type="const QObject *" name="receiver" default=""/>
                <parameter type="const char *" name="method" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="2876" column="4">
                    <para>Disconnects <argument>signal</argument> in object <argument>sender</argument> from <argument>method</argument> in object <argument>receiver</argument>. Returns <teletype type="highlighted">true</teletype> if the connection is successfully broken; otherwise returns <teletype type="highlighted">false</teletype>.</para>
                    <para>A signal-slot connection is removed when either of the objects involved are destroyed.</para>
                    <para> is typically used in three ways, as the following examples demonstrate.</para>
                    <list type="ordered" start="1">
                        <item>
                            <para>Disconnect everything connected to an object's signals:</para>
                            <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="26"/>
                            <para>equivalent to the non-static overloaded function</para>
                            <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="27"/>
                        </item>
                        <item>
                            <para>Disconnect everything connected to a specific signal:</para>
                            <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="28"/>
                            <para>equivalent to the non-static overloaded function</para>
                            <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="29"/>
                        </item>
                        <item>
                            <para>Disconnect a specific receiver:</para>
                            <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="30"/>
                            <para>equivalent to the non-static overloaded function</para>
                            <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="31"/>
                        </item>
                    </list>
                    <para>0 may be used as a wildcard, meaning &quot;any signal&quot;, &quot;any receiving object&quot;, or &quot;any slot in the receiving object&quot;, respectively.</para>
                    <para>The <argument>sender</argument> may never be 0. (You cannot disconnect signals from more than one object in a single call.)</para>
                    <para>If <argument>signal</argument> is 0, it disconnects <argument>receiver</argument> and <argument>method</argument> from any signal. If not, only the specified signal is disconnected.</para>
                    <para>If <argument>receiver</argument> is 0, it disconnects anything connected to <argument>signal</argument>. If not, slots in objects other than <argument>receiver</argument> are not disconnected.</para>
                    <para>If <argument>method</argument> is 0, it disconnects anything that is connected to <argument>receiver</argument>. If not, only slots named <argument>method</argument> will be disconnected, and all other slots are left alone. The <argument>method</argument> must be 0 if <argument>receiver</argument> is left out, so you cannot disconnect a specifically-named slot on all objects.</para>
                    <see-also>
                        <link raw="connect()" href="qobject.html#connect" type="function">connect()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="disconnect" fullname="QObject::disconnect" href="qobject.html#disconnect-1" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="339" since="4.8" virtual="non" meta="plain" const="false" static="true" overload="false" delete="false" default="false" final="false" override="false" type="bool" signature="bool disconnect(const QObject *sender, const QMetaMethod &amp;signal, const QObject *receiver, const QMetaMethod &amp;method)">
                <parameter type="const QObject *" name="sender" default=""/>
                <parameter type="const QMetaMethod &amp;" name="signal" default=""/>
                <parameter type="const QObject *" name="receiver" default=""/>
                <parameter type="const QMetaMethod &amp;" name="method" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="3042" column="4">
                    <para>Disconnects <argument>signal</argument> in object <argument>sender</argument> from <argument>method</argument> in object <argument>receiver</argument>. Returns <teletype type="highlighted">true</teletype> if the connection is successfully broken; otherwise returns <teletype type="highlighted">false</teletype>.</para>
                    <para>This function provides the same possibilities like <teletype type="highlighted">disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)</teletype> but uses <link raw="QMetaMethod" href="qmetamethod.html" type="class">QMetaMethod</link> to represent the signal and the method to be disconnected.</para>
                    <para>Additionally this function returnsfalse and no signals and slots disconnected if:</para>
                    <list type="ordered" start="1">
                        <item>
                            <para>
                                <argument>signal</argument> is not a member of sender class or one of its parent classes.</para>
                        </item>
                        <item>
                            <para>
                                <argument>method</argument> is not a member of receiver class or one of its parent classes.</para>
                        </item>
                        <item>
                            <para>
                                <argument>signal</argument> instance represents not a signal.</para>
                        </item>
                    </list>
                    <para>QMetaMethod() may be used as wildcard in the meaning &quot;any signal&quot; or &quot;any slot in receiving object&quot;. In the same way 0 can be used for <argument>receiver</argument> in the meaning &quot;any receiving object&quot;. In this case method should also be QMetaMethod(). <argument>sender</argument> parameter should be never 0.</para>
                    <see-also>
                        <link raw="disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)" href="qobject.html#disconnect" type="function">disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="disconnect" fullname="QObject::disconnect" href="qobject.html#disconnect-2" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="341" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="bool" signature="bool disconnect(const char *signal, const QObject *receiver, const char *member) const">
                <parameter type="const char *" name="signal" default="nullptr"/>
                <parameter type="const QObject *" name="receiver" default="nullptr"/>
                <parameter type="const char *" name="member" default="nullptr"/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="disconnect" fullname="QObject::disconnect" href="qobject.html#disconnect-3" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="344" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="bool" signature="bool disconnect(const QObject *receiver, const char *member) const">
                <parameter type="const QObject *" name="receiver" default=""/>
                <parameter type="const char *" name="member" default="nullptr"/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="disconnect" fullname="QObject::disconnect" href="qobject.html#disconnect-4" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="346" virtual="non" meta="plain" const="false" static="true" overload="false" delete="false" default="false" final="false" override="false" type="bool" signature="bool disconnect(const QMetaObject::Connection &amp;connection)">
                <parameter type="const QMetaObject::Connection &amp;" name="connection" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4858" column="4">
                    <para>Disconnect a connection.</para>
                    <para>If the <argument>connection</argument> is invalid or has already been disconnected, do nothing and return false.</para>
                    <see-also>
                        <link raw="connect()" href="qobject.html#connect" type="function">connect()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="disconnect" fullname="QObject::disconnect" href="qobject.html#disconnect-5" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="350" virtual="non" meta="plain" const="false" static="true" overload="false" delete="false" default="false" final="false" override="false" type="bool" signature="bool disconnect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method)">
                <parameter type="const QObject *" name="sender" default=""/>
                <parameter type="PointerToMemberFunction" name="signal" default=""/>
                <parameter type="const QObject *" name="receiver" default=""/>
                <parameter type="PointerToMemberFunction" name="method" default=""/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="dumpObjectTree" fullname="QObject::dumpObjectTree" href="qobject-obsolete.html#dumpObjectTree-1" status="obsolete" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="385" virtual="non" meta="plain" const="false" static="false" overload="true" delete="false" default="false" final="false" override="false" overload-number="1" type="void" signature="void dumpObjectTree()">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4007" column="4">
                    <para>This is an overloaded function.</para>
                    <para>Dumps a tree of children to the debug output.</para>
                    <see-also>
                        <link raw="dumpObjectInfo()" href="qobject.html#dumpObjectInfo" type="function">dumpObjectInfo()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="dumpObjectInfo" fullname="QObject::dumpObjectInfo" href="qobject-obsolete.html#dumpObjectInfo-1" status="obsolete" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="386" virtual="non" meta="plain" const="false" static="false" overload="true" delete="false" default="false" final="false" override="false" overload-number="1" type="void" signature="void dumpObjectInfo()">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4034" column="4">
                    <para>This is an overloaded function.</para>
                    <para>Dumps information about signal connections, etc. for this object to the debug output.</para>
                    <see-also>
                        <link raw="dumpObjectTree()" href="qobject.html#dumpObjectTree" type="function">dumpObjectTree()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="dumpObjectTree" fullname="QObject::dumpObjectTree" href="qobject.html#dumpObjectTree" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="388" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="void" signature="void dumpObjectTree() const">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4021" column="4">
                    <para>Dumps a tree of children to the debug output.</para>
                    <para>
                        <bold>Note:</bold> before Qt 5.9, this function was not const.</para>
                    <see-also>
                        <link raw="dumpObjectInfo()" href="qobject.html#dumpObjectInfo" type="function">dumpObjectInfo()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="dumpObjectInfo" fullname="QObject::dumpObjectInfo" href="qobject.html#dumpObjectInfo" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="389" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="void" signature="void dumpObjectInfo() const">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4049" column="4">
                    <para>Dumps information about signal connections, etc. for this object to the debug output.</para>
                    <para>
                        <bold>Note:</bold> before Qt 5.9, this function was not const.</para>
                    <see-also>
                        <link raw="dumpObjectTree()" href="qobject.html#dumpObjectTree" type="function">dumpObjectTree()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="setProperty" fullname="QObject::setProperty" href="qobject.html#setProperty" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="392" virtual="non" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="bool" signature="bool setProperty(const char *name, const QVariant &amp;value)">
                <parameter type="const char *" name="name" default=""/>
                <parameter type="const QVariant &amp;" name="value" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="3856" column="4">
                    <para>Sets the value of the object's <argument>name</argument> property to <argument>value</argument>.</para>
                    <para>If the property is defined in the class using <link raw="Q_PROPERTY" href="qobject.html#Q_PROPERTY" type="function">Q_PROPERTY</link> then true is returned on success and false otherwise. If the property is not defined using <link raw="Q_PROPERTY" href="qobject.html#Q_PROPERTY" type="function">Q_PROPERTY</link>, and therefore not listed in the meta-object, it is added as a dynamic property and false is returned.</para>
                    <para>Information about all available properties is provided through the <link raw="metaObject()" href="qobject.html#metaObject" type="function">metaObject()</link> and <link raw="dynamicPropertyNames()" href="qobject.html#dynamicPropertyNames" type="function">dynamicPropertyNames()</link>.</para>
                    <para>Dynamic properties can be queried again using <link raw="property()" href="qobject.html#property" type="function">property()</link> and can be removed by setting the property value to an invalid <link raw="QVariant" href="qvariant.html" type="class">QVariant</link>. Changing the value of a dynamic property causes a <link raw="QDynamicPropertyChangeEvent" href="qdynamicpropertychangeevent.html" type="class">QDynamicPropertyChangeEvent</link> to be sent to the object.</para>
                    <para>
                        <bold>Note:</bold> Dynamic properties starting with &quot;_q_&quot; are reserved for internal purposes.</para>
                    <see-also>
                        <link raw="property()" href="qobject.html#property" type="function">property()</link>
                        <link raw="metaObject()" href="qobject.html#metaObject" type="function">metaObject()</link>
                        <link raw="dynamicPropertyNames()" href="qobject.html#dynamicPropertyNames" type="function">dynamicPropertyNames()</link>
                        <link raw="QMetaProperty::write()" href="qmetaproperty.html#write" type="function">QMetaProperty::write()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="property" fullname="QObject::property" href="qobject.html#property" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="393" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="QVariant" signature="QVariant property(const char *name) const">
                <parameter type="const char *" name="name" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="3921" column="4">
                    <para>Returns the value of the object's <argument>name</argument> property.</para>
                    <para>If no such property exists, the returned variant is invalid.</para>
                    <para>Information about all available properties is provided through the <link raw="metaObject()" href="qobject.html#metaObject" type="function">metaObject()</link> and <link raw="dynamicPropertyNames()" href="qobject.html#dynamicPropertyNames" type="function">dynamicPropertyNames()</link>.</para>
                    <see-also>
                        <link raw="setProperty()" href="qobject.html#setProperty" type="function">setProperty()</link>
                        <link raw="QVariant::isValid()" href="qvariant.html#isValid" type="function">QVariant::isValid()</link>
                        <link raw="metaObject()" href="qobject.html#metaObject" type="function">metaObject()</link>
                        <link raw="dynamicPropertyNames()" href="qobject.html#dynamicPropertyNames" type="function">dynamicPropertyNames()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="dynamicPropertyNames" fullname="QObject::dynamicPropertyNames" href="qobject.html#dynamicPropertyNames" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="394" since="4.2" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="QList&lt;QByteArray&gt;" signature="QList&lt;QByteArray&gt; dynamicPropertyNames() const">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="3954" column="4">
                    <para>Returns the names of all properties that were dynamically added to the object using <link raw="setProperty()" href="qobject.html#setProperty" type="function">setProperty()</link>.</para>
                </description>
            </function>
            <function threadsafety="unspecified" name="registerUserData" fullname="QObject::registerUserData" href="qobject.html#registerUserData" status="internal" access="private" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="398" virtual="non" meta="plain" const="false" static="true" overload="false" delete="false" default="false" final="false" override="false" type="uint" signature="uint registerUserData()">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4122" column="4"/>
            </function>
            <function threadsafety="unspecified" name="setUserData" fullname="QObject::setUserData" href="qobject.html#setUserData" status="internal" access="private" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="399" virtual="non" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="void" signature="void setUserData(uint id, QObjectUserData *data)">
                <parameter type="uint" name="id" default=""/>
                <parameter type="QObjectUserData *" name="data" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4138" column="4"/>
            </function>
            <function threadsafety="unspecified" name="userData" fullname="QObject::userData" href="qobject.html#userData" status="internal" access="private" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="400" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="QObjectUserData *" signature="QObjectUserData * userData(uint id) const">
                <parameter type="uint" name="id" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4152" column="4"/>
            </function>
            <function threadsafety="unspecified" name="destroyed" fullname="QObject::destroyed" href="qobject.html#destroyed" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="404" virtual="non" meta="signal" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="void" signature="void destroyed(QObject *)">
                <parameter type="QObject *" name="" default="nullptr"/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="objectNameChanged" fullname="QObject::objectNameChanged" href="qobject.html#objectName-prop" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="405" virtual="non" meta="signal" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" associated-property="objectName" type="void" signature="void objectNameChanged(const QString &amp;objectName)">
                <parameter type="const QString &amp;" name="objectName" default=""/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="parent" fullname="QObject::parent" href="qobject.html#parent" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="408" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="QObject *" signature="QObject * parent() const">
                <description path="" line="0" column="0">
                    <see-also>
                        <link raw="setParent()" href="qobject.html#setParent" type="function">setParent()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="inherits" fullname="QObject::inherits" href="qobject.html#inherits" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="410" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="bool" signature="bool inherits(const char *classname) const">
                <parameter type="const char *" name="classname" default=""/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="deleteLater" fullname="QObject::deleteLater" href="qobject.html#deleteLater" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="414" virtual="non" meta="slot" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="void" signature="void deleteLater()">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="2146" column="4">
                    <para>Schedules this object for deletion.</para>
                    <para>The object will be deleted when control returns to the event loop. If the event loop is not running when this function is called (e.g.  is called on an object before <link raw="QCoreApplication::exec()" href="qcoreapplication.html#exec" type="function">QCoreApplication::exec()</link>), the object will be deleted once the event loop is started. If  is called after the main event loop has stopped, the object will not be deleted. Since Qt 4.8, if  is called on an object that lives in a thread with no running event loop, the object will be destroyed when the thread finishes.</para>
                    <para>Note that entering and leaving a new event loop (e.g., by opening a modal dialog) will <italic>not</italic> perform the deferred deletion; for the object to be deleted, the control must return to the event loop from which  was called.</para>
                    <para>
                        <bold>Note:</bold> It is safe to call this function more than once; when the first deferred deletion event is delivered, any pending events for the object are removed from the event queue.</para>
                    <see-also>
                        <link raw="destroyed()" href="qobject.html#destroyed" type="function">destroyed()</link>
                        <link raw="QPointer" href="qpointer.html" type="class">QPointer</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="sender" fullname="QObject::sender" href="qobject.html#sender" status="active" access="protected" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="417" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="QObject *" signature="QObject * sender() const">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="2328" column="4">
                    <para>Returns a pointer to the object that sent the signal, if called in a slot activated by a signal; otherwise it returns 0. The pointer is valid only during the execution of the slot that calls this function from this object's thread context.</para>
                    <para>The pointer returned by this function becomes invalid if the sender is destroyed, or if the slot is disconnected from the sender's signal.</para>
                    <para>
                        <bold>Warning:</bold> This function violates the object-oriented principle of modularity. However, getting access to the sender might be useful when many signals are connected to a single slot.</para>
                    <para>
                        <bold>Warning:</bold> As mentioned above, the return value of this function is not valid when the slot is called via a <link raw="Qt::DirectConnection" href="qt.html#ConnectionType-enum" type="enum" enum="Qt::ConnectionType">Qt::DirectConnection</link> from a thread different from this object's thread. Do not use this function in this type of scenario.</para>
                    <see-also>
                        <link raw="senderSignalIndex()" href="qobject.html#senderSignalIndex" type="function">senderSignalIndex()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="senderSignalIndex" fullname="QObject::senderSignalIndex" href="qobject.html#senderSignalIndex" status="active" access="protected" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="418" since="4.8" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="int" signature="int senderSignalIndex() const">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="2366" column="4">
                    <para>Returns the meta-method index of the signal that called the currently executing slot, which is a member of the class returned by <link raw="sender()" href="qobject.html#sender" type="function">sender()</link>. If called outside of a slot activated by a signal, -1 is returned.</para>
                    <para>For signals with default parameters, this function will always return the index with all parameters, regardless of which was used with <link raw="connect()" href="qobject.html#connect" type="function">connect()</link>. For example, the signal <teletype type="highlighted">destroyed(QObject *obj = 0)</teletype> will have two different indexes (with and without the parameter), but this function will always return the index with a parameter. This does not apply when overloading signals with different parameters.</para>
                    <para>
                        <bold>Warning:</bold> This function violates the object-oriented principle of modularity. However, getting access to the signal index might be useful when many signals are connected to a single slot.</para>
                    <para>
                        <bold>Warning:</bold> The return value of this function is not valid when the slot is called via a <link raw="Qt::DirectConnection" href="qt.html#ConnectionType-enum" type="enum" enum="Qt::ConnectionType">Qt::DirectConnection</link> from a thread different from this object's thread. Do not use this function in this type of scenario.</para>
                    <see-also>
                        <link raw="sender()" href="qobject.html#sender" type="function">sender()</link>
                        <link raw="QMetaObject::indexOfSignal()" href="qmetaobject.html#indexOfSignal" type="function">QMetaObject::indexOfSignal()</link>
                        <link raw="QMetaObject::method()" href="qmetaobject.html#method" type="function">QMetaObject::method()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="receivers" fullname="QObject::receivers" href="qobject.html#receivers" status="active" access="protected" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="419" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="int" signature="int receivers(const char *signal) const">
                <parameter type="const char *" name="signal" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="2409" column="4">
                    <para>Returns the number of receivers connected to the <argument>signal</argument>.</para>
                    <para>Since both slots and signals can be used as receivers for signals, and the same connections can be made many times, the number of receivers is the same as the number of connections made from this signal.</para>
                    <para>When calling this function, you can use the <teletype type="highlighted">SIGNAL()</teletype> macro to pass a specific signal:</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="21"/>
                    <para>
                        <bold>Warning:</bold> This function violates the object-oriented principle of modularity. However, it might be useful when you need to perform expensive initialization only if something is connected to a signal.</para>
                    <see-also>
                        <link raw="isSignalConnected()" href="qobject.html#isSignalConnected" type="function">isSignalConnected()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="isSignalConnected" fullname="QObject::isSignalConnected" href="qobject.html#isSignalConnected" status="active" access="protected" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="420" since="5.0" virtual="non" meta="plain" const="true" static="false" overload="false" delete="false" default="false" final="false" override="false" type="bool" signature="bool isSignalConnected(const QMetaMethod &amp;signal) const">
                <parameter type="const QMetaMethod &amp;" name="signal" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="2473" column="4">
                    <para>Returns <teletype type="highlighted">true</teletype> if the <argument>signal</argument> is connected to at least one receiver, otherwise returns <teletype type="highlighted">false</teletype>.</para>
                    <para>
                        <argument>signal</argument> must be a signal member of this object, otherwise the behaviour is undefined.</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="49"/>
                    <para>As the code snippet above illustrates, you can use this function to avoid emitting a signal that nobody listens to.</para>
                    <para>
                        <bold>Warning:</bold> This function violates the object-oriented principle of modularity. However, it might be useful when you need to perform expensive initialization only if something is connected to a signal.</para>
                </description>
            </function>
            <function threadsafety="unspecified" name="timerEvent" fullname="QObject::timerEvent" href="qobject.html#timerEvent" status="active" access="protected" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="422" virtual="virtual" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="void" signature="void timerEvent(QTimerEvent *event)">
                <parameter type="QTimerEvent *" name="event" default=""/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="childEvent" fullname="QObject::childEvent" href="qobject.html#childEvent" status="active" access="protected" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="423" virtual="virtual" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="void" signature="void childEvent(QChildEvent *event)">
                <parameter type="QChildEvent *" name="event" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="1299" column="4">
                    <para>This event handler can be reimplemented in a subclass to receive child events. The event is passed in the <argument>event</argument> parameter.</para>
                    <para>
                        <link raw="QEvent::ChildAdded" href="qevent.html#Type-enum" type="enum" enum="QEvent::Type">QEvent::ChildAdded</link> and <link raw="QEvent::ChildRemoved" href="qevent.html#Type-enum" type="enum" enum="QEvent::Type">QEvent::ChildRemoved</link> events are sent to objects when children are added or removed. In both cases you can only rely on the child being a <link raw="QObject" href="qobject.html" type="class">QObject</link>, or if <link raw="isWidgetType()" href="qobject.html#isWidgetType" type="function">isWidgetType()</link> returns <teletype type="highlighted">true</teletype>, a <link raw="QWidget" href="qwidget.html" type="class">QWidget</link>. (This is because, in the <link raw="QEvent::ChildAdded" href="qevent.html#Type-enum" type="enum" enum="QEvent::Type">ChildAdded</link> case, the child is not yet fully constructed, and in the <link raw="QEvent::ChildRemoved" href="qevent.html#Type-enum" type="enum" enum="QEvent::Type">ChildRemoved</link> case it might have been destructed already).</para>
                    <para>
                        <link raw="QEvent::ChildPolished" href="qevent.html#Type-enum" type="enum" enum="QEvent::Type">QEvent::ChildPolished</link> events are sent to widgets when children are polished, or when polished children are added. If you receive a child polished event, the child's construction is usually completed. However, this is not guaranteed, and multiple polish events may be delivered during the execution of a widget's constructor.</para>
                    <para>For every child widget, you receive one <link raw="QEvent::ChildAdded" href="qevent.html#Type-enum" type="enum" enum="QEvent::Type">ChildAdded</link> event, zero or more <link raw="QEvent::ChildPolished" href="qevent.html#Type-enum" type="enum" enum="QEvent::Type">ChildPolished</link> events, and one <link raw="QEvent::ChildRemoved" href="qevent.html#Type-enum" type="enum" enum="QEvent::Type">ChildRemoved</link> event.</para>
                    <para>The <link raw="QEvent::ChildPolished" href="qevent.html#Type-enum" type="enum" enum="QEvent::Type">ChildPolished</link> event is omitted if a child is removed immediately after it is added. If a child is polished several times during construction and destruction, you may receive several child polished events for the same child, each time with a different virtual table.</para>
                    <see-also>
                        <link raw="event()" href="qobject.html#event" type="function">event()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="customEvent" fullname="QObject::customEvent" href="qobject.html#customEvent" status="active" access="protected" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="424" virtual="virtual" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="void" signature="void customEvent(QEvent *event)">
                <parameter type="QEvent *" name="event" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="1337" column="4">
                    <para>This event handler can be reimplemented in a subclass to receive custom events. Custom events are user-defined events with a type value at least as large as the <link raw="QEvent::User" href="qevent.html#Type-enum" type="enum" enum="QEvent::Type">QEvent::User</link> item of the <link raw="QEvent::Type" href="qevent.html#Type-enum" type="enum" enum="QEvent::Type">QEvent::Type</link> enum, and is typically a <link raw="QEvent" href="qevent.html" type="class">QEvent</link> subclass. The event is passed in the <argument>event</argument> parameter.</para>
                    <see-also>
                        <link raw="event()" href="qobject.html#event" type="function">event()</link>
                        <link raw="QEvent" href="qevent.html" type="class">QEvent</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="connectNotify" fullname="QObject::connectNotify" href="qobject.html#connectNotify" status="active" access="protected" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="426" since="5.0" virtual="virtual" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="void" signature="void connectNotify(const QMetaMethod &amp;signal)">
                <parameter type="const QMetaMethod &amp;" name="signal" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="3160" column="4">
                    <para>This virtual function is called when something has been connected to <argument>signal</argument> in this object.</para>
                    <para>If you want to compare <argument>signal</argument> with a specific signal, you can use <link raw="QMetaMethod::fromSignal()" href="qmetamethod.html#fromSignal" type="function">QMetaMethod::fromSignal()</link> as follows:</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="32"/>
                    <para>
                        <bold>Warning:</bold> This function violates the object-oriented principle of modularity. However, it might be useful when you need to perform expensive initialization only if something is connected to a signal.</para>
                    <para>
                        <bold>Warning:</bold> This function is called from the thread which performs the connection, which may be a different thread from the thread in which this object lives.</para>
                    <see-also>
                        <link raw="connect()" href="qobject.html#connect" type="function">connect()</link>
                        <link raw="disconnectNotify()" href="qobject.html#disconnectNotify" type="function">disconnectNotify()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="disconnectNotify" fullname="QObject::disconnectNotify" href="qobject.html#disconnectNotify" status="active" access="protected" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="427" since="5.0" virtual="virtual" meta="plain" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="void" signature="void disconnectNotify(const QMetaMethod &amp;signal)">
                <parameter type="const QMetaMethod &amp;" name="signal" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="3188" column="4">
                    <para>This virtual function is called when something has been disconnected from <argument>signal</argument> in this object.</para>
                    <para>See <link raw="connectNotify()" href="qobject.html#connectNotify" type="function">connectNotify()</link> for an example of how to compare <argument>signal</argument> with a specific signal.</para>
                    <para>If all signals were disconnected from this object (e.g., the signal argument to <link raw="disconnect()" href="qobject.html#disconnect" type="function">disconnect()</link> was 0),  is only called once, and the <argument>signal</argument> will be an invalid <link raw="QMetaMethod" href="qmetamethod.html" type="class">QMetaMethod</link> (<link raw="QMetaMethod::isValid()" href="qmetamethod.html#isValid" type="function">QMetaMethod::isValid()</link> returns <teletype type="highlighted">false</teletype>).</para>
                    <para>
                        <bold>Warning:</bold> This function violates the object-oriented principle of modularity. However, it might be useful for optimizing access to expensive resources.</para>
                    <para>
                        <bold>Warning:</bold> This function is called from the thread which performs the disconnection, which may be a different thread from the thread in which this object lives. This function may also be called with a <link raw="QObject" href="qobject.html" type="class">QObject</link> internal mutex locked. It is therefore not allowed to re-enter any of any <link raw="QObject" href="qobject.html" type="class">QObject</link> functions from your reimplementation and if you lock a mutex in your reimplementation, make sure that you don't call <link raw="QObject" href="qobject.html" type="class">QObject</link> functions with that mutex held in other places or it will result in a deadlock.</para>
                    <see-also>
                        <link raw="disconnect()" href="qobject.html#disconnect" type="function">disconnect()</link>
                        <link raw="connectNotify()" href="qobject.html#connectNotify" type="function">connectNotify()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="QObject" fullname="QObject::QObject" href="qobject.html#QObject-1" status="internal" access="private" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="430" virtual="non" meta="constructor" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="" signature="QObject(QObjectPrivate &amp;dd, QObject *parent)">
                <parameter type="QObjectPrivate &amp;" name="dd" default=""/>
                <parameter type="QObject *" name="parent" default="nullptr"/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="825" column="4"/>
            </function>
            <variable threadsafety="unspecified" name="d_ptr" fullname="QObject::d_ptr" href="qobject.html#d_ptr-var" status="active" access="protected" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="433" type="QScopedPointer&lt;QObjectData&gt;" static="false">
                <description path="" line="0" column="0"/>
            </variable>
            <variable threadsafety="unspecified" name="staticQtMetaObject" fullname="QObject::staticQtMetaObject" href="qobject.html#staticQtMetaObject-var" status="active" access="protected" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="435" type="const QMetaObject" static="true">
                <description path="" line="0" column="0"/>
            </variable>
            <function threadsafety="unspecified" name="QObject" fullname="QObject::QObject" href="qobject.html#QObject-2" status="active" access="private" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="449" virtual="non" meta="constructor" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="" signature="QObject(const QObject &amp;)">
                <parameter type="const QObject &amp;" name="" default=""/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="operator=" fullname="QObject::operator=" href="qobject.html#operator-eq" status="active" access="private" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="449" virtual="non" meta="copy-assign" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" type="QObject &amp;" signature="QObject &amp; operator=(const QObject &amp;)">
                <parameter type="const QObject &amp;" name="" default=""/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="connectImpl" fullname="QObject::connectImpl" href="qobject.html#connectImpl" status="internal" access="private" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="453" virtual="non" meta="plain" const="false" static="true" overload="false" delete="false" default="false" final="false" override="false" type="QMetaObject::Connection" signature="QMetaObject::Connection connectImpl(const QObject *sender, void **signal, const QObject *receiver, void **slot, QtPrivate::QSlotObjectBase *slotObj, Qt::ConnectionType type, const int *types, const QMetaObject *senderMetaObject)">
                <parameter type="const QObject *" name="sender" default=""/>
                <parameter type="void **" name="signal" default=""/>
                <parameter type="const QObject *" name="receiver" default=""/>
                <parameter type="void **" name="slot" default=""/>
                <parameter type="QtPrivate::QSlotObjectBase *" name="slotObj" default=""/>
                <parameter type="Qt::ConnectionType" name="type" default=""/>
                <parameter type="const int *" name="types" default=""/>
                <parameter type="const QMetaObject *" name="senderMetaObject" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4745" column="4">
                    <para>Implementation of the template version of connect</para>
                    <para>
                        <argument>sender</argument> is the sender object <argument>signal</argument> is a pointer to a pointer to a member signal of the sender <argument>receiver</argument> is the receiver object, may not be null, will be equal to sender when connecting to a static function or a functor <argument>slot</argument> a pointer only used when using <link raw="Qt::UniqueConnection" href="qt.html#ConnectionType-enum" type="enum" enum="Qt::ConnectionType">Qt::UniqueConnection</link> <argument>type</argument> the Qt::ConnctionType passed as argument to connect <argument>types</argument> an array of integer with the metatype id of the parameter of the signal to be used with queued connection must stay valid at least for the whole time of the connection, this function do not take ownership. typically static data. If null, then the types will be computed when the signal is emit in a queued connection from the types from the signature. <argument>senderMetaObject</argument> is the metaobject used to lookup the signal, the signal must be in this metaobject</para>
                </description>
            </function>
            <function threadsafety="unspecified" name="disconnectImpl" fullname="QObject::disconnectImpl" href="qobject.html#disconnectImpl" status="active" access="private" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="458" virtual="non" meta="plain" const="false" static="true" overload="false" delete="false" default="false" final="false" override="false" type="bool" signature="bool disconnectImpl(const QObject *sender, void **signal, const QObject *receiver, void **slot, const QMetaObject *senderMetaObject)">
                <parameter type="const QObject *" name="sender" default=""/>
                <parameter type="void **" name="signal" default=""/>
                <parameter type="const QObject *" name="receiver" default=""/>
                <parameter type="void **" name="slot" default=""/>
                <parameter type="const QMetaObject *" name="senderMetaObject" default=""/>
                <description path="" line="0" column="0"/>
            </function>
            <function threadsafety="unspecified" name="Q_DISABLE_COPY" href="qobject.html#Q_DISABLE_COPY" status="active" access="public" virtual="non" meta="macrowithparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_DISABLE_COPY( Class)">
                <parameter type="" name="Class" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/global/qglobal.cpp" line="491" column="4">
                    <para>Disables the use of copy constructors and assignment operators for the given <argument>Class</argument>.</para>
                    <para>Instances of subclasses of <link raw="QObject" href="qobject.html" type="class">QObject</link> should not be thought of as values that can be copied or assigned, but as unique identities. This means that when you create your own subclass of <link raw="QObject" href="qobject.html" type="class">QObject</link> (director or indirect), you should <italic>not</italic> give it a copy constructor or an assignment operator. However, it may not enough to simply omit them from your class, because, if you mistakenly write some code that requires a copy constructor or an assignment operator (it's easy to do), your compiler will thoughtfully create it for you. You must do more.</para>
                    <para>The curious user will have seen that the Qt classes derived from <link raw="QObject" href="qobject.html" type="class">QObject</link> typically include this macro in a private section:</para>
                    <snippet location="code/src_corelib_global_qglobal.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_global_qglobal.cpp" identifier="43"/>
                    <para>It declares a copy constructor and an assignment operator in the private section, so that if you use them by mistake, the compiler will report an error.</para>
                    <snippet location="code/src_corelib_global_qglobal.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_global_qglobal.cpp" identifier="44"/>
                    <para>But even this might not catch absolutely every case. You might be tempted to do something like this:</para>
                    <snippet location="code/src_corelib_global_qglobal.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_global_qglobal.cpp" identifier="45"/>
                    <para>First of all, don't do that. Most compilers will generate code that uses the copy constructor, so the privacy violation error will be reported, but your C++ compiler is not required to generate code for this statement in a specific way. It could generate code using <italic>neither</italic> the copy constructor <italic>nor</italic> the assignment operator we made private. In that case, no error would be reported, but your application would probably crash when you called a member function of <teletype type="highlighted">w</teletype>.</para>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_CLASSINFO" href="qobject.html#Q_CLASSINFO" status="active" access="public" virtual="non" meta="macrowithparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_CLASSINFO( Name,  Value)">
                <parameter type="" name="Name" default=""/>
                <parameter type="" name="Value" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4182" column="4">
                    <para>This macro associates extra information to the class, which is available using <link raw="QObject::metaObject()" href="qobject.html#metaObject" type="function">QObject::metaObject()</link>. Qt makes only limited use of this feature, in the <link raw="Active Qt" href="activeqt-index.html" type="page" page="Active Qt">Active Qt</link>, <link raw="Qt D-Bus" href="qtdbus-index.html" type="page" page="Qt D-Bus">Qt D-Bus</link> and <link raw="Qt QML module" href="whatsnew59.html#qt-qml-module" type="page" page="What's New in Qt 5.9">Qt QML</link>.</para>
                    <para>The extra information takes the form of a <argument>Name</argument> string and a <argument>Value</argument> literal string.</para>
                    <para>Example:</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="35"/>
                    <see-also>
                        <link raw="QMetaObject::classInfo()" href="qmetaobject.html#classInfo" type="function">QMetaObject::classInfo()</link>
                        <link raw="QAxFactory" href="qaxfactory.html" type="class">QAxFactory</link>
                        <link raw="Using Qt D-Bus Adaptors" href="usingadaptors.html" type="page" page="Using Qt D-Bus Adaptors">Using Qt D-Bus Adaptors</link>
                        <link raw="Extending QML" href="qtquick-codesamples.html#extending-qml" type="page" page="Qt Quick Examples and Tutorials">Extending QML</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_INTERFACES" href="qobject.html#Q_INTERFACES" status="active" access="public" virtual="non" meta="macrowithparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_INTERFACES( ... )">
                <parameter type=" ..." name="" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4203" column="4">
                    <para>This macro tells Qt which interfaces the class implements. This is used when implementing plugins.</para>
                    <para>Example:</para>
                    <snippet location="../widgets/tools/plugandpaint/plugins/basictools/basictoolsplugin.h" path="C:/Qt/5.11.1/Src/qtbase/examples/corelib/../widgets/tools/plugandpaint/plugins/basictools/basictoolsplugin.h" identifier="1"/>
                    <dots indent="4">...</dots>
                    <snippet location="../widgets/tools/plugandpaint/plugins/basictools/basictoolsplugin.h" path="C:/Qt/5.11.1/Src/qtbase/examples/corelib/../widgets/tools/plugandpaint/plugins/basictools/basictoolsplugin.h" identifier="3"/>
                    <para>See the <link raw="tools/plugandpaint/plugins/basictools" href="qtwidgets-tools-plugandpaint-plugins-basictools-example.html" type="page" page="Plug &amp; Paint Basic Tools Example">Plug &amp; Paint Basic Tools</link> example for details.</para>
                    <see-also>
                        <link raw="Q_DECLARE_INTERFACE()" href="qtplugin.html#Q_DECLARE_INTERFACE" type="function">Q_DECLARE_INTERFACE()</link>
                        <link raw="Q_PLUGIN_METADATA()" href="qtplugin.html#Q_PLUGIN_METADATA" type="function">Q_PLUGIN_METADATA()</link>
                        <link raw="How to Create Qt Plugins" href="plugins-howto.html" type="page" page="How to Create Qt Plugins">How to Create Qt Plugins</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_PROPERTY" href="qobject.html#Q_PROPERTY" status="active" access="public" virtual="non" meta="macrowithparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_PROPERTY( ... )">
                <parameter type=" ..." name="" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4222" column="4">
                    <para>This macro is used for declaring properties in classes that inherit <link raw="QObject" href="qobject.html" type="class">QObject</link>. Properties behave like class data members, but they have additional features accessible through the <link raw="Meta-Object System" href="metaobjects.html" type="page" page="The Meta-Object System">Meta-Object System</link>.</para>
                    <snippet location="code/doc_src_properties.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/doc_src_properties.cpp" identifier="0"/>
                    <para>The property name and type and the <teletype type="highlighted">READ</teletype> function are required. The type can be any type supported by <link raw="QVariant" href="qvariant.html" type="class">QVariant</link>, or it can be a user-defined type. The other items are optional, but a <teletype type="highlighted">WRITE</teletype> function is common. The attributes default to true except <teletype type="highlighted">USER</teletype>, which defaults to false.</para>
                    <para>For example:</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="37"/>
                    <para>For more details about how to use this macro, and a more detailed example of its use, see the discussion on <link raw="Qt's Property System" href="properties.html" type="page" page="The Property System">Qt's Property System</link>.</para>
                    <see-also>
                        <link raw="Qt's Property System" href="properties.html" type="page" page="The Property System">Qt's Property System</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_ENUMS" href="qobject-obsolete.html#Q_ENUMS" status="obsolete" access="public" virtual="non" meta="macrowithparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_ENUMS( ... )">
                <parameter type=" ..." name="" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4249" column="4">
                    <para>This macro registers one or several enum types to the meta-object system.</para>
                    <para>For example:</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="38"/>
                    <para>If you want to register an enum that is declared in another class, the enum must be fully qualified with the name of the class defining it. In addition, the class <italic>defining</italic> the enum has to inherit <link raw="QObject" href="qobject.html" type="class">QObject</link> as well as declare the enum using .</para>
                    <para>In new code, you should prefer the use of the <link raw="Q_ENUM()" href="qobject.html#Q_ENUM" type="function">Q_ENUM()</link> macro, which makes the type available also to the meta type system. For instance, <link raw="QMetaEnum::fromType()" href="qmetaenum.html#fromType" type="function">QMetaEnum::fromType()</link> will not work with types declared with .</para>
                    <see-also>
                        <link raw="Qt's Property System" href="properties.html" type="page" page="The Property System">Qt's Property System</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_FLAGS" href="qobject-obsolete.html#Q_FLAGS" status="obsolete" access="public" virtual="non" meta="macrowithparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_FLAGS( ... )">
                <parameter type=" ..." name="" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4273" column="4">
                    <para>This macro registers one or several <link raw="QFlags" href="qflags.html" type="class">flags types</link> with the meta-object system. It is typically used in a class definition to declare that values of a given enum can be used as flags and combined using the bitwise OR operator.</para>
                    <para>
                        <bold>Note:</bold> This macro takes care of registering individual flag values with the meta-object system, so it is unnecessary to use <link raw="Q_ENUMS()" href="qobject-obsolete.html#Q_ENUMS" type="function">Q_ENUMS()</link> in addition to this macro.</para>
                    <para>In new code, you should prefer the use of the <link raw="Q_FLAG()" href="qobject.html#Q_FLAG" type="function">Q_FLAG()</link> macro, which makes the type available also to the meta type system.</para>
                    <see-also>
                        <link raw="Qt's Property System" href="properties.html" type="page" page="The Property System">Qt's Property System</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_ENUM" href="qobject.html#Q_ENUM" status="active" access="public" since="5.5" virtual="non" meta="macrowithparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_ENUM( ... )">
                <parameter type=" ..." name="" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4293" column="4">
                    <para>This macro registers an enum type with the meta-object system. It must be placed after the enum declaration in a class that has the <link raw="Q_OBJECT" href="qobject.html#Q_OBJECT" type="function">Q_OBJECT</link> or the <link raw="Q_GADGET" href="qobject.html#Q_GADGET" type="function">Q_GADGET</link> macro. For namespaces use <link raw="Q_ENUM_NS()" href="qobject.html#Q_ENUM_NS" type="function">Q_ENUM_NS()</link> instead.</para>
                    <para>For example:</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="38"/>
                    <para>Enumerations that are declared with  have their <link raw="QMetaEnum" href="qmetaenum.html" type="class">QMetaEnum</link> registered in the enclosing <link raw="QMetaObject" href="qmetaobject.html" type="class">QMetaObject</link>. You can also use <link raw="QMetaEnum::fromType()" href="qmetaenum.html#fromType" type="function">QMetaEnum::fromType()</link> to get the <link raw="QMetaEnum" href="qmetaenum.html" type="class">QMetaEnum</link>.</para>
                    <para>Registered enumerations are automatically registered also to the Qt meta type system, making them known to <link raw="QMetaType" href="qmetatype.html" type="class">QMetaType</link> without the need to use <link raw="Q_DECLARE_METATYPE()" href="qmetatype.html#Q_DECLARE_METATYPE" type="function">Q_DECLARE_METATYPE()</link>. This will enable useful features; for example, if used in a <link raw="QVariant" href="qvariant.html" type="class">QVariant</link>, you can convert them to strings. Likewise, passing them to <link raw="QDebug" href="qdebug.html" type="class">QDebug</link> will print out their names.</para>
                    <see-also>
                        <link raw="Qt's Property System" href="properties.html" type="page" page="The Property System">Qt's Property System</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_FLAG" href="qobject.html#Q_FLAG" status="active" access="public" since="5.5" virtual="non" meta="macrowithparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_FLAG( ... )">
                <parameter type=" ..." name="" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4319" column="4">
                    <para>This macro registers a single <link raw="QFlags" href="qflags.html" type="class">flags type</link> with the meta-object system. It is typically used in a class definition to declare that values of a given enum can be used as flags and combined using the bitwise OR operator. For namespaces use <link raw="Q_FLAG_NS()" href="qobject.html#Q_FLAG_NS" type="function">Q_FLAG_NS()</link> instead.</para>
                    <para>The macro must be placed after the enum declaration.</para>
                    <para>For example, in <link raw="QLibrary" href="qlibrary.html" type="class">QLibrary</link>, the <link raw="QLibrary::LoadHints" href="qlibrary.html#LoadHint-enum" type="typedef">LoadHints</link> flag is declared in the following way:</para>
                    <snippet location="code/src_corelib_kernel_qobject.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/code/src_corelib_kernel_qobject.cpp" identifier="39"/>
                    <para>The declaration of the flags themselves is performed in the public section of the <link raw="QLibrary" href="qlibrary.html" type="class">QLibrary</link> class itself, using the <link raw="Q_DECLARE_FLAGS()" href="qflags.html#Q_DECLARE_FLAGS" type="function">Q_DECLARE_FLAGS()</link> macro.</para>
                    <para>
                        <bold>Note:</bold> The  macro takes care of registering individual flag values with the meta-object system, so it is unnecessary to use <link raw="Q_ENUM()" href="qobject.html#Q_ENUM" type="function">Q_ENUM()</link> in addition to this macro.</para>
                    <see-also>
                        <link raw="Qt's Property System" href="properties.html" type="page" page="The Property System">Qt's Property System</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_ENUM_NS" href="qobject.html#Q_ENUM_NS" status="active" access="public" since="5.8" virtual="non" meta="macrowithparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_ENUM_NS( ... )">
                <parameter type=" ..." name="" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4346" column="4">
                    <para>This macro registers an enum type with the meta-object system. It must be placed after the enum declaration in a namespace that has the <link raw="Q_NAMESPACE" href="qobject.html#Q_NAMESPACE" type="function">Q_NAMESPACE</link> macro. It is the same as <link raw="Q_ENUM" href="qobject.html#Q_ENUM" type="function">Q_ENUM</link> but in a namespace.</para>
                    <para>Enumerations that are declared with  have their <link raw="QMetaEnum" href="qmetaenum.html" type="class">QMetaEnum</link> registered in the enclosing <link raw="QMetaObject" href="qmetaobject.html" type="class">QMetaObject</link>. You can also use <link raw="QMetaEnum::fromType()" href="qmetaenum.html#fromType" type="function">QMetaEnum::fromType()</link> to get the <link raw="QMetaEnum" href="qmetaenum.html" type="class">QMetaEnum</link>.</para>
                    <para>Registered enumerations are automatically registered also to the Qt meta type system, making them known to <link raw="QMetaType" href="qmetatype.html" type="class">QMetaType</link> without the need to use <link raw="Q_DECLARE_METATYPE()" href="qmetatype.html#Q_DECLARE_METATYPE" type="function">Q_DECLARE_METATYPE()</link>. This will enable useful features; for example, if used in a <link raw="QVariant" href="qvariant.html" type="class">QVariant</link>, you can convert them to strings. Likewise, passing them to <link raw="QDebug" href="qdebug.html" type="class">QDebug</link> will print out their names.</para>
                    <see-also>
                        <link raw="Qt's Property System" href="properties.html" type="page" page="The Property System">Qt's Property System</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_FLAG_NS" href="qobject.html#Q_FLAG_NS" status="active" access="public" since="5.8" virtual="non" meta="macrowithparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_FLAG_NS( ... )">
                <parameter type=" ..." name="" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4370" column="4">
                    <para>This macro registers a single <link raw="QFlags" href="qflags.html" type="class">flags type</link> with the meta-object system. It is used in a namespace that has the <link raw="Q_NAMESPACE" href="qobject.html#Q_NAMESPACE" type="function">Q_NAMESPACE</link> macro, to declare that values of a given enum can be used as flags and combined using the bitwise OR operator. It is the same as <link raw="Q_FLAG" href="qobject.html#Q_FLAG" type="function">Q_FLAG</link> but in a namespace.</para>
                    <para>The macro must be placed after the enum declaration.</para>
                    <para>
                        <bold>Note:</bold> The  macro takes care of registering individual flag values with the meta-object system, so it is unnecessary to use <link raw="Q_ENUM_NS()" href="qobject.html#Q_ENUM_NS" type="function">Q_ENUM_NS()</link> in addition to this macro.</para>
                    <see-also>
                        <link raw="Qt's Property System" href="properties.html" type="page" page="The Property System">Qt's Property System</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_OBJECT" href="qobject.html#Q_OBJECT" status="active" access="public" virtual="non" meta="macrowithoutparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_OBJECT">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4391" column="4">
                    <para>The  macro must appear in the private section of a class definition that declares its own signals and slots or that uses other services provided by Qt's meta-object system.</para>
                    <para>For example:</para>
                    <snippet location="signalsandslots/signalsandslots.h" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/signalsandslots/signalsandslots.h" identifier="1"/>
                    <codeline> </codeline>
                    <snippet location="signalsandslots/signalsandslots.h" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/signalsandslots/signalsandslots.h" identifier="2"/>
                    <snippet location="signalsandslots/signalsandslots.h" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/signalsandslots/signalsandslots.h" identifier="3"/>
                    <para>
                        <bold>Note:</bold> This macro requires the class to be a subclass of <link raw="QObject" href="qobject.html" type="class">QObject</link>. Use <link raw="Q_GADGET" href="qobject.html#Q_GADGET" type="function">Q_GADGET</link> instead of  to enable the meta object system's support for enums in a class that is not a <link raw="QObject" href="qobject.html" type="class">QObject</link> subclass.</para>
                    <see-also>
                        <link raw="Meta-Object System" href="metaobjects.html" type="page" page="The Meta-Object System">Meta-Object System</link>
                        <link raw="Signals and Slots" href="signalsandslots.html" type="page" page="Signals &amp; Slots">Signals and Slots</link>
                        <link raw="Qt's Property System" href="properties.html" type="page" page="The Property System">Qt's Property System</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_GADGET" href="qobject.html#Q_GADGET" status="active" access="public" virtual="non" meta="macrowithoutparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_GADGET">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4413" column="4">
                    <para>The  macro is a lighter version of the <link raw="Q_OBJECT" href="qobject.html#Q_OBJECT" type="function">Q_OBJECT</link> macro for classes that do not inherit from <link raw="QObject" href="qobject.html" type="class">QObject</link> but still want to use some of the reflection capabilities offered by <link raw="QMetaObject" href="qmetaobject.html" type="class">QMetaObject</link>. Just like the <link raw="Q_OBJECT" href="qobject.html#Q_OBJECT" type="function">Q_OBJECT</link> macro, it must appear in the private section of a class definition.</para>
                    <para>Q_GADGETs can have <link raw="Q_ENUM" href="qobject.html#Q_ENUM" type="function">Q_ENUM</link>, <link raw="Q_PROPERTY" href="qobject.html#Q_PROPERTY" type="function">Q_PROPERTY</link> and <link raw="Q_INVOKABLE" href="qobject.html#Q_INVOKABLE" type="function">Q_INVOKABLE</link>, but they cannot have signals or slots</para>
                    <para> makes a class member, <teletype type="highlighted">staticMetaObject</teletype>, available. <teletype type="highlighted">staticMetaObject</teletype> is of type <link raw="QMetaObject" href="qmetaobject.html" type="class">QMetaObject</link> and provides access to the enums declared with <link raw="Q_ENUMS" href="qobject-obsolete.html#Q_ENUMS" type="function">Q_ENUMS</link>.</para>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_NAMESPACE" href="qobject.html#Q_NAMESPACE" status="active" access="public" since="5.8" virtual="non" meta="macrowithoutparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_NAMESPACE">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4430" column="4">
                    <para>The  macro can be used to add <link raw="QMetaObject" href="qmetaobject.html" type="class">QMetaObject</link> capabilities to a namespace.</para>
                    <para>Q_NAMESPACEs can have <link raw="Q_CLASSINFO" href="qobject.html#Q_CLASSINFO" type="function">Q_CLASSINFO</link>, <link raw="Q_ENUM_NS" href="qobject.html#Q_ENUM_NS" type="function">Q_ENUM_NS</link>, <link raw="Q_FLAG_NS" href="qobject.html#Q_FLAG_NS" type="function">Q_FLAG_NS</link>, but they cannot have <link raw="Q_ENUM" href="qobject.html#Q_ENUM" type="function">Q_ENUM</link>, <link raw="Q_FLAG" href="qobject.html#Q_FLAG" type="function">Q_FLAG</link>, <link raw="Q_PROPERTY" href="qobject.html#Q_PROPERTY" type="function">Q_PROPERTY</link>, <link raw="Q_INVOKABLE" href="qobject.html#Q_INVOKABLE" type="function">Q_INVOKABLE</link>, signals nor slots.</para>
                    <para> makes an external variable, <teletype type="highlighted">staticMetaObject</teletype>, available. <teletype type="highlighted">staticMetaObject</teletype> is of type <link raw="QMetaObject" href="qmetaobject.html" type="class">QMetaObject</link> and provides access to the enums declared with <link raw="Q_ENUM_NS" href="qobject.html#Q_ENUM_NS" type="function">Q_ENUM_NS</link>/<link raw="Q_FLAG_NS" href="qobject.html#Q_FLAG_NS" type="function">Q_FLAG_NS</link>.</para>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_SIGNALS" href="qobject.html#Q_SIGNALS" status="active" access="public" virtual="non" meta="macrowithoutparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_SIGNALS">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4446" column="4">
                    <para>Use this macro to replace the <teletype type="highlighted">signals</teletype> keyword in class declarations, when you want to use Qt Signals and Slots with a <link raw="3rd Party Signals and Slots" href="signalsandslots.html#3rd-party-signals-and-slots" type="page" page="Signals &amp; Slots">3rd party signal/slot mechanism</link>.</para>
                    <para>The macro is normally used when <teletype type="highlighted">no_keywords</teletype> is specified with the <teletype type="highlighted">CONFIG</teletype> variable in the <teletype type="highlighted">.pro</teletype> file, but it can be used even when <teletype type="highlighted">no_keywords</teletype> is <italic>not</italic> specified.</para>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_SIGNAL" href="qobject.html#Q_SIGNAL" status="active" access="public" virtual="non" meta="macrowithoutparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_SIGNAL">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4459" column="4">
                    <para>This is an additional macro that allows you to mark a single function as a signal. It can be quite useful, especially when you use a 3rd-party source code parser which doesn't understand a <teletype type="highlighted">signals</teletype> or <teletype type="highlighted">Q_SIGNALS</teletype> groups.</para>
                    <para>Use this macro to replace the <teletype type="highlighted">signals</teletype> keyword in class declarations, when you want to use Qt Signals and Slots with a <link raw="3rd Party Signals and Slots" href="signalsandslots.html#3rd-party-signals-and-slots" type="page" page="Signals &amp; Slots">3rd party signal/slot mechanism</link>.</para>
                    <para>The macro is normally used when <teletype type="highlighted">no_keywords</teletype> is specified with the <teletype type="highlighted">CONFIG</teletype> variable in the <teletype type="highlighted">.pro</teletype> file, but it can be used even when <teletype type="highlighted">no_keywords</teletype> is <italic>not</italic> specified.</para>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_SLOTS" href="qobject.html#Q_SLOTS" status="active" access="public" virtual="non" meta="macrowithoutparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_SLOTS">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4477" column="4">
                    <para>Use this macro to replace the <teletype type="highlighted">slots</teletype> keyword in class declarations, when you want to use Qt Signals and Slots with a <link raw="3rd Party Signals and Slots" href="signalsandslots.html#3rd-party-signals-and-slots" type="page" page="Signals &amp; Slots">3rd party signal/slot mechanism</link>.</para>
                    <para>The macro is normally used when <teletype type="highlighted">no_keywords</teletype> is specified with the <teletype type="highlighted">CONFIG</teletype> variable in the <teletype type="highlighted">.pro</teletype> file, but it can be used even when <teletype type="highlighted">no_keywords</teletype> is <italic>not</italic> specified.</para>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_SLOT" href="qobject.html#Q_SLOT" status="active" access="public" virtual="non" meta="macrowithoutparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_SLOT">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4490" column="4">
                    <para>This is an additional macro that allows you to mark a single function as a slot. It can be quite useful, especially when you use a 3rd-party source code parser which doesn't understand a <teletype type="highlighted">slots</teletype> or <teletype type="highlighted">Q_SLOTS</teletype> groups.</para>
                    <para>Use this macro to replace the <teletype type="highlighted">slots</teletype> keyword in class declarations, when you want to use Qt Signals and Slots with a <link raw="3rd Party Signals and Slots" href="signalsandslots.html#3rd-party-signals-and-slots" type="page" page="Signals &amp; Slots">3rd party signal/slot mechanism</link>.</para>
                    <para>The macro is normally used when <teletype type="highlighted">no_keywords</teletype> is specified with the <teletype type="highlighted">CONFIG</teletype> variable in the <teletype type="highlighted">.pro</teletype> file, but it can be used even when <teletype type="highlighted">no_keywords</teletype> is <italic>not</italic> specified.</para>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_EMIT" href="qobject.html#Q_EMIT" status="active" access="public" virtual="non" meta="macrowithoutparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_EMIT">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4508" column="4">
                    <para>Use this macro to replace the <teletype type="highlighted">emit</teletype> keyword for emitting signals, when you want to use Qt Signals and Slots with a <link raw="3rd Party Signals and Slots" href="signalsandslots.html#3rd-party-signals-and-slots" type="page" page="Signals &amp; Slots">3rd party signal/slot mechanism</link>.</para>
                    <para>The macro is normally used when <teletype type="highlighted">no_keywords</teletype> is specified with the <teletype type="highlighted">CONFIG</teletype> variable in the <teletype type="highlighted">.pro</teletype> file, but it can be used even when <teletype type="highlighted">no_keywords</teletype> is <italic>not</italic> specified.</para>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_INVOKABLE" href="qobject.html#Q_INVOKABLE" status="active" access="public" virtual="non" meta="macrowithoutparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_INVOKABLE">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4521" column="4">
                    <para>Apply this macro to declarations of member functions to allow them to be invoked via the meta-object system. The macro is written before the return type, as shown in the following example:</para>
                    <snippet location="qmetaobject-invokable/window.h" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/qmetaobject-invokable/window.h" identifier="Window class with invokable method"/>
                    <para>The <teletype type="highlighted">invokableMethod()</teletype> function is marked up using , causing it to be registered with the meta-object system and enabling it to be invoked using <link raw="QMetaObject::invokeMethod()" href="qmetaobject.html#invokeMethod" type="function">QMetaObject::invokeMethod()</link>. Since <teletype type="highlighted">normalMethod()</teletype> function is not registered in this way, it cannot be invoked using <link raw="QMetaObject::invokeMethod()" href="qmetaobject.html#invokeMethod" type="function">QMetaObject::invokeMethod()</link>.</para>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_REVISION" href="qobject.html#Q_REVISION" status="active" access="public" virtual="non" meta="macrowithoutparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_REVISION">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4538" column="4">
                    <para>Apply this macro to declarations of member functions to tag them with a revision number in the meta-object system. The macro is written before the return type, as shown in the following example:</para>
                    <snippet location="qmetaobject-revision/window.h" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/qmetaobject-revision/window.h" identifier="Window class with revision"/>
                    <para>This is useful when using the meta-object system to dynamically expose objects to another API, as you can match the version expected by multiple versions of the other API. Consider the following simplified example:</para>
                    <snippet location="qmetaobject-revision/main.cpp" path="C:/Qt/5.11.1/Src/qtbase/src/corelib/doc/snippets/qmetaobject-revision/main.cpp" identifier="Window class using revision"/>
                    <para>Using the same Window class as the previous example, the newProperty and newMethod would only be exposed in this code when the expected version is 1 or greater.</para>
                    <para>Since all methods are considered to be in revision 0 if untagged, a tag of (0) is invalid and ignored.</para>
                    <para>This tag is not used by the meta-object system itself. Currently this is only used by the <link raw="QtQml" href="qtqml-module.html" type="module">QtQml</link> module.</para>
                    <para>For a more generic string tag, see <link raw="QMetaMethod::tag()" href="qmetamethod.html#tag" type="function">QMetaMethod::tag()</link></para>
                    <see-also>
                        <link raw="QMetaMethod::revision()" href="qmetamethod.html#revision" type="function">QMetaMethod::revision()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="Q_SET_OBJECT_NAME" href="qobject.html#Q_SET_OBJECT_NAME" status="active" access="public" since="5.0" virtual="non" meta="macrowithparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="Q_SET_OBJECT_NAME( Object)">
                <parameter type="" name="Object" default=""/>
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4569" column="4">
                    <para>This macro assigns <argument>Object</argument> the objectName &quot;Object&quot;.</para>
                    <para>It doesn't matter whether <argument>Object</argument> is a pointer or not, the macro figures that out by itself.</para>
                    <see-also>
                        <link raw="QObject::objectName()" href="qobject.html#objectName-prop" type="function">QObject::objectName()</link>
                    </see-also>
                </description>
            </function>
            <function threadsafety="unspecified" name="QT_NO_NARROWING_CONVERSIONS_IN_CONNECT" href="qobject.html#QT_NO_NARROWING_CONVERSIONS_IN_CONNECT" status="active" access="public" since="5.8" virtual="non" meta="macrowithoutparams" const="false" static="false" overload="false" delete="false" default="false" final="false" override="false" relates="QObject" type="" signature="QT_NO_NARROWING_CONVERSIONS_IN_CONNECT">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4582" column="4">
                    <para>Defining this macro will disable narrowing and floating-point-to-integral conversions between the arguments carried by a signal and the arguments accepted by a slot, when the signal and the slot are connected using the PMF-based syntax.</para>
                    <see-also>
                        <link raw="QObject::connect" href="qobject.html#connect" type="function">QObject::connect</link>
                    </see-also>
                </description>
            </function>
            <typedef threadsafety="unspecified" name="QObjectList" href="qobject.html#QObjectList-typedef" status="active" access="public" location="qobject.h" filepath="C:/Qt/5.11.1/msvc2017_64/include\QtCore/qobject.h" lineno="85">
                <description path="C:/Qt/5.11.1/Src/qtbase/src/corelib/kernel/qobject.cpp" line="4595" column="4">
                    <para>Synonym for <link raw="QList" href="qlist.html" type="class">QList</link>&lt;<link raw="QObject" href="qobject.html" type="class">QObject</link> *&gt;.</para>
                </description>
            </typedef>
        </class>
    </document>
</WebXML>
