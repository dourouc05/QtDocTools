<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink"
  version="5.2">
  <db:info>
    <db:title>Deploying QML Applications</db:title>
    <db:abstract>
      <db:para>Deploying QML applications</db:para>
    </db:abstract>
  </db:info>
  <db:para>Deploying QML applications</db:para>
  <db:para>QML documents are loaded and executed by the QML runtime. This includes the Declarative UI engine along with the built-in QML types and plugin modules, and it also provides access to third-party QML types and modules.</db:para>
  <db:para>Applications that use QML need to invoke the QML runtime in order to execute QML documents. This can be done by creating a QQuickView or a <db:code><db:link xlink:href="qqmlengine.html" xrefstyle="class" annotations="QQmlEngine">QQmlEngine</db:link></db:code>, as described below. In addition, the Declarative UI package includes the qmlscene tool, which loads <db:code>.qml</db:code> files. This tool is useful for developing and testing QML code without the need to write a C++ application to load the QML runtime.</db:para>
  <db:section xml:id="deploying-applications-with-qt-creator">
    <db:title>Deploying Applications with Qt Creator</db:title>
    <db:para>
      <db:link xlink:href="http://doc.qt.io/qtcreator/index.html" xrefstyle="page" annotations="Qt Creator Manual">Qt Creator</db:link> deploys and packages QML applications to various platforms. For mobile devices, Qt Creator can directly bundle applications to the respective platform package formats such as APK.</db:para>
    <db:para>For more information, visit:</db:para>
    <db:itemizedlist>
      <db:listitem>
        <db:para>
          <db:link xlink:href="deployment.html" xrefstyle="page" annotations="Deploying Qt Applications">Deploying Qt Applications</db:link>
        </db:para>
      </db:listitem>
      <db:listitem>
        <db:para>
          <db:link xlink:href="http://doc.qt.io/qtcreator/creator-running-targets.html" xrefstyle="page" annotations="Qt Creator: Running on Multiple Platforms">Running on Multiple Platforms</db:link>
        </db:para>
      </db:listitem>
      <db:listitem>
        <db:para>
          <db:link xlink:href="http://doc.qt.io/qtcreator/creator-deployment.html" xrefstyle="page" annotations="Qt Creator: Deploying to Devices">Deploying to Devices</db:link>
        </db:para>
      </db:listitem>
    </db:itemizedlist>
    <db:para>When running applications on the target platform, the application needs to access the location of the QML libraries. When using <db:link xlink:href="qmake-manual.html" xrefstyle="page" annotations="qmake Manual">qmake</db:link>, the <db:code>QT_INSTALL_QML</db:code> environment points to the location of the libraries. The <db:link xlink:href="http://qt.io/download" xrefstyle="page" annotations="Downloads">Qt Installers</db:link> install the QML libraries in <db:emphasis>&lt;version&gt;</db:emphasis>
      <db:code>/</db:code>
      <db:emphasis>&lt;compiler&gt;</db:emphasis>
      <db:code>/qml</db:code> directory.</db:para>
  </db:section>
  <db:section xml:id="qml-caching">
    <db:title>QML Caching</db:title>
    <db:para>The QML runtime loads QML documents by parsing them and generating byte code. Most of the time the document hasn't changed since the last time it was loaded. In order to speed up this loading process, the QML runtime maintains a cache file for each qml document. This cache file contains the compiled byte code and a binary representation of the QML document structure. In addition, when multiple applications use the same QML document, the memory needed for the code is shared between application processes. The cache files are loaded via the <db:code>mmap()</db:code> system call on POSIX compliant operating systems or <db:code>CreateFileMapping()</db:code> on Windows, resulting in significant memory savings.</db:para>
    <db:para>Each time you load a changed QML document, the cache is automatically re-created. Cache files are located in the same directory as the source code, if the directory is writable. Otherwise they will be placed in a sub-directory of <db:code><db:link xlink:href="qstandardpaths.html#StandardLocation-enum" xrefstyle="enum" annotations="QStandardPaths::CacheLocation">QStandardPaths::CacheLocation</db:link></db:code> with the name "qmlcache". The file extension is <db:code>.qmlc</db:code> for QML documents and <db:code>.jsc</db:code> for imported JavaScript modules. On the Android platform, cache files are always stored in the cache directory.</db:para>
  </db:section>
  <db:section xml:id="compiling-qml-ahead-of-time">
    <db:title>Compiling QML Ahead of Time</db:title>
    <db:para>The automatic caching of compiled QML documents into cache files results in significantly faster load times of applications. However, the initial creation of cache files can still take time, especially when the application starts for the very first time. To avoid that initial step and provide faster start-up times from the very beginning, Qt's build system allows you to perform the compilation step for QML files at the same time as the rest of your application.</db:para>
    <db:para>If you would like to deploy your application with QML files compiled ahead of time, then you must organize the files and the build system in a specific way:</db:para>
    <db:itemizedlist>
      <db:listitem>
        <db:para>All QML documents (including JavaScript files) must be included as resources through <db:link xlink:href="resources.html" xrefstyle="page" annotations="The Qt Resource System">Qt's Resource system</db:link>.</db:para>
      </db:listitem>
      <db:listitem>
        <db:para>Your application must load the QML documents via the <db:code>qrc:///</db:code> URL scheme.</db:para>
      </db:listitem>
      <db:listitem>
        <db:para>You can enable Ahead-of-Time compilation using the <db:code>CONFIG+=qtquickcompiler</db:code> directive.</db:para>
      </db:listitem>
      <db:listitem>
        <db:para>If you are using the CMake build system, then you can achieve this inserting a <db:code>find_package(Qt5QuickCompiler)</db:code> call into your <db:code>CMakeLists.txt</db:code> and replace the use of of <db:code>qt5_add_resources</db:code> with <db:code>qtquick_compiler_add_resources</db:code> .</db:para>
      </db:listitem>
    </db:itemizedlist>
    <db:para>One added benefit of this way of developing and deploying the application is that you will be notified of syntax errors in your QML documents at application compile time, instead of run-time when loading the file.</db:para>
  </db:section>
  <db:section xml:id="limitations">
    <db:title>Limitations</db:title>
    <db:para>Currently this feature will tie your application to the Qt version you are compiling against, because it will replace the QML document source code in the resources with the compiled binary version. The source files are not present anymore. That means that when using the same application against a different version of Qt without recompiling it, loading the QML documents will fail with an error message.</db:para>
    <db:para>The Ahead-of-Time compilation is implemented this way because the feature originates from an add-on for use in commercial application environments, where the deployment of source code is not desirable and requiring a recompilation when changing Qt is usually acceptable.</db:para>
    <db:para>We plan to implement support for retaining the source documents in a future version of Qt.</db:para>
  </db:section>
  <db:section xml:id="prototyping-with-qml-scene">
    <db:title>Prototyping with QML Scene</db:title>
    <db:para>The Declarative UI package includes a QML runtime tool, <db:link xlink:href="qtquick-qmlscene.html" xrefstyle="page" annotations="qtquick-qmlscene.html">qmlscene</db:link>, which loads and displays QML documents. This is useful during the application development phase for prototyping QML-based applications without writing your own C++ applications to invoke the QML runtime.</db:para>
  </db:section>
  <db:section xml:id="initializing-the-qml-runtime-in-applications">
    <db:title>Initializing the QML Runtime in Applications</db:title>
    <db:para>To run an application that uses QML, the QML runtime must be invoked by the application. This is done by writing a Qt C++ application that loads the <db:code><db:link xlink:href="qqmlengine.html" xrefstyle="class" annotations="QQmlEngine">QQmlEngine</db:link></db:code> by either:</db:para>
    <db:itemizedlist>
      <db:listitem>
        <db:para>Loading the QML file through a QQuickView instance, or</db:para>
      </db:listitem>
      <db:listitem>
        <db:para>Creating a <db:code><db:link xlink:href="qqmlengine.html" xrefstyle="class" annotations="QQmlEngine">QQmlEngine</db:link></db:code> instance and loading QML files with <db:code><db:link xlink:href="qqmlcomponent.html" xrefstyle="class" annotations="QQmlComponent">QQmlComponent</db:link></db:code>
        </db:para>
      </db:listitem>
    </db:itemizedlist>
  </db:section>
  <db:section xml:id="initializing-with-qquickview">
    <db:title>Initializing with QQuickView</db:title>
    <db:para>QQuickView is a <db:code><db:link xlink:href="qwindow.html" xrefstyle="class" annotations="QWindow">QWindow</db:link></db:code>-based class that is able to load QML files. For example, if there is a QML file, <db:code>application.qml</db:code>, it will look like this:</db:para>
    <db:para>It can be loaded in a Qt application's <db:code>main.cpp</db:code> file like this:</db:para>
    <db:programlisting language="other">#include &lt;QGuiApplication&gt;
      #include &lt;QQuickView&gt;
      
      int main(int argc, char *argv[])
      {
      QGuiApplication app(argc, argv);
      
      QQuickView view;
      view.setSource(QUrl::fromLocalFile("application.qml"));
      view.show();
      
      return app.exec();
      }</db:programlisting>
    <db:para>This creates a <db:code><db:link xlink:href="qwindow.html" xrefstyle="class" annotations="QWindow">QWindow</db:link></db:code>-based view that displays the contents of <db:code>application.qml</db:code>.</db:para>
    <db:para>The application's <db:code>.pro</db:code>
      <db:link xlink:href="qmake-project-files.html" xrefstyle="page" annotations="Creating Project Files">project file</db:link> must specify the <db:code>declarative</db:code> module for the <db:code>QT</db:code> variable. For example:</db:para>
    <db:programlisting language="other">TEMPLATE += app
      QT += quick
      SOURCES += main.cpp</db:programlisting>
  </db:section>
  <db:section xml:id="creating-a-qqmlengine-directly">
    <db:title>Creating a QQmlEngine directly</db:title>
    <db:para>If <db:code>application.qml</db:code> does not have any graphical components, or if it is preferred to avoid QQuickView for other reasons, the <db:code><db:link xlink:href="qqmlengine.html" xrefstyle="class" annotations="QQmlEngine">QQmlEngine</db:link></db:code> can be constructed directly instead. In this case, <db:code>application.qml</db:code> is loaded as a <db:code><db:link xlink:href="qqmlcomponent.html" xrefstyle="class" annotations="QQmlComponent">QQmlComponent</db:link></db:code> instance rather than placed into a view:</db:para>
    <db:programlisting language="other">#include &lt;QGuiApplication&gt;
      #include &lt;QQmlEngine&gt;
      #include &lt;QQmlContext&gt;
      #include &lt;QQmlComponent&gt;
      
      int main(int argc, char *argv[])
      {
      QGuiApplication app(argc, argv);
      
      QQmlEngine engine;
      QQmlContext *objectContext = new QQmlContext(engine.rootContext());
      
      QQmlComponent component(&amp;engine, "application.qml");
      QObject *object = component.create(objectContext);
      
      // ... delete object and objectContext when necessary
      
      return app.exec();
      }</db:programlisting>
    <db:para>
      <db:code><db:link xlink:href="qguiapplication.html" xrefstyle="class" annotations="QGuiApplication">QGuiApplication</db:link></db:code> can be replaced by a <db:code><db:link xlink:href="qcoreapplication.html" xrefstyle="class" annotations="QCoreApplication">QCoreApplication</db:link></db:code> in the code above in case you are not using any graphical items from Qt Quick. This allows using QML as a language without any dependencies to the <db:link xlink:href="qtgui-index.html" xrefstyle="page" annotations="Qt GUI">Qt GUI</db:link> module.</db:para>
    <db:para>See <db:link xlink:href="qtqml-cppintegration-data.html" xrefstyle="page" annotations="qtqml-cppintegration-data.html">qtqml-cppintegration-exposecppattributes.html</db:link>{Exposing Attributes of C++ Types to QML} for more information about using <db:code><db:link xlink:href="qqmlengine.html" xrefstyle="class" annotations="QQmlEngine">QQmlEngine</db:link></db:code>, <db:code><db:link xlink:href="qqmlcontext.html" xrefstyle="class" annotations="QQmlContext">QQmlContext</db:link></db:code> and <db:code><db:link xlink:href="qqmlcomponent.html" xrefstyle="class" annotations="QQmlComponent">QQmlComponent</db:link></db:code>, as well as details on including QML files through <db:link xlink:href="resources.html" xrefstyle="page" annotations="The Qt Resource System">Qt's Resource system</db:link>.</db:para>
  </db:section>
  <db:section xml:id="managing-resource-files-with-the-qt-resource-system">
    <db:title>Managing Resource Files with the Qt Resource System</db:title>
    <db:para>The <db:link xlink:href="resources.html" xrefstyle="page" annotations="The Qt Resource System">Qt resource system</db:link> allows resource files to be stored as binary files in an application executable. This can be useful when building a mixed QML/C++ application as it enables QML files (as well as other resources such as images and sound files) to be referred to through the resource system URI scheme rather than relative or absolute paths to filesystem resources. Note, however, that if you use the resource system, the application executable must be re-compiled whenever a QML source file is changed in order to update the resources in the package.</db:para>
    <db:para>To use the resource system in a mixed QML/C++ application:</db:para>
    <db:itemizedlist>
      <db:listitem>
        <db:para>Create a <db:code>.qrc</db:code>
          <db:link xlink:href="resources.html" xrefstyle="page" annotations="The Qt Resource System">resource collection file</db:link> that lists resource files in XML format</db:para>
      </db:listitem>
      <db:listitem>
        <db:para>From C++, load the main QML file as a resource using the <db:code>:/</db:code> prefix or as a URL with the <db:code>qrc</db:code> scheme</db:para>
      </db:listitem>
    </db:itemizedlist>
    <db:para>Once this is done, all files specified by relative paths in QML will be loaded from the resource system instead. Use of the resource system is completely transparent to the QML layer; this means all QML code should refer to resource files using relative paths and should <db:emphasis>not</db:emphasis> use the <db:code>qrc</db:code> scheme. This scheme should only be used from C++ code for referring to resource files.</db:para>
    <db:para>Here is a application packaged using the <db:link xlink:href="resources.html" xrefstyle="page" annotations="The Qt Resource System">Qt resource system</db:link>. The directory structure looks like this:</db:para>
    <db:programlisting language="other">project
      |- example.qrc
      |- main.qml
      |- images
      |- background.png
      |- main.cpp
      |- project.pro</db:programlisting>
    <db:para>The <db:code>main.qml</db:code> and <db:code>background.png</db:code> files will be packaged as resource files. This is done in the <db:code>example.qrc</db:code> resource collection file:</db:para>
    <db:programlisting>&lt;!DOCTYPE RCC&gt;
      &lt;RCC version="1.0"&gt;
      
      &lt;qresource prefix="/"&gt;
      &lt;file&gt;main.qml&lt;/file&gt;
      &lt;file&gt;images/background.png&lt;/file&gt;
      &lt;/qresource&gt;
      
      &lt;/RCC&gt;
      
    </db:programlisting>
    <db:para>Since <db:code>background.png</db:code> is a resource file, <db:code>main.qml</db:code> can refer to it using the relative path specified in <db:code>example.qrc</db:code>:</db:para>
    <db:programlisting/>
    <db:para>To allow QML to locate resource files correctly, the <db:code>main.cpp</db:code> loads the main QML file, <db:code>main.qml</db:code>, as a resource file using the <db:code>qrc</db:code> scheme:</db:para>
    <db:programlisting/>
    <db:para>Finally, <db:code>project.pro</db:code> uses the RESOURCES variable to indicate that <db:code>example.qrc</db:code> should be used to build the application resources:</db:para>
    <db:programlisting>QT += qml
      
      SOURCES += main.cpp
      RESOURCES += example.qrc
    </db:programlisting>
    <db:para>See <db:link xlink:href="resources.html" xrefstyle="page" annotations="The Qt Resource System">The Qt Resource System</db:link> for more information.</db:para>
  </db:section>
</db:article>
