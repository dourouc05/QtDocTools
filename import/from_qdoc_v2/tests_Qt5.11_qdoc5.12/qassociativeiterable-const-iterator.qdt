<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook"
            xmlns:xlink="http://www.w3.org/1999/xlink">
   <db:info>
      <db:title>const_iterator</db:title>
      <db:abstract>
         <db:para>QAssociativeIterable::const_iterator allows iteration over a container in a QVariant</db:para>
      </db:abstract>
   </db:info>
   <db:classsynopsis>
      <db:ooclass>
         <db:classname>const_iterator</db:classname>
      </db:ooclass>
      <db:classsynopsisinfo role="module">QtCore</db:classsynopsisinfo>
      <db:namespacesynopsisinfo role="headers">#include &lt;qvariant.h&gt;</db:namespacesynopsisinfo>
      <db:classsynopsisinfo role="since">5.2</db:classsynopsisinfo>
   </db:classsynopsis>
   <db:section xml:id="details">
      <db:title>Detailed Description</db:title>
      <db:para>A <db:code><db:link xlink:href="qassociativeiterable-const-iterator.html" xrefstyle="class" annotations="QAssociativeIterable::const_iterator">QAssociativeIterable::const_iterator</db:link></db:code> can only be created by a <db:code><db:link xlink:href="qassociativeiterable.html" xrefstyle="class" annotations="QAssociativeIterable">QAssociativeIterable</db:link></db:code> instance, and can be used in a way similar to other stl-style iterators.</db:para>
      <db:programlisting>/****************************************************************************&#xD;
**&#xD;
** Copyright (C) 2016 The Qt Company Ltd.&#xD;
** Contact: https://www.qt.io/licensing/&#xD;
**&#xD;
** This file is part of the documentation of the Qt Toolkit.&#xD;
**&#xD;
** $QT_BEGIN_LICENSE:BSD$&#xD;
** Commercial License Usage&#xD;
** Licensees holding valid commercial Qt licenses may use this file in&#xD;
** accordance with the commercial license agreement provided with the&#xD;
** Software or, alternatively, in accordance with the terms contained in&#xD;
** a written agreement between you and The Qt Company. For licensing terms&#xD;
** and conditions see https://www.qt.io/terms-conditions. For further&#xD;
** information use the contact form at https://www.qt.io/contact-us.&#xD;
**&#xD;
** BSD License Usage&#xD;
** Alternatively, you may use this file under the terms of the BSD license&#xD;
** as follows:&#xD;
**&#xD;
** "Redistribution and use in source and binary forms, with or without&#xD;
** modification, are permitted provided that the following conditions are&#xD;
** met:&#xD;
**   * Redistributions of source code must retain the above copyright&#xD;
**     notice, this list of conditions and the following disclaimer.&#xD;
**   * Redistributions in binary form must reproduce the above copyright&#xD;
**     notice, this list of conditions and the following disclaimer in&#xD;
**     the documentation and/or other materials provided with the&#xD;
**     distribution.&#xD;
**   * Neither the name of The Qt Company Ltd nor the names of its&#xD;
**     contributors may be used to endorse or promote products derived&#xD;
**     from this software without specific prior written permission.&#xD;
**&#xD;
**&#xD;
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&#xD;
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&#xD;
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR&#xD;
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT&#xD;
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,&#xD;
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT&#xD;
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,&#xD;
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY&#xD;
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&#xD;
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE&#xD;
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."&#xD;
**&#xD;
** $QT_END_LICENSE$&#xD;
**&#xD;
****************************************************************************/&#xD;
&#xD;
//! [0]&#xD;
QDataStream out(...);&#xD;
QVariant v(123);                // The variant now contains an int&#xD;
int x = v.toInt();              // x = 123&#xD;
out &lt;&lt; v;                       // Writes a type tag and an int to out&#xD;
v = QVariant("hello");          // The variant now contains a QByteArray&#xD;
v = QVariant(tr("hello"));      // The variant now contains a QString&#xD;
int y = v.toInt();              // y = 0 since v cannot be converted to an int&#xD;
QString s = v.toString();       // s = tr("hello")  (see QObject::tr())&#xD;
out &lt;&lt; v;                       // Writes a type tag and a QString to out&#xD;
...&#xD;
QDataStream in(...);            // (opening the previously written stream)&#xD;
in &gt;&gt; v;                        // Reads an Int variant&#xD;
int z = v.toInt();              // z = 123&#xD;
qDebug("Type is %s",            // prints "Type is int"&#xD;
        v.typeName());&#xD;
v = v.toInt() + 100;            // The variant now hold the value 223&#xD;
v = QVariant(QStringList());&#xD;
//! [0]&#xD;
&#xD;
&#xD;
//! [1]&#xD;
QVariant x, y(QString()), z(QString(""));&#xD;
x.convert(QVariant::Int);&#xD;
// x.isNull() == true&#xD;
// y.isNull() == true, z.isNull() == false&#xD;
//! [1]&#xD;
&#xD;
&#xD;
//! [2]&#xD;
QVariant variant;&#xD;
...&#xD;
QColor color = variant.value&lt;QColor&gt;();&#xD;
//! [2]&#xD;
&#xD;
&#xD;
//! [3]&#xD;
QColor color = palette().background().color();&#xD;
QVariant variant = color;&#xD;
//! [3]&#xD;
&#xD;
&#xD;
//! [4]&#xD;
QVariant v;&#xD;
&#xD;
v.setValue(5);&#xD;
int i = v.toInt();         // i is now 5&#xD;
QString s = v.toString()   // s is now "5"&#xD;
&#xD;
MyCustomStruct c;&#xD;
v.setValue(c);&#xD;
&#xD;
...&#xD;
&#xD;
MyCustomStruct c2 = v.value&lt;MyCustomStruct&gt;();&#xD;
//! [4]&#xD;
&#xD;
&#xD;
//! [5]&#xD;
QVariant v;&#xD;
&#xD;
MyCustomStruct c;&#xD;
if (v.canConvert&lt;MyCustomStruct&gt;())&#xD;
    c = v.value&lt;MyCustomStruct&gt;();&#xD;
&#xD;
v = 7;&#xD;
int i = v.value&lt;int&gt;();                        // same as v.toInt()&#xD;
QString s = v.value&lt;QString&gt;();                // same as v.toString(), s is now "7"&#xD;
MyCustomStruct c2 = v.value&lt;MyCustomStruct&gt;(); // conversion failed, c2 is empty&#xD;
//! [5]&#xD;
&#xD;
&#xD;
//! [6]&#xD;
QVariant v = 42;&#xD;
&#xD;
v.canConvert&lt;int&gt;();              // returns true&#xD;
v.canConvert&lt;QString&gt;();          // returns true&#xD;
&#xD;
MyCustomStruct s;&#xD;
v.setValue(s);&#xD;
&#xD;
v.canConvert&lt;int&gt;();              // returns false&#xD;
v.canConvert&lt;MyCustomStruct&gt;();   // returns true&#xD;
//! [6]&#xD;
&#xD;
&#xD;
//! [7]&#xD;
MyCustomStruct s;&#xD;
return QVariant::fromValue(s);&#xD;
//! [7]&#xD;
&#xD;
&#xD;
//! [8]&#xD;
QObject *object = getObjectFromSomewhere();&#xD;
QVariant data = QVariant::fromValue(object);&#xD;
//! [8]&#xD;
&#xD;
//! [9]&#xD;
&#xD;
QList&lt;int&gt; intList = {7, 11, 42};&#xD;
&#xD;
QVariant variant = QVariant::fromValue(intList);&#xD;
if (variant.canConvert&lt;QVariantList&gt;()) {&#xD;
    QSequentialIterable iterable = variant.value&lt;QSequentialIterable&gt;();&#xD;
    // Can use foreach:&#xD;
    foreach (const QVariant &amp;v, iterable) {&#xD;
        qDebug() &lt;&lt; v;&#xD;
    }&#xD;
    // Can use C++11 range-for:&#xD;
    for (const QVariant &amp;v : iterable) {&#xD;
        qDebug() &lt;&lt; v;&#xD;
    }&#xD;
    // Can use iterators:&#xD;
    QSequentialIterable::const_iterator it = iterable.begin();&#xD;
    const QSequentialIterable::const_iterator end = iterable.end();&#xD;
    for ( ; it != end; ++it) {&#xD;
        qDebug() &lt;&lt; *it;&#xD;
    }&#xD;
}&#xD;
&#xD;
//! [9]&#xD;
&#xD;
//! [10]&#xD;
&#xD;
QHash&lt;int, QString&gt; mapping;&#xD;
mapping.insert(7, "Seven");&#xD;
mapping.insert(11, "Eleven");&#xD;
mapping.insert(42, "Forty-two");&#xD;
&#xD;
QVariant variant = QVariant::fromValue(mapping);&#xD;
if (variant.canConvert&lt;QVariantHash&gt;()) {&#xD;
    QAssociativeIterable iterable = variant.value&lt;QAssociativeIterable&gt;();&#xD;
    // Can use foreach over the values:&#xD;
    foreach (const QVariant &amp;v, iterable) {&#xD;
        qDebug() &lt;&lt; v;&#xD;
    }&#xD;
    // Can use C++11 range-for over the values:&#xD;
    for (const QVariant &amp;v : iterable) {&#xD;
        qDebug() &lt;&lt; v;&#xD;
    }&#xD;
    // Can use iterators:&#xD;
    QAssociativeIterable::const_iterator it = iterable.begin();&#xD;
    const QAssociativeIterable::const_iterator end = iterable.end();&#xD;
    for ( ; it != end; ++it) {&#xD;
        qDebug() &lt;&lt; *it; // The current value&#xD;
        qDebug() &lt;&lt; it.key();&#xD;
        qDebug() &lt;&lt; it.value();&#xD;
    }&#xD;
}&#xD;
&#xD;
//! [10]&#xD;
</db:programlisting>
      <db:para>
         <db:emphasis role="bold">See Also:</db:emphasis>
         <db:simplelist type="vert">
            <db:member>
               <db:code><db:link xlink:href="qassociativeiterable.html" xrefstyle="class" annotations="QAssociativeIterable">QAssociativeIterable</db:link></db:code>
            </db:member>
         </db:simplelist>
      </db:para>
   </db:section>
   <db:section>
      <db:title>Member Function Documentation</db:title>
      <db:section>
         <db:title> QAssociativeIterable::const_iterator::const_iterator(const const_iterator &amp;other)</db:title>
         <db:constructorsynopsis>
            <db:methodname>const_iterator</db:methodname>
            <db:methodparam>
               <db:type>const const_iterator &amp;</db:type>
               <db:parameter>other</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:constructorsynopsis>
         <db:para>Creates a copy of <db:code role="argument">other</db:code>.</db:para>
      </db:section>
      <db:section>
         <db:title> QAssociativeIterable::const_iterator::~const_iterator()</db:title>
         <db:destructorsynopsis>
            <db:methodname>~const_iterator</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:destructorsynopsis>
         <db:para>Destroys the <db:code><db:link xlink:href="qassociativeiterable-const-iterator.html" xrefstyle="class" annotations="QAssociativeIterable::const_iterator">QAssociativeIterable::const_iterator</db:link></db:code>.</db:para>
      </db:section>
      <db:section>
         <db:title>bool QAssociativeIterable::const_iterator::operator!=(const const_iterator &amp;other) const</db:title>
         <db:methodsynopsis>
            <db:type>bool</db:type>
            <db:methodname>operator!=</db:methodname>
            <db:methodparam>
               <db:type>const const_iterator &amp;</db:type>
               <db:parameter>other</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Returns <db:code>true</db:code> if <db:code role="argument">other</db:code> points to a different item than this iterator; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qassociativeiterable-const-iterator.html#operator-eq-eq" xrefstyle="function" annotations="operator==()">operator==()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>bool QAssociativeIterable::const_iterator::operator==(const const_iterator &amp;other) const</db:title>
         <db:methodsynopsis>
            <db:type>bool</db:type>
            <db:methodname>operator==</db:methodname>
            <db:methodparam>
               <db:type>const const_iterator &amp;</db:type>
               <db:parameter>other</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Returns <db:code>true</db:code> if <db:code role="argument">other</db:code> points to the same item as this iterator; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qassociativeiterable-const-iterator.html#operator-not-eq" xrefstyle="function" annotations="operator!=()">operator!=()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>const QVariant QAssociativeIterable::const_iterator::key() const</db:title>
         <db:methodsynopsis>
            <db:type>const QVariant</db:type>
            <db:methodname>key</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Returns the current key, converted to a <db:code><db:link xlink:href="qvariant.html" xrefstyle="class" annotations="QVariant">QVariant</db:link></db:code>.</db:para>
      </db:section>
      <db:section>
         <db:title>const QVariant QAssociativeIterable::const_iterator::operator**() const</db:title>
         <db:methodsynopsis>
            <db:type>const QVariant</db:type>
            <db:methodname>operator*</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Returns the current value, converted to a <db:code><db:link xlink:href="qvariant.html" xrefstyle="class" annotations="QVariant">QVariant</db:link></db:code>.</db:para>
      </db:section>
      <db:section>
         <db:title>const QVariant QAssociativeIterable::const_iterator::value() const</db:title>
         <db:methodsynopsis>
            <db:type>const QVariant</db:type>
            <db:methodname>value</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Returns the current value, converted to a <db:code><db:link xlink:href="qvariant.html" xrefstyle="class" annotations="QVariant">QVariant</db:link></db:code>.</db:para>
      </db:section>
      <db:section>
         <db:title>const_iterator &amp; QAssociativeIterable::const_iterator::operator++()</db:title>
         <db:methodsynopsis>
            <db:type>const_iterator &amp;</db:type>
            <db:methodname>operator++</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>The prefix ++ operator (<db:code>++it</db:code>) advances the iterator to the next item in the container and returns an iterator to the new current item.</db:para>
         <db:para>Calling this function on <db:code><db:link xlink:href="qassociativeiterable.html#end" xrefstyle="function" annotations="QAssociativeIterable::end()">QAssociativeIterable::end()</db:link></db:code> leads to undefined results.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qassociativeiterable-const-iterator.html#operator--" xrefstyle="function" annotations="operator--()">operator--()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>const_iterator &amp; QAssociativeIterable::const_iterator::operator+=(int j)</db:title>
         <db:methodsynopsis>
            <db:type>const_iterator &amp;</db:type>
            <db:methodname>operator+=</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>j</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Advances the iterator by <db:code role="argument">j</db:code> items.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qassociativeiterable-const-iterator.html#operator--eq" xrefstyle="function" annotations="operator-=()">operator-=()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qassociativeiterable-const-iterator.html#operator-2b" xrefstyle="function" annotations="operator+()">operator+()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>const_iterator &amp; QAssociativeIterable::const_iterator::operator--()</db:title>
         <db:methodsynopsis>
            <db:type>const_iterator &amp;</db:type>
            <db:methodname>operator--</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>The prefix -- operator (<db:code>--it</db:code>) makes the preceding item current and returns an iterator to the new current item.</db:para>
         <db:para>Calling this function on <db:code><db:link xlink:href="qassociativeiterable.html#begin" xrefstyle="function" annotations="QAssociativeIterable::begin()">QAssociativeIterable::begin()</db:link></db:code> leads to undefined results.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qassociativeiterable-const-iterator.html#operator-2b-2b" xrefstyle="function" annotations="operator++()">operator++()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>const_iterator &amp; QAssociativeIterable::const_iterator::operator-=(int j)</db:title>
         <db:methodsynopsis>
            <db:type>const_iterator &amp;</db:type>
            <db:methodname>operator-=</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>j</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Makes the iterator go back by <db:code role="argument">j</db:code> items.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qassociativeiterable-const-iterator.html#operator-2b-eq" xrefstyle="function" annotations="operator+=()">operator+=()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qassociativeiterable-const-iterator.html#operator-" xrefstyle="function" annotations="operator-()">operator-()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>const_iterator &amp; QAssociativeIterable::const_iterator::operator=(const const_iterator &amp;other)</db:title>
         <db:methodsynopsis>
            <db:type>const_iterator &amp;</db:type>
            <db:methodname>operator=</db:methodname>
            <db:methodparam>
               <db:type>const const_iterator &amp;</db:type>
               <db:parameter>other</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Assigns <db:code role="argument">other</db:code> to this.</db:para>
      </db:section>
      <db:section>
         <db:title>const_iterator QAssociativeIterable::const_iterator::operator+(int j) const</db:title>
         <db:methodsynopsis>
            <db:type>const_iterator</db:type>
            <db:methodname>operator+</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>j</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Returns an iterator to the item at <db:code role="argument">j</db:code> positions forward from this iterator.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qassociativeiterable-const-iterator.html#operator-" xrefstyle="function" annotations="operator-()">operator-()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qassociativeiterable-const-iterator.html#operator-2b-eq" xrefstyle="function" annotations="operator+=()">operator+=()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>const_iterator QAssociativeIterable::const_iterator::operator++(int )</db:title>
         <db:methodsynopsis>
            <db:type>const_iterator</db:type>
            <db:methodname>operator++</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter/>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>The postfix ++ operator (<db:code>it++</db:code>) advances the iterator to the next item in the container and returns an iterator to the previously current item.</db:para>
      </db:section>
      <db:section>
         <db:title>const_iterator QAssociativeIterable::const_iterator::operator-(int j) const</db:title>
         <db:methodsynopsis>
            <db:type>const_iterator</db:type>
            <db:methodname>operator-</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>j</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Returns an iterator to the item at <db:code role="argument">j</db:code> positions backward from this iterator.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qassociativeiterable-const-iterator.html#operator-2b" xrefstyle="function" annotations="operator+()">operator+()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qassociativeiterable-const-iterator.html#operator--eq" xrefstyle="function" annotations="operator-=()">operator-=()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>const_iterator QAssociativeIterable::const_iterator::operator--(int )</db:title>
         <db:methodsynopsis>
            <db:type>const_iterator</db:type>
            <db:methodname>operator--</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter/>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>The postfix -- operator (<db:code>it--</db:code>) makes the preceding item current and returns an iterator to the previously current item.</db:para>
      </db:section>
   </db:section>
</db:article>
