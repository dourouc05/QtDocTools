<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            version="5.2"
            xml:lang="en">
   <db:info>
      <db:title>QByteArray</db:title>
      <db:abstract>
         <db:para>Array of bytes</db:para>
         <db:note>
            <db:para>All functions in this class are <db:link xlink:href="threads-reentrancy.html">reentrant</db:link>.</db:para>
         </db:note>
      </db:abstract>
      <db:pubdate>2019-07-14+02:00</db:pubdate>
      <db:date>2019-07-14+02:00</db:date>
      <db:productname>Qt</db:productname>
      <db:productnumber>1.2</db:productnumber>
   </db:info>
   <db:classsynopsis>
      <db:ooclass>
         <db:classname>QByteArray</db:classname>
      </db:ooclass>
      <db:classsynopsisinfo role="threadsafety">reentrant</db:classsynopsisinfo>
      <db:classsynopsisinfo role="module">QtCore</db:classsynopsisinfo>
      <db:classsynopsisinfo role="headers">#include &lt;QByteArray&gt;</db:classsynopsisinfo>
      <db:classsynopsisinfo role="definedin">QtCore\qbytearray.h</db:classsynopsisinfo>
      <db:classsynopsisinfo role="group">tools</db:classsynopsisinfo>
      <db:classsynopsisinfo role="group">shared</db:classsynopsisinfo>
      <db:classsynopsisinfo role="group">string-processing</db:classsynopsisinfo>
   </db:classsynopsis>
   <db:section xml:id="details">
      <db:title>Detailed Description</db:title>
      <db:para>The <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> class provides an array of bytes.</db:para>
      <db:para>
         <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> can be used to store both raw bytes (including '\0's) and traditional 8-bit '\0'-terminated strings. Using <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> is much more convenient than using <db:code>const char *</db:code>. Behind the scenes, it always ensures that the data is followed by a '\0' terminator, and uses <db:link xlink:href="implicit-sharing.html" xrefstyle="page" annotations="implicit sharing">implicit sharing</db:link> (copy-on-write) to reduce memory usage and avoid needless copying of data.</db:para>
      <db:para>In addition to <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>, Qt also provides the <db:code><db:link xlink:href="qstring.html" xrefstyle="class" annotations="QString">QString</db:link></db:code> class to store string data. For most purposes, <db:code><db:link xlink:href="qstring.html" xrefstyle="class" annotations="QString">QString</db:link></db:code> is the class you want to use. It stores 16-bit Unicode characters, making it easy to store non-ASCII/non-Latin-1 characters in your application. Furthermore, <db:code><db:link xlink:href="qstring.html" xrefstyle="class" annotations="QString">QString</db:link></db:code> is used throughout in the Qt API. The two main cases where <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> is appropriate are when you need to store raw binary data, and when memory conservation is critical (e.g., with Qt for Embedded Linux).</db:para>
      <db:para>One way to initialize a <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> is simply to pass a <db:code>const char *</db:code> to its constructor. For example, the following code creates a byte array of size 5 containing the data "Hello":</db:para>
      <db:programlisting language="other">QByteArray ba("Hello");</db:programlisting>
      <db:para>Although the <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code> is 5, the byte array also maintains an extra '\0' character at the end so that if a function is used that asks for a pointer to the underlying data (e.g. a call to <db:code><db:link xlink:href="qbytearray.html#data" xrefstyle="function" annotations="data()">data()</db:link></db:code>), the data pointed to is guaranteed to be '\0'-terminated.</db:para>
      <db:para>
         <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> makes a deep copy of the <db:code>const char *</db:code> data, so you can modify it later without experiencing side effects. (If for performance reasons you don't want to take a deep copy of the character data, use <db:code><db:link xlink:href="qbytearray.html#fromRawData" xrefstyle="function" annotations="QByteArray::fromRawData()">QByteArray::fromRawData()</db:link></db:code> instead.)</db:para>
      <db:para>Another approach is to set the size of the array using <db:code><db:link xlink:href="qbytearray.html#resize" xrefstyle="function" annotations="resize()">resize()</db:link></db:code> and to initialize the data byte per byte. <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> uses 0-based indexes, just like C++ arrays. To access the byte at a particular index position, you can use operator[](). On non-const byte arrays, operator[]() returns a reference to a byte that can be used on the left side of an assignment. For example:</db:para>
      <db:programlisting language="other">QByteArray ba;
ba.resize(5);
ba[0] = 0x3c;
ba[1] = 0xb8;
ba[2] = 0x64;
ba[3] = 0x18;
ba[4] = 0xca;</db:programlisting>
      <db:para>For read-only access, an alternative syntax is to use <db:code><db:link xlink:href="qbytearray.html#at" xrefstyle="function" annotations="at()">at()</db:link></db:code>:</db:para>
      <db:programlisting language="other">for (int i = 0; i &lt; ba.size(); ++i) {
    if (ba.at(i) &gt;= 'a' &amp;&amp; ba.at(i) &lt;= 'f')
        cout &lt;&lt; "Found character in range [a-f]" &lt;&lt; endl;
}</db:programlisting>
      <db:para>
         <db:code><db:link xlink:href="qbytearray.html#at" xrefstyle="function" annotations="at()">at()</db:link></db:code> can be faster than operator[](), because it never causes a <db:link xlink:href="implicit-sharing.html#deep-copy" xrefstyle="page" annotations="deep copy">deep copy</db:link> to occur.</db:para>
      <db:para>To extract many bytes at a time, use <db:code><db:link xlink:href="qbytearray.html#left" xrefstyle="function" annotations="left()">left()</db:link></db:code>, <db:code><db:link xlink:href="qbytearray.html#right" xrefstyle="function" annotations="right()">right()</db:link></db:code>, or <db:code><db:link xlink:href="qbytearray.html#mid" xrefstyle="function" annotations="mid()">mid()</db:link></db:code>.</db:para>
      <db:para>A <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> can embed '\0' bytes. The <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code> function always returns the size of the whole array, including embedded '\0' bytes, but excluding the terminating '\0' added by <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>. For example:</db:para>
      <db:programlisting language="other">QByteArray ba1("ca\0r\0t");
ba1.size();                     // Returns 2.
ba1.constData();                // Returns "ca" with terminating \0.

QByteArray ba2("ca\0r\0t", 3);
ba2.size();                     // Returns 3.
ba2.constData();                // Returns "ca\0" with terminating \0.

QByteArray ba3("ca\0r\0t", 4);
ba3.size();                     // Returns 4.
ba3.constData();                // Returns "ca\0r" with terminating \0.

const char cart[] = {'c', 'a', '\0', 'r', '\0', 't'};
QByteArray ba4(QByteArray::fromRawData(cart, 6));
ba4.size();                     // Returns 6.
ba4.constData();                // Returns "ca\0r\0t" without terminating \0.</db:programlisting>
      <db:para>If you want to obtain the length of the data up to and excluding the first '\0' character, call <db:code><db:link xlink:href="qbytearray.html#qstrlen" xrefstyle="function" annotations="qstrlen()">qstrlen()</db:link></db:code> on the byte array.</db:para>
      <db:para>After a call to <db:code><db:link xlink:href="qbytearray.html#resize" xrefstyle="function" annotations="resize()">resize()</db:link></db:code>, newly allocated bytes have undefined values. To set all the bytes to a particular value, call <db:code><db:link xlink:href="qbytearray.html#fill" xrefstyle="function" annotations="fill()">fill()</db:link></db:code>.</db:para>
      <db:para>To obtain a pointer to the actual character data, call <db:code><db:link xlink:href="qbytearray.html#data" xrefstyle="function" annotations="data()">data()</db:link></db:code> or <db:code><db:link xlink:href="qbytearray.html#constData" xrefstyle="function" annotations="constData()">constData()</db:link></db:code>. These functions return a pointer to the beginning of the data. The pointer is guaranteed to remain valid until a non-const function is called on the <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>. It is also guaranteed that the data ends with a '\0' byte unless the <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> was created from a <db:code><db:link xlink:href="qbytearray.html#fromRawData" xrefstyle="function" annotations="fromRawData()">raw data</db:link></db:code>. This '\0' byte is automatically provided by <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> and is not counted in <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>.</db:para>
      <db:para>
         <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> provides the following basic functions for modifying the byte data: <db:code><db:link xlink:href="qbytearray.html#append" xrefstyle="function" annotations="append()">append()</db:link></db:code>, <db:code><db:link xlink:href="qbytearray.html#prepend" xrefstyle="function" annotations="prepend()">prepend()</db:link></db:code>, <db:code><db:link xlink:href="qbytearray.html#insert" xrefstyle="function" annotations="insert()">insert()</db:link></db:code>, <db:code><db:link xlink:href="qbytearray.html#replace" xrefstyle="function" annotations="replace()">replace()</db:link></db:code>, and <db:code><db:link xlink:href="qbytearray.html#remove" xrefstyle="function" annotations="remove()">remove()</db:link></db:code>. For example:</db:para>
      <db:programlisting language="other">QByteArray x("and");
x.prepend("rock ");         // x == "rock and"
x.append(" roll");          // x == "rock and roll"
x.replace(5, 3, "&amp;");       // x == "rock &amp; roll"</db:programlisting>
      <db:para>The <db:code><db:link xlink:href="qbytearray.html#replace" xrefstyle="function" annotations="replace()">replace()</db:link></db:code> and <db:code><db:link xlink:href="qbytearray.html#remove" xrefstyle="function" annotations="remove()">remove()</db:link></db:code> functions' first two arguments are the position from which to start erasing and the number of bytes that should be erased.</db:para>
      <db:para>When you <db:code><db:link xlink:href="qbytearray.html#append" xrefstyle="function" annotations="append()">append()</db:link></db:code> data to a non-empty array, the array will be reallocated and the new data copied to it. You can avoid this behavior by calling <db:code><db:link xlink:href="qbytearray.html#reserve" xrefstyle="function" annotations="reserve()">reserve()</db:link></db:code>, which preallocates a certain amount of memory. You can also call <db:code><db:link xlink:href="qbytearray.html#capacity" xrefstyle="function" annotations="capacity()">capacity()</db:link></db:code> to find out how much memory <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> actually allocated. Data appended to an empty array is not copied.</db:para>
      <db:para>A frequent requirement is to remove whitespace characters from a byte array ('\n', '\t', ' ', etc.). If you want to remove whitespace from both ends of a <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>, use <db:code><db:link xlink:href="qbytearray.html#trimmed" xrefstyle="function" annotations="trimmed()">trimmed()</db:link></db:code>. If you want to remove whitespace from both ends and replace multiple consecutive whitespaces with a single space character within the byte array, use <db:code><db:link xlink:href="qbytearray.html#simplified" xrefstyle="function" annotations="simplified()">simplified()</db:link></db:code>.</db:para>
      <db:para>If you want to find all occurrences of a particular character or substring in a <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>, use <db:code><db:link xlink:href="qbytearray.html#indexOf" xrefstyle="function" annotations="indexOf()">indexOf()</db:link></db:code> or <db:code><db:link xlink:href="qbytearray.html#lastIndexOf" xrefstyle="function" annotations="lastIndexOf()">lastIndexOf()</db:link></db:code>. The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the character or substring if they find it; otherwise, they return -1. For example, here's a typical loop that finds all occurrences of a particular substring:</db:para>
      <db:programlisting language="other">QByteArray ba("We must be &lt;b&gt;bold&lt;/b&gt;, very &lt;b&gt;bold&lt;/b&gt;");
int j = 0;
while ((j = ba.indexOf("&lt;b&gt;", j)) != -1) {
    cout &lt;&lt; "Found &lt;b&gt; tag at index position " &lt;&lt; j &lt;&lt; endl;
    ++j;
}</db:programlisting>
      <db:para>If you simply want to check whether a <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> contains a particular character or substring, use <db:code><db:link xlink:href="qbytearray.html#contains" xrefstyle="function" annotations="contains()">contains()</db:link></db:code>. If you want to find out how many times a particular character or substring occurs in the byte array, use <db:code><db:link xlink:href="qbytearray.html#count-3" xrefstyle="function" annotations="count()">count()</db:link></db:code>. If you want to replace all occurrences of a particular value with another, use one of the two-parameter <db:code><db:link xlink:href="qbytearray.html#replace" xrefstyle="function" annotations="replace()">replace()</db:link></db:code> overloads.</db:para>
      <db:para>
         <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>s can be compared using overloaded operators such as operator&lt;(), operator&lt;=(), operator==(), operator&gt;=(), and so on. The comparison is based exclusively on the numeric values of the characters and is very fast, but is not what a human would expect. <db:code><db:link xlink:href="qstring.html#localeAwareCompare" xrefstyle="function" annotations="QString::localeAwareCompare()">QString::localeAwareCompare()</db:link></db:code> is a better choice for sorting user-interface strings.</db:para>
      <db:para>For historical reasons, <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> distinguishes between a null byte array and an empty byte array. A <db:emphasis>null</db:emphasis> byte array is a byte array that is initialized using <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>'s default constructor or by passing (const char *)0 to the constructor. An <db:emphasis>empty</db:emphasis> byte array is any byte array with size 0. A null byte array is always empty, but an empty byte array isn't necessarily null:</db:para>
      <db:programlisting language="other">QByteArray().isNull();          // returns true
QByteArray().isEmpty();         // returns true

QByteArray("").isNull();        // returns false
QByteArray("").isEmpty();       // returns true

QByteArray("abc").isNull();     // returns false
QByteArray("abc").isEmpty();    // returns false</db:programlisting>
      <db:para>All functions except <db:code><db:link xlink:href="qbytearray.html#isNull" xrefstyle="function" annotations="isNull()">isNull()</db:link></db:code> treat null byte arrays the same as empty byte arrays. For example, <db:code><db:link xlink:href="qbytearray.html#data" xrefstyle="function" annotations="data()">data()</db:link></db:code> returns a pointer to a '\0' character for a null byte array (<db:emphasis>not</db:emphasis> a null pointer), and <db:code><db:link xlink:href="qbytearray.html#QByteArray" xrefstyle="function" annotations="QByteArray()">QByteArray()</db:link></db:code> compares equal to <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>(""). We recommend that you always use <db:code><db:link xlink:href="qbytearray.html#isEmpty" xrefstyle="function" annotations="isEmpty()">isEmpty()</db:link></db:code> and avoid <db:code><db:link xlink:href="qbytearray.html#isNull" xrefstyle="function" annotations="isNull()">isNull()</db:link></db:code>.</db:para>
      <db:section xml:id="notes-on-locale">
         <db:title>Notes on Locale</db:title>
      </db:section>
      <db:section xml:id="number-string-conversions">
         <db:title>Number-String Conversions</db:title>
         <db:para>Functions that perform conversions between numeric data types and strings are performed in the C locale, irrespective of the user's locale settings. Use <db:code><db:link xlink:href="qstring.html" xrefstyle="class" annotations="QString">QString</db:link></db:code> to perform locale-aware conversions between numbers and strings.</db:para>
      </db:section>
      <db:section xml:id="a8-bit-character-comparisons">
         <db:title>8-bit Character Comparisons</db:title>
         <db:para>In <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>, the notion of uppercase and lowercase and of which character is greater than or less than another character is locale dependent. This affects functions that support a case insensitive option or that compare or lowercase or uppercase their arguments. Case insensitive operations and comparisons will be accurate if both strings contain only ASCII characters. (If <db:code>$LC_CTYPE</db:code> is set, most Unix systems do "the right thing".) Functions that this affects include <db:code><db:link xlink:href="qbytearray.html#contains" xrefstyle="function" annotations="contains()">contains()</db:link></db:code>, <db:code><db:link xlink:href="qbytearray.html#indexOf" xrefstyle="function" annotations="indexOf()">indexOf()</db:link></db:code>, <db:code><db:link xlink:href="qbytearray.html#lastIndexOf" xrefstyle="function" annotations="lastIndexOf()">lastIndexOf()</db:link></db:code>, operator&lt;(), operator&lt;=(), operator&gt;(), operator&gt;=(), <db:code><db:link xlink:href="qbytearray.html#isLower" xrefstyle="function" annotations="isLower()">isLower()</db:link></db:code>, <db:code><db:link xlink:href="qbytearray.html#isUpper" xrefstyle="function" annotations="isUpper()">isUpper()</db:link></db:code>, <db:code><db:link xlink:href="qbytearray.html#toLower" xrefstyle="function" annotations="toLower()">toLower()</db:link></db:code> and <db:code><db:link xlink:href="qbytearray.html#toUpper" xrefstyle="function" annotations="toUpper()">toUpper()</db:link></db:code>.</db:para>
         <db:para>This issue does not apply to <db:code><db:link xlink:href="qstring.html" xrefstyle="class" annotations="QString">QString</db:link></db:code>s since they represent characters using Unicode.</db:para>
      </db:section>
      <db:section>
         <db:title>See Also</db:title>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qstring.html" xrefstyle="class" annotations="QString">QString</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbitarray.html" xrefstyle="class" annotations="QBitArray">QBitArray</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
   </db:section>
   <db:section>
      <db:title>Member Function Documentation</db:title>
      <db:section xml:id="QByteArray">
         <db:title>QByteArray()</db:title>
         <db:constructorsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:methodname>QByteArray</db:methodname>
            <db:void/>
         </db:constructorsynopsis>
         <db:para>Constructs an empty byte array.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#isEmpty" xrefstyle="function" annotations="isEmpty()">isEmpty()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="QByteArray">
         <db:title>QByteArray(const QByteArray &amp;other)</db:title>
         <db:constructorsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:methodname>QByteArray</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>other</db:parameter>
            </db:methodparam>
         </db:constructorsynopsis>
         <db:para>Constructs a copy of <db:code role="argument">other</db:code>.</db:para>
         <db:para>This operation takes <db:link xlink:href="containers.html#constant-time" xrefstyle="page" annotations="constant time">constant time</db:link>, because <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> is <db:link xlink:href="implicit-sharing.html" xrefstyle="page" annotations="implicitly shared">implicitly shared</db:link>. This makes returning a <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), taking <db:link xlink:href="containers.html#linear-time" xrefstyle="page" annotations="linear time">linear time</db:link>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-eq" xrefstyle="function" annotations="operator=()">operator=()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="QByteArray-1">
         <db:title>QByteArray(const char *data, int size)</db:title>
         <db:constructorsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:methodname>QByteArray</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>data</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>size</db:parameter>
               <db:initializer>-1</db:initializer>
            </db:methodparam>
         </db:constructorsynopsis>
         <db:para>Constructs a byte array containing the first <db:code role="argument">size</db:code> bytes of array <db:code role="argument">data</db:code>.</db:para>
         <db:para>If <db:code role="argument">data</db:code> is 0, a null byte array is constructed.</db:para>
         <db:para>If <db:code role="argument">size</db:code> is negative, <db:code role="argument">data</db:code> is assumed to point to a '\0'-terminated string and its length is determined dynamically. The terminating \0 character is not considered part of the byte array.</db:para>
         <db:para>
            <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> makes a deep copy of the string data.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData" xrefstyle="function" annotations="fromRawData()">fromRawData()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="QByteArray-2">
         <db:title>QByteArray(int size, char ch)</db:title>
         <db:constructorsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:methodname>QByteArray</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>size</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
         </db:constructorsynopsis>
         <db:para>Constructs a byte array of size <db:code role="argument">size</db:code> with every byte set to character <db:code role="argument">ch</db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fill" xrefstyle="function" annotations="fill()">fill()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="dtor.QByteArray">
         <db:title>~QByteArray()</db:title>
         <db:destructorsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:methodname>~QByteArray</db:methodname>
            <db:void/>
         </db:destructorsynopsis>
         <db:para>Destroys the byte array.</db:para>
      </db:section>
      <db:section xml:id="toCFData">
         <db:title>CFDataRef toCFData() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>CFDataRef</db:type>
            <db:methodname>toCFData</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Creates a CFData from a <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>. The caller owns the CFData object and is responsible for releasing it.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toRawCFData" xrefstyle="function" annotations="toRawCFData()">toRawCFData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromCFData" xrefstyle="function" annotations="fromCFData()">fromCFData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawCFData" xrefstyle="function" annotations="fromRawCFData()">fromRawCFData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData" xrefstyle="function" annotations="fromRawData()">fromRawData()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.3.</db:para>
      </db:section>
      <db:section xml:id="toRawCFData">
         <db:title>CFDataRef toRawCFData() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>CFDataRef</db:type>
            <db:methodname>toRawCFData</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Constructs a CFData that uses the bytes of the <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>.</db:para>
         <db:para>The <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>'s bytes are not copied.</db:para>
         <db:para>The caller guarantees that the <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> will not be deleted or modified as long as this CFData object exists.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toCFData" xrefstyle="function" annotations="toCFData()">toCFData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawCFData" xrefstyle="function" annotations="fromRawCFData()">fromRawCFData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromCFData" xrefstyle="function" annotations="fromCFData()">fromCFData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData" xrefstyle="function" annotations="fromRawData()">fromRawData()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.3.</db:para>
      </db:section>
      <db:section xml:id="toNSData">
         <db:title>NSData * toNSData() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>NSData *</db:type>
            <db:methodname>toNSData</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Creates a NSData from a <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>. The NSData object is autoreleased.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromNSData" xrefstyle="function" annotations="fromNSData()">fromNSData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawNSData" xrefstyle="function" annotations="fromRawNSData()">fromRawNSData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData" xrefstyle="function" annotations="fromRawData()">fromRawData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toRawNSData" xrefstyle="function" annotations="toRawNSData()">toRawNSData()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.3.</db:para>
      </db:section>
      <db:section xml:id="toRawNSData">
         <db:title>NSData * toRawNSData() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>NSData *</db:type>
            <db:methodname>toRawNSData</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Constructs a NSData that uses the bytes of the <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>.</db:para>
         <db:para>The <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>'s bytes are not copied.</db:para>
         <db:para>The caller guarantees that the <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> will not be deleted or modified as long as this NSData object exists.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawNSData" xrefstyle="function" annotations="fromRawNSData()">fromRawNSData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromNSData" xrefstyle="function" annotations="fromNSData()">fromNSData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData" xrefstyle="function" annotations="fromRawData()">fromRawData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toNSData" xrefstyle="function" annotations="toNSData()">toNSData()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.3.</db:para>
      </db:section>
      <db:section xml:id="append-1">
         <db:title>QByteArray &amp; append(char ch)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>append</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Appends the character <db:code role="argument">ch</db:code> to this byte array.</db:para>
      </db:section>
      <db:section xml:id="append">
         <db:title>QByteArray &amp; append(const QByteArray &amp;ba)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>append</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>ba</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Appends the byte array <db:code role="argument">ba</db:code> onto the end of this byte array.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray x("free");
QByteArray y("dom");
x.append(y);
// x == "freedom"</db:programlisting>
         <db:para>This is the same as insert(<db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>, <db:code role="argument">ba</db:code>).</db:para>
         <db:para>Note: <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> is an <db:link xlink:href="implicit-sharing.html" xrefstyle="page" annotations="implicitly shared">implicitly shared</db:link> class. Consequently, if you append to an empty byte array, then the byte array will just share the data held in <db:code role="argument">ba</db:code>. In this case, no copying of data is done, taking <db:link xlink:href="containers.html#constant-time" xrefstyle="page" annotations="constant time">constant time</db:link>. If a shared instance is modified, it will be copied (copy-on-write), taking <db:link xlink:href="containers.html#linear-time" xrefstyle="page" annotations="linear time">linear time</db:link>.</db:para>
         <db:para>If the byte array being appended to is not empty, a deep copy of the data is performed, taking <db:link xlink:href="containers.html#linear-time" xrefstyle="page" annotations="linear time">linear time</db:link>.</db:para>
         <db:para>This operation typically does not suffer from allocation overhead, because <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> preallocates extra space at the end of the data so that it may grow without reallocating for each append operation.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-2b-eq" xrefstyle="function" annotations="operator+=()">operator+=()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#prepend" xrefstyle="function" annotations="prepend()">prepend()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#insert" xrefstyle="function" annotations="insert()">insert()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="append-5">
         <db:title>QByteArray &amp; append(const QString &amp;str)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>append</db:methodname>
            <db:methodparam>
               <db:type>const QString &amp;</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Appends the string <db:code role="argument">str</db:code> to this byte array. The Unicode data is converted into 8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code>.</db:para>
         <db:para>You can disable this function by defining <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code> (or <db:code><db:link xlink:href="qstring.html#toLatin1" xrefstyle="function" annotations="QString::toLatin1()">QString::toLatin1()</db:link></db:code> or <db:code><db:link xlink:href="qstring.html#toLocal8Bit" xrefstyle="function" annotations="QString::toLocal8Bit()">QString::toLocal8Bit()</db:link></db:code>) explicitly if you want to convert the data to <db:code>const char *</db:code>.</db:para>
      </db:section>
      <db:section xml:id="append-3">
         <db:title>QByteArray &amp; append(const char *str)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>append</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Appends the string <db:code role="argument">str</db:code> to this byte array.</db:para>
      </db:section>
      <db:section xml:id="append-4">
         <db:title>QByteArray &amp; append(const char *str, int len)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>append</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>len</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This function overloads <db:code><db:link xlink:href="qbytearray.html#append" xrefstyle="function" annotations="append()">append()</db:link></db:code>.</db:para>
         <db:para>Appends the first <db:code role="argument">len</db:code> characters of the string <db:code role="argument">str</db:code> to this byte array and returns a reference to this byte array.</db:para>
         <db:para>If <db:code role="argument">len</db:code> is negative, the length of the string will be determined automatically using <db:code><db:link xlink:href="qbytearray.html#qstrlen" xrefstyle="function" annotations="qstrlen()">qstrlen()</db:link></db:code>. If <db:code role="argument">len</db:code> is zero or <db:code role="argument">str</db:code> is null, nothing is appended to the byte array. Ensure that <db:code role="argument">len</db:code> is <db:emphasis>not</db:emphasis> longer than <db:code role="argument">str</db:code>.</db:para>
      </db:section>
      <db:section xml:id="append-2">
         <db:title>QByteArray &amp; append(int count, char ch)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>append</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>count</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Appends <db:code role="argument">count</db:code> copies of character <db:code role="argument">ch</db:code> to this byte array and returns a reference to this byte array.</db:para>
         <db:para>If <db:code role="argument">count</db:code> is negative or zero nothing is appended to the byte array.</db:para>
         <db:para>This property was introduced in Qt 5.7.</db:para>
      </db:section>
      <db:section xml:id="fill">
         <db:title>QByteArray &amp; fill(char ch, int size)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>fill</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>size</db:parameter>
               <db:initializer>-1</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Sets every byte in the byte array to character <db:code role="argument">ch</db:code>. If <db:code role="argument">size</db:code> is different from -1 (the default), the byte array is resized to size <db:code role="argument">size</db:code> beforehand.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray ba("Istambul");
ba.fill('o');
// ba == "oooooooo"

ba.fill('X', 2);
// ba == "XX"</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#resize" xrefstyle="function" annotations="resize()">resize()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="insert-1">
         <db:title>QByteArray &amp; insert(int i, char ch)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>insert</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>i</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Inserts character <db:code role="argument">ch</db:code> at index position <db:code role="argument">i</db:code> in the byte array. If <db:code role="argument">i</db:code> is greater than <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>, the array is first extended using <db:code><db:link xlink:href="qbytearray.html#resize" xrefstyle="function" annotations="resize()">resize()</db:link></db:code>.</db:para>
      </db:section>
      <db:section xml:id="insert">
         <db:title>QByteArray &amp; insert(int i, const QByteArray &amp;ba)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>insert</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>i</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>ba</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Inserts the byte array <db:code role="argument">ba</db:code> at index position <db:code role="argument">i</db:code> and returns a reference to this byte array.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray ba("Meal");
ba.insert(1, QByteArray("ontr"));
// ba == "Montreal"</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#append" xrefstyle="function" annotations="append()">append()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#prepend" xrefstyle="function" annotations="prepend()">prepend()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#replace" xrefstyle="function" annotations="replace()">replace()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#remove" xrefstyle="function" annotations="remove()">remove()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="insert-5">
         <db:title>QByteArray &amp; insert(int i, const QString &amp;str)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>insert</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>i</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QString &amp;</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Inserts the string <db:code role="argument">str</db:code> at index position <db:code role="argument">i</db:code> in the byte array. The Unicode data is converted into 8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code>.</db:para>
         <db:para>If <db:code role="argument">i</db:code> is greater than <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>, the array is first extended using <db:code><db:link xlink:href="qbytearray.html#resize" xrefstyle="function" annotations="resize()">resize()</db:link></db:code>.</db:para>
         <db:para>You can disable this function by defining <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code> (or <db:code><db:link xlink:href="qstring.html#toLatin1" xrefstyle="function" annotations="QString::toLatin1()">QString::toLatin1()</db:link></db:code> or <db:code><db:link xlink:href="qstring.html#toLocal8Bit" xrefstyle="function" annotations="QString::toLocal8Bit()">QString::toLocal8Bit()</db:link></db:code>) explicitly if you want to convert the data to <db:code>const char *</db:code>.</db:para>
      </db:section>
      <db:section xml:id="insert-3">
         <db:title>QByteArray &amp; insert(int i, const char *str)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>insert</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>i</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Inserts the string <db:code role="argument">str</db:code> at position <db:code role="argument">i</db:code> in the byte array.</db:para>
         <db:para>If <db:code role="argument">i</db:code> is greater than <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>, the array is first extended using <db:code><db:link xlink:href="qbytearray.html#resize" xrefstyle="function" annotations="resize()">resize()</db:link></db:code>.</db:para>
      </db:section>
      <db:section xml:id="insert-4">
         <db:title>QByteArray &amp; insert(int i, const char *str, int len)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>insert</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>i</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>len</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Inserts <db:code role="argument">len</db:code> bytes of the string <db:code role="argument">str</db:code> at position <db:code role="argument">i</db:code> in the byte array.</db:para>
         <db:para>If <db:code role="argument">i</db:code> is greater than <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>, the array is first extended using <db:code><db:link xlink:href="qbytearray.html#resize" xrefstyle="function" annotations="resize()">resize()</db:link></db:code>.</db:para>
         <db:para>This property was introduced in Qt 4.6.</db:para>
      </db:section>
      <db:section xml:id="insert-2">
         <db:title>QByteArray &amp; insert(int i, int count, char ch)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>insert</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>i</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>count</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Inserts <db:code role="argument">count</db:code> copies of character <db:code role="argument">ch</db:code> at index position <db:code role="argument">i</db:code> in the byte array.</db:para>
         <db:para>If <db:code role="argument">i</db:code> is greater than <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>, the array is first extended using <db:code><db:link xlink:href="qbytearray.html#resize" xrefstyle="function" annotations="resize()">resize()</db:link></db:code>.</db:para>
         <db:para>This property was introduced in Qt 5.7.</db:para>
      </db:section>
      <db:section xml:id="operator-2b-eq-1">
         <db:title>QByteArray &amp; operator+=(char ch)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>operator+=</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Appends the character <db:code role="argument">ch</db:code> onto the end of this byte array and returns a reference to this byte array.</db:para>
      </db:section>
      <db:section xml:id="operator-2b-eq">
         <db:title>QByteArray &amp; operator+=(const QByteArray &amp;ba)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>operator+=</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>ba</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Appends the byte array <db:code role="argument">ba</db:code> onto the end of this byte array and returns a reference to this byte array.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray x("free");
QByteArray y("dom");
x += y;
// x == "freedom"</db:programlisting>
         <db:para>Note: <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> is an <db:link xlink:href="implicit-sharing.html" xrefstyle="page" annotations="implicitly shared">implicitly shared</db:link> class. Consequently, if you append to an empty byte array, then the byte array will just share the data held in <db:code role="argument">ba</db:code>. In this case, no copying of data is done, taking <db:link xlink:href="containers.html#constant-time" xrefstyle="page" annotations="constant time">constant time</db:link>. If a shared instance is modified, it will be copied (copy-on-write), taking <db:link xlink:href="containers.html#linear-time" xrefstyle="page" annotations="linear time">linear time</db:link>.</db:para>
         <db:para>If the byte array being appended to is not empty, a deep copy of the data is performed, taking <db:link xlink:href="containers.html#linear-time" xrefstyle="page" annotations="linear time">linear time</db:link>.</db:para>
         <db:para>This operation typically does not suffer from allocation overhead, because <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> preallocates extra space at the end of the data so that it may grow without reallocating for each append operation.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#append" xrefstyle="function" annotations="append()">append()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#prepend" xrefstyle="function" annotations="prepend()">prepend()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="operator-2b-eq-3">
         <db:title>QByteArray &amp; operator+=(const QString &amp;str)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>operator+=</db:methodname>
            <db:methodparam>
               <db:type>const QString &amp;</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Appends the string <db:code role="argument">str</db:code> onto the end of this byte array and returns a reference to this byte array. The Unicode data is converted into 8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code>.</db:para>
         <db:para>You can disable this function by defining <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code> (or <db:code><db:link xlink:href="qstring.html#toLatin1" xrefstyle="function" annotations="QString::toLatin1()">QString::toLatin1()</db:link></db:code> or <db:code><db:link xlink:href="qstring.html#toLocal8Bit" xrefstyle="function" annotations="QString::toLocal8Bit()">QString::toLocal8Bit()</db:link></db:code>) explicitly if you want to convert the data to <db:code>const char *</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-2b-eq-2">
         <db:title>QByteArray &amp; operator+=(const char *str)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>operator+=</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Appends the string <db:code role="argument">str</db:code> onto the end of this byte array and returns a reference to this byte array.</db:para>
      </db:section>
      <db:section xml:id="operator-eq-2">
         <db:title>QByteArray &amp; operator=(QByteArray &amp;&amp;other)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>operator=</db:methodname>
            <db:methodparam>
               <db:type>QByteArray &amp;&amp;</db:type>
               <db:parameter>other</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Move-assigns <db:code role="argument">other</db:code> to this <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> instance.</db:para>
         <db:para>This property was introduced in Qt 5.2.</db:para>
      </db:section>
      <db:section xml:id="operator-eq">
         <db:title>QByteArray &amp; operator=(const QByteArray &amp;other)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>operator=</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>other</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Assigns <db:code role="argument">other</db:code> to this byte array and returns a reference to this byte array.</db:para>
      </db:section>
      <db:section xml:id="operator-eq-1">
         <db:title>QByteArray &amp; operator=(const char *str)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>operator=</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Assigns <db:code role="argument">str</db:code> to this byte array.</db:para>
      </db:section>
      <db:section xml:id="prepend-1">
         <db:title>QByteArray &amp; prepend(char ch)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>prepend</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Prepends the character <db:code role="argument">ch</db:code> to this byte array.</db:para>
      </db:section>
      <db:section xml:id="prepend">
         <db:title>QByteArray &amp; prepend(const QByteArray &amp;ba)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>prepend</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>ba</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Prepends the byte array <db:code role="argument">ba</db:code> to this byte array and returns a reference to this byte array.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray x("ship");
QByteArray y("air");
x.prepend(y);
// x == "airship"</db:programlisting>
         <db:para>This is the same as insert(0, <db:code role="argument">ba</db:code>).</db:para>
         <db:para>Note: <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> is an <db:link xlink:href="implicit-sharing.html" xrefstyle="page" annotations="implicitly shared">implicitly shared</db:link> class. Consequently, if you prepend to an empty byte array, then the byte array will just share the data held in <db:code role="argument">ba</db:code>. In this case, no copying of data is done, taking <db:link xlink:href="containers.html#constant-time" xrefstyle="page" annotations="constant time">constant time</db:link>. If a shared instance is modified, it will be copied (copy-on-write), taking <db:link xlink:href="containers.html#linear-time" xrefstyle="page" annotations="linear time">linear time</db:link>.</db:para>
         <db:para>If the byte array being prepended to is not empty, a deep copy of the data is performed, taking <db:link xlink:href="containers.html#linear-time" xrefstyle="page" annotations="linear time">linear time</db:link>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#append" xrefstyle="function" annotations="append()">append()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#insert" xrefstyle="function" annotations="insert()">insert()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="prepend-3">
         <db:title>QByteArray &amp; prepend(const char *str)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>prepend</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Prepends the string <db:code role="argument">str</db:code> to this byte array.</db:para>
      </db:section>
      <db:section xml:id="prepend-4">
         <db:title>QByteArray &amp; prepend(const char *str, int len)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>prepend</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>len</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Prepends <db:code role="argument">len</db:code> bytes of the string <db:code role="argument">str</db:code> to this byte array.</db:para>
         <db:para>This property was introduced in Qt 4.6.</db:para>
      </db:section>
      <db:section xml:id="prepend-2">
         <db:title>QByteArray &amp; prepend(int count, char ch)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>prepend</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>count</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Prepends <db:code role="argument">count</db:code> copies of character <db:code role="argument">ch</db:code> to this byte array.</db:para>
         <db:para>This property was introduced in Qt 5.7.</db:para>
      </db:section>
      <db:section xml:id="remove">
         <db:title>QByteArray &amp; remove(int pos, int len)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>remove</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>pos</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>len</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Removes <db:code role="argument">len</db:code> bytes from the array, starting at index position <db:code role="argument">pos</db:code>, and returns a reference to the array.</db:para>
         <db:para>If <db:code role="argument">pos</db:code> is out of range, nothing happens. If <db:code role="argument">pos</db:code> is valid, but <db:code role="argument">pos</db:code> + <db:code role="argument">len</db:code> is larger than the size of the array, the array is truncated at position <db:code role="argument">pos</db:code>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray ba("Montreal");
ba.remove(1, 4);
// ba == "Meal"</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#insert" xrefstyle="function" annotations="insert()">insert()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#replace" xrefstyle="function" annotations="replace()">replace()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="replace-10">
         <db:title>QByteArray &amp; replace(char before, char after)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>replace</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>before</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>after</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the character <db:code role="argument">before</db:code> with the character <db:code role="argument">after</db:code>.</db:para>
      </db:section>
      <db:section xml:id="replace-4">
         <db:title>QByteArray &amp; replace(char before, const QByteArray &amp;after)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>replace</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>before</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>after</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the character <db:code role="argument">before</db:code> with the byte array <db:code role="argument">after</db:code>.</db:para>
      </db:section>
      <db:section xml:id="replace-12">
         <db:title>QByteArray &amp; replace(char before, const QString &amp;after)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>replace</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>before</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QString &amp;</db:type>
               <db:parameter>after</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the character <db:code role="argument">before</db:code> with the string <db:code role="argument">after</db:code>. The Unicode data is converted into 8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code>.</db:para>
         <db:para>You can disable this function by defining <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code> (or <db:code><db:link xlink:href="qstring.html#toLatin1" xrefstyle="function" annotations="QString::toLatin1()">QString::toLatin1()</db:link></db:code> or <db:code><db:link xlink:href="qstring.html#toLocal8Bit" xrefstyle="function" annotations="QString::toLocal8Bit()">QString::toLocal8Bit()</db:link></db:code>) explicitly if you want to convert the data to <db:code>const char *</db:code>.</db:para>
      </db:section>
      <db:section xml:id="replace-3">
         <db:title>QByteArray &amp; replace(char before, const char *after)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>replace</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>before</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>after</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the character <db:code role="argument">before</db:code> with the string <db:code role="argument">after</db:code>.</db:para>
      </db:section>
      <db:section xml:id="replace-7">
         <db:title>QByteArray &amp; replace(const QByteArray &amp;before, const QByteArray &amp;after)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>replace</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>before</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>after</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the byte array <db:code role="argument">before</db:code> with the byte array <db:code role="argument">after</db:code>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray ba("colour behaviour flavour neighbour");
ba.replace(QByteArray("ou"), QByteArray("o"));
// ba == "color behavior flavor neighbor"</db:programlisting>
      </db:section>
      <db:section xml:id="replace-8">
         <db:title>QByteArray &amp; replace(const QByteArray &amp;before, const char *after)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>replace</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>before</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>after</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the byte array <db:code role="argument">before</db:code> with the string <db:code role="argument">after</db:code>.</db:para>
      </db:section>
      <db:section xml:id="replace-13">
         <db:title>QByteArray &amp; replace(const QString &amp;before, const QByteArray &amp;after)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>replace</db:methodname>
            <db:methodparam>
               <db:type>const QString &amp;</db:type>
               <db:parameter>before</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>after</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the string <db:code role="argument">before</db:code> with the byte array <db:code role="argument">after</db:code>. The Unicode data is converted into 8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code>.</db:para>
         <db:para>You can disable this function by defining <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code> (or <db:code><db:link xlink:href="qstring.html#toLatin1" xrefstyle="function" annotations="QString::toLatin1()">QString::toLatin1()</db:link></db:code> or <db:code><db:link xlink:href="qstring.html#toLocal8Bit" xrefstyle="function" annotations="QString::toLocal8Bit()">QString::toLocal8Bit()</db:link></db:code>) explicitly if you want to convert the data to <db:code>const char *</db:code>.</db:para>
      </db:section>
      <db:section xml:id="replace-11">
         <db:title>QByteArray &amp; replace(const QString &amp;before, const char *after)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>replace</db:methodname>
            <db:methodparam>
               <db:type>const QString &amp;</db:type>
               <db:parameter>before</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>after</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the string <db:code role="argument">before</db:code> with the string <db:code role="argument">after</db:code>.</db:para>
      </db:section>
      <db:section xml:id="replace-9">
         <db:title>QByteArray &amp; replace(const char *before, const QByteArray &amp;after)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>replace</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>before</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>after</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the string <db:code role="argument">before</db:code> with the byte array <db:code role="argument">after</db:code>.</db:para>
      </db:section>
      <db:section xml:id="replace-5">
         <db:title>QByteArray &amp; replace(const char *before, const char *after)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>replace</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>before</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>after</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the string <db:code role="argument">before</db:code> with the string <db:code role="argument">after</db:code>.</db:para>
      </db:section>
      <db:section xml:id="replace-6">
         <db:title>QByteArray &amp; replace(const char *before, int bsize, const char *after, int asize)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>replace</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>before</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>bsize</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>after</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>asize</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces every occurrence of the string <db:code role="argument">before</db:code> with the string <db:code role="argument">after</db:code>. Since the sizes of the strings are given by <db:code role="argument">bsize</db:code> and <db:code role="argument">asize</db:code>, they may contain zero characters and do not need to be '\0'-terminated.</db:para>
      </db:section>
      <db:section xml:id="replace">
         <db:title>QByteArray &amp; replace(int pos, int len, const QByteArray &amp;after)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>replace</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>pos</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>len</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>after</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Replaces <db:code role="argument">len</db:code> bytes from index position <db:code role="argument">pos</db:code> with the byte array <db:code role="argument">after</db:code>, and returns a reference to this byte array.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray x("Say yes!");
QByteArray y("no");
x.replace(4, 3, y);
// x == "Say no!"</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#insert" xrefstyle="function" annotations="insert()">insert()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#remove" xrefstyle="function" annotations="remove()">remove()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="replace-1">
         <db:title>QByteArray &amp; replace(int pos, int len, const char *after)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>replace</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>pos</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>len</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>after</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces <db:code role="argument">len</db:code> bytes from index position <db:code role="argument">pos</db:code> with the '\0'-terminated string <db:code role="argument">after</db:code>.</db:para>
         <db:para>Notice: this can change the length of the byte array.</db:para>
      </db:section>
      <db:section xml:id="replace-2">
         <db:title>QByteArray &amp; replace(int pos, int len, const char *after, int alen)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>replace</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>pos</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>len</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>after</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>alen</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Replaces <db:code role="argument">len</db:code> bytes from index position <db:code role="argument">pos</db:code> with <db:code role="argument">alen</db:code> bytes from the string <db:code role="argument">after</db:code>. <db:code role="argument">after</db:code> is allowed to have '\0' characters.</db:para>
         <db:para>This property was introduced in Qt 4.7.</db:para>
      </db:section>
      <db:section xml:id="setNum-7">
         <db:title>QByteArray &amp; setNum(double n, char f, int prec)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>setNum</db:methodname>
            <db:methodparam>
               <db:type>double</db:type>
               <db:parameter>n</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>f</db:parameter>
               <db:initializer>'g'</db:initializer>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>prec</db:parameter>
               <db:initializer>6</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Sets the byte array to the printed value of <db:code role="argument">n</db:code>, formatted in format <db:code role="argument">f</db:code> with precision <db:code role="argument">prec</db:code>, and returns a reference to the byte array.</db:para>
         <db:para>The format <db:code role="argument">f</db:code> can be any of the following:</db:para>
         <db:informaltable>
            <db:thead>
               <db:tr>
                  <db:th>
                     <db:para>Format</db:para>
                  </db:th>
                  <db:th>
                     <db:para>Meaning</db:para>
                  </db:th>
               </db:tr>
            </db:thead>
            <db:tr>
               <db:td>
                  <db:para>
                     <db:code>e</db:code>
                  </db:para>
               </db:td>
               <db:td>
                  <db:para>format as [-]9.9e[+|-]999</db:para>
               </db:td>
            </db:tr>
            <db:tr>
               <db:td>
                  <db:para>
                     <db:code>E</db:code>
                  </db:para>
               </db:td>
               <db:td>
                  <db:para>format as [-]9.9E[+|-]999</db:para>
               </db:td>
            </db:tr>
            <db:tr>
               <db:td>
                  <db:para>
                     <db:code>f</db:code>
                  </db:para>
               </db:td>
               <db:td>
                  <db:para>format as [-]9.9</db:para>
               </db:td>
            </db:tr>
            <db:tr>
               <db:td>
                  <db:para>
                     <db:code>g</db:code>
                  </db:para>
               </db:td>
               <db:td>
                  <db:para>use <db:code>e</db:code> or <db:code>f</db:code> format, whichever is the most concise</db:para>
               </db:td>
            </db:tr>
            <db:tr>
               <db:td>
                  <db:para>
                     <db:code>G</db:code>
                  </db:para>
               </db:td>
               <db:td>
                  <db:para>use <db:code>E</db:code> or <db:code>f</db:code> format, whichever is the most concise</db:para>
               </db:td>
            </db:tr>
         </db:informaltable>
         <db:para>With 'e', 'E', and 'f', <db:code role="argument">prec</db:code> is the number of digits after the decimal point. With 'g' and 'G', <db:code role="argument">prec</db:code> is the maximum number of significant digits (trailing zeroes are omitted).</db:para>
         <db:note>
            <db:para> The format of the number is not localized; the default C locale is used irrespective of the user's locale.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toDouble" xrefstyle="function" annotations="toDouble()">toDouble()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="setNum-6">
         <db:title>QByteArray &amp; setNum(float n, char f, int prec)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>setNum</db:methodname>
            <db:methodparam>
               <db:type>float</db:type>
               <db:parameter>n</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>f</db:parameter>
               <db:initializer>'g'</db:initializer>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>prec</db:parameter>
               <db:initializer>6</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Sets the byte array to the printed value of <db:code role="argument">n</db:code>, formatted in format <db:code role="argument">f</db:code> with precision <db:code role="argument">prec</db:code>, and returns a reference to the byte array.</db:para>
         <db:note>
            <db:para> The format of the number is not localized; the default C locale is used irrespective of the user's locale.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toFloat" xrefstyle="function" annotations="toFloat()">toFloat()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="setNum">
         <db:title>QByteArray &amp; setNum(int n, int base)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>setNum</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>n</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Sets the byte array to the printed value of <db:code role="argument">n</db:code> in base <db:code role="argument">base</db:code> (10 by default) and returns a reference to the byte array. The <db:code role="argument">base</db:code> can be any value between 2 and 36. For bases other than 10, n is treated as an unsigned integer.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray ba;
int n = 63;
ba.setNum(n);           // ba == "63"
ba.setNum(n, 16);       // ba == "3f"</db:programlisting>
         <db:note>
            <db:para> The format of the number is not localized; the default C locale is used irrespective of the user's locale.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number" xrefstyle="function" annotations="number()">number()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toInt" xrefstyle="function" annotations="toInt()">toInt()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="setNum-4">
         <db:title>QByteArray &amp; setNum(qlonglong n, int base)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>setNum</db:methodname>
            <db:methodparam>
               <db:type>qlonglong</db:type>
               <db:parameter>n</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toLongLong" xrefstyle="function" annotations="toLongLong()">toLongLong()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="setNum-5">
         <db:title>QByteArray &amp; setNum(qulonglong n, int base)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>setNum</db:methodname>
            <db:methodparam>
               <db:type>qulonglong</db:type>
               <db:parameter>n</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toULongLong" xrefstyle="function" annotations="toULongLong()">toULongLong()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="setNum-1">
         <db:title>QByteArray &amp; setNum(short n, int base)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>setNum</db:methodname>
            <db:methodparam>
               <db:type>short</db:type>
               <db:parameter>n</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toShort" xrefstyle="function" annotations="toShort()">toShort()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="setNum-3">
         <db:title>QByteArray &amp; setNum(uint n, int base)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>setNum</db:methodname>
            <db:methodparam>
               <db:type>uint</db:type>
               <db:parameter>n</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toUInt" xrefstyle="function" annotations="toUInt()">toUInt()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="setNum-2">
         <db:title>QByteArray &amp; setNum(ushort n, int base)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>setNum</db:methodname>
            <db:methodparam>
               <db:type>ushort</db:type>
               <db:parameter>n</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toUShort" xrefstyle="function" annotations="toUShort()">toUShort()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="setRawData">
         <db:title>QByteArray &amp; setRawData(const char *data, uint size)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray &amp;</db:type>
            <db:methodname>setRawData</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>data</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>uint</db:type>
               <db:parameter>size</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Resets the <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> to use the first <db:code role="argument">size</db:code> bytes of the <db:code role="argument">data</db:code> array. The bytes are <db:emphasis>not</db:emphasis> copied. The <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> will contain the <db:code role="argument">data</db:code> pointer. The caller guarantees that <db:code role="argument">data</db:code> will not be deleted or modified as long as this <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> and any copies of it exist that have not been modified.</db:para>
         <db:para>This function can be used instead of <db:code><db:link xlink:href="qbytearray.html#fromRawData" xrefstyle="function" annotations="fromRawData()">fromRawData()</db:link></db:code> to re-use existing <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> objects to save memory re-allocations.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData" xrefstyle="function" annotations="fromRawData()">fromRawData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#data" xrefstyle="function" annotations="data()">data()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#constData" xrefstyle="function" annotations="constData()">constData()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 4.7.</db:para>
      </db:section>
      <db:section xml:id="chopped">
         <db:title>QByteArray chopped(int len) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>chopped</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>len</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns a byte array that contains the leftmost <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code> - <db:code role="argument">len</db:code> bytes of this byte array.</db:para>
         <db:note>
            <db:para> The behavior is undefined if <db:code role="argument">len</db:code> is negative or greater than <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#endsWith" xrefstyle="function" annotations="endsWith()">endsWith()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#left" xrefstyle="function" annotations="left()">left()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#right" xrefstyle="function" annotations="right()">right()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#mid" xrefstyle="function" annotations="mid()">mid()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#chop" xrefstyle="function" annotations="chop()">chop()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#truncate" xrefstyle="function" annotations="truncate()">truncate()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.10.</db:para>
      </db:section>
      <db:section xml:id="fromBase64">
         <db:title>QByteArray fromBase64(const QByteArray &amp;base64)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>fromBase64</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>base64</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns a decoded copy of the Base64 array <db:code role="argument">base64</db:code>. Input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters.</db:para>
         <db:para>For example:</db:para>
         <db:programlisting language="other">QByteArray text = QByteArray::fromBase64("UXQgaXMgZ3JlYXQh");
text.data();            // returns "Qt is great!"</db:programlisting>
         <db:para>The algorithm used to decode Base64-encoded data is defined in <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt" xrefstyle="" annotations="RFC 4648">RFC 4648</db:link>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toBase64" xrefstyle="function" annotations="toBase64()">toBase64()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="fromBase64-1">
         <db:title>QByteArray fromBase64(const QByteArray &amp;base64, QByteArray::Base64Options options)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>fromBase64</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>base64</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>QByteArray::Base64Options</db:type>
               <db:parameter>options</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns a decoded copy of the Base64 array <db:code role="argument">base64</db:code>, using the alphabet defined by <db:code role="argument">options</db:code>. Input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters.</db:para>
         <db:para>For example:</db:para>
         <db:programlisting language="other">QByteArray::fromBase64("PHA+SGVsbG8/PC9wPg==", QByteArray::Base64Encoding); // returns "&lt;p&gt;Hello?&lt;/p&gt;"
QByteArray::fromBase64("PHA-SGVsbG8_PC9wPg==", QByteArray::Base64UrlEncoding); // returns "&lt;p&gt;Hello?&lt;/p&gt;"</db:programlisting>
         <db:para>The algorithm used to decode Base64-encoded data is defined in <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt" xrefstyle="" annotations="RFC 4648">RFC 4648</db:link>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toBase64" xrefstyle="function" annotations="toBase64()">toBase64()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.2.</db:para>
      </db:section>
      <db:section xml:id="fromCFData">
         <db:title>QByteArray fromCFData(CFDataRef data)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>fromCFData</db:methodname>
            <db:methodparam>
               <db:type>CFDataRef</db:type>
               <db:parameter>data</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Constructs a new <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> containing a copy of the CFData <db:code role="argument">data</db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawCFData" xrefstyle="function" annotations="fromRawCFData()">fromRawCFData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData" xrefstyle="function" annotations="fromRawData()">fromRawData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toRawCFData" xrefstyle="function" annotations="toRawCFData()">toRawCFData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toCFData" xrefstyle="function" annotations="toCFData()">toCFData()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.3.</db:para>
      </db:section>
      <db:section xml:id="fromHex">
         <db:title>QByteArray fromHex(const QByteArray &amp;hexEncoded)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>fromHex</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>hexEncoded</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns a decoded copy of the hex encoded array <db:code role="argument">hexEncoded</db:code>. Input is not checked for validity; invalid characters in the input are skipped, enabling the decoding process to continue with subsequent characters.</db:para>
         <db:para>For example:</db:para>
         <db:programlisting language="other">QByteArray text = QByteArray::fromHex("517420697320677265617421");
text.data();            // returns "Qt is great!"</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toHex" xrefstyle="function" annotations="toHex()">toHex()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="fromNSData">
         <db:title>QByteArray fromNSData(const NSData *data)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>fromNSData</db:methodname>
            <db:methodparam>
               <db:type>const NSData *</db:type>
               <db:parameter>data</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Constructs a new <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> containing a copy of the NSData <db:code role="argument">data</db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawNSData" xrefstyle="function" annotations="fromRawNSData()">fromRawNSData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData" xrefstyle="function" annotations="fromRawData()">fromRawData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toNSData" xrefstyle="function" annotations="toNSData()">toNSData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toRawNSData" xrefstyle="function" annotations="toRawNSData()">toRawNSData()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.3.</db:para>
      </db:section>
      <db:section xml:id="fromPercentEncoding">
         <db:title>QByteArray fromPercentEncoding(const QByteArray &amp;input, char percent)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>fromPercentEncoding</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>input</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>percent</db:parameter>
               <db:initializer>'%'</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns a decoded copy of the URI/URL-style percent-encoded <db:code role="argument">input</db:code>. The <db:code role="argument">percent</db:code> parameter allows you to replace the '%' character for another (for instance, '_' or '=').</db:para>
         <db:para>For example:</db:para>
         <db:programlisting language="other">QByteArray text = QByteArray::fromPercentEncoding("Qt%20is%20great%33");
text.data();            // returns "Qt is great!"</db:programlisting>
         <db:note>
            <db:para> Given invalid input (such as a string containing the sequence "%G5", which is not a valid hexadecimal number) the output will be invalid as well. As an example: the sequence "%G5" could be decoded to 'W'.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toPercentEncoding" xrefstyle="function" annotations="toPercentEncoding()">toPercentEncoding()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qurl.html#fromPercentEncoding" xrefstyle="function" annotations="QUrl::fromPercentEncoding()">QUrl::fromPercentEncoding()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 4.4.</db:para>
      </db:section>
      <db:section xml:id="fromRawCFData">
         <db:title>QByteArray fromRawCFData(CFDataRef data)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>fromRawCFData</db:methodname>
            <db:methodparam>
               <db:type>CFDataRef</db:type>
               <db:parameter>data</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Constructs a <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> that uses the bytes of the CFData <db:code role="argument">data</db:code>.</db:para>
         <db:para>The <db:code role="argument">data</db:code>'s bytes are not copied.</db:para>
         <db:para>The caller guarantees that the CFData will not be deleted or modified as long as this <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> object exists.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromCFData" xrefstyle="function" annotations="fromCFData()">fromCFData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData" xrefstyle="function" annotations="fromRawData()">fromRawData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toRawCFData" xrefstyle="function" annotations="toRawCFData()">toRawCFData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toCFData" xrefstyle="function" annotations="toCFData()">toCFData()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.3.</db:para>
      </db:section>
      <db:section xml:id="fromRawData">
         <db:title>QByteArray fromRawData(const char *data, int size)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>fromRawData</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>data</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>size</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Constructs a <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> that uses the first <db:code role="argument">size</db:code> bytes of the <db:code role="argument">data</db:code> array. The bytes are <db:emphasis>not</db:emphasis> copied. The <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> will contain the <db:code role="argument">data</db:code> pointer. The caller guarantees that <db:code role="argument">data</db:code> will not be deleted or modified as long as this <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> and any copies of it exist that have not been modified. In other words, because <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> is an <db:link xlink:href="implicit-sharing.html" xrefstyle="page" annotations="implicitly shared">implicitly shared</db:link> class and the instance returned by this function contains the <db:code role="argument">data</db:code> pointer, the caller must not delete <db:code role="argument">data</db:code> or modify it directly as long as the returned <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> and any copies exist. However, <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> does not take ownership of <db:code role="argument">data</db:code>, so the <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> destructor will never delete the raw <db:code role="argument">data</db:code>, even when the last <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> referring to <db:code role="argument">data</db:code> is destroyed.</db:para>
         <db:para>A subsequent attempt to modify the contents of the returned <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> or any copy made from it will cause it to create a deep copy of the <db:code role="argument">data</db:code> array before doing the modification. This ensures that the raw <db:code role="argument">data</db:code> array itself will never be modified by <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>.</db:para>
         <db:para>Here is an example of how to read data using a <db:code><db:link xlink:href="qdatastream.html" xrefstyle="class" annotations="QDataStream">QDataStream</db:link></db:code> on raw data in memory without copying the raw data into a <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>:</db:para>
         <db:programlisting language="other"> static const char mydata[] = {
    '\x00', '\x00', '\x03', '\x84', '\x78', '\x9c', '\x3b', '\x76',
    '\xec', '\x18', '\xc3', '\x31', '\x0a', '\xf1', '\xcc', '\x99',
    ...
    '\x6d', '\x5b'
};

QByteArray data = QByteArray::fromRawData(mydata, sizeof(mydata));
QDataStream in(&amp;data, QIODevice::ReadOnly);
...</db:programlisting>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> A byte array created with  is <db:emphasis>not</db:emphasis> '\0'-terminated, unless the raw data contains a 0 character at position <db:code role="argument">size</db:code>. While that does not matter for <db:code><db:link xlink:href="qdatastream.html" xrefstyle="class" annotations="QDataStream">QDataStream</db:link></db:code> or functions like <db:code><db:link xlink:href="qbytearray.html#indexOf" xrefstyle="function" annotations="indexOf()">indexOf()</db:link></db:code>, passing the byte array to a function accepting a <db:code>const char *</db:code> expected to be '\0'-terminated will fail.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#setRawData" xrefstyle="function" annotations="setRawData()">setRawData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#data" xrefstyle="function" annotations="data()">data()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#constData" xrefstyle="function" annotations="constData()">constData()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="fromRawNSData">
         <db:title>QByteArray fromRawNSData(const NSData *data)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>fromRawNSData</db:methodname>
            <db:methodparam>
               <db:type>const NSData *</db:type>
               <db:parameter>data</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Constructs a <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> that uses the bytes of the NSData <db:code role="argument">data</db:code>.</db:para>
         <db:para>The <db:code role="argument">data</db:code>'s bytes are not copied.</db:para>
         <db:para>The caller guarantees that the NSData will not be deleted or modified as long as this <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> object exists.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromNSData" xrefstyle="function" annotations="fromNSData()">fromNSData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData" xrefstyle="function" annotations="fromRawData()">fromRawData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toRawNSData" xrefstyle="function" annotations="toRawNSData()">toRawNSData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toNSData" xrefstyle="function" annotations="toNSData()">toNSData()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.3.</db:para>
      </db:section>
      <db:section xml:id="fromStdString">
         <db:title>QByteArray fromStdString(const std::string &amp;str)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>fromStdString</db:methodname>
            <db:methodparam>
               <db:type>const std::string &amp;</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns a copy of the <db:code role="argument">str</db:code> string as a <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toStdString" xrefstyle="function" annotations="toStdString()">toStdString()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qstring.html#fromStdString" xrefstyle="function" annotations="QString::fromStdString()">QString::fromStdString()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.4.</db:para>
      </db:section>
      <db:section xml:id="left">
         <db:title>QByteArray left(int len) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>left</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>len</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns a byte array that contains the leftmost <db:code role="argument">len</db:code> bytes of this byte array.</db:para>
         <db:para>The entire byte array is returned if <db:code role="argument">len</db:code> is greater than <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray x("Pineapple");
QByteArray y = x.left(4);
// y == "Pine"</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#startsWith" xrefstyle="function" annotations="startsWith()">startsWith()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#right" xrefstyle="function" annotations="right()">right()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#mid" xrefstyle="function" annotations="mid()">mid()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#chopped" xrefstyle="function" annotations="chopped()">chopped()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#chop" xrefstyle="function" annotations="chop()">chop()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#truncate" xrefstyle="function" annotations="truncate()">truncate()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="leftJustified">
         <db:title>QByteArray leftJustified(int width, char fill, bool truncate) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>leftJustified</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>width</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>fill</db:parameter>
               <db:initializer>' '</db:initializer>
            </db:methodparam>
            <db:methodparam>
               <db:type>bool</db:type>
               <db:parameter>truncate</db:parameter>
               <db:initializer>false</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns a byte array of size <db:code role="argument">width</db:code> that contains this byte array padded by the <db:code role="argument">fill</db:code> character.</db:para>
         <db:para>If <db:code role="argument">truncate</db:code> is false and the <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code> of the byte array is more than <db:code role="argument">width</db:code>, then the returned byte array is a copy of this byte array.</db:para>
         <db:para>If <db:code role="argument">truncate</db:code> is true and the <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code> of the byte array is more than <db:code role="argument">width</db:code>, then any bytes in a copy of the byte array after position <db:code role="argument">width</db:code> are removed, and the copy is returned.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray x("apple");
QByteArray y = x.leftJustified(8, '.');   // y == "apple..."</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#rightJustified" xrefstyle="function" annotations="rightJustified()">rightJustified()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="mid">
         <db:title>QByteArray mid(int pos, int len) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>mid</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>pos</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>len</db:parameter>
               <db:initializer>-1</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns a byte array containing <db:code role="argument">len</db:code> bytes from this byte array, starting at position <db:code role="argument">pos</db:code>.</db:para>
         <db:para>If <db:code role="argument">len</db:code> is -1 (the default), or <db:code role="argument">pos</db:code> + <db:code role="argument">len</db:code> &gt;= <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>, returns a byte array containing all bytes starting at position <db:code role="argument">pos</db:code> until the end of the byte array.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray x("Five pineapples");
QByteArray y = x.mid(5, 4);     // y == "pine"
QByteArray z = x.mid(5);        // z == "pineapples"</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#left" xrefstyle="function" annotations="left()">left()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#right" xrefstyle="function" annotations="right()">right()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#chopped" xrefstyle="function" annotations="chopped()">chopped()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#chop" xrefstyle="function" annotations="chop()">chop()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#truncate" xrefstyle="function" annotations="truncate()">truncate()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="number-4">
         <db:title>QByteArray number(double n, char f, int prec)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>number</db:methodname>
            <db:methodparam>
               <db:type>double</db:type>
               <db:parameter>n</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>f</db:parameter>
               <db:initializer>'g'</db:initializer>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>prec</db:parameter>
               <db:initializer>6</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns a byte array that contains the printed value of <db:code role="argument">n</db:code>, formatted in format <db:code role="argument">f</db:code> with precision <db:code role="argument">prec</db:code>.</db:para>
         <db:para>Argument <db:code role="argument">n</db:code> is formatted according to the <db:code role="argument">f</db:code> format specified, which is <db:code>g</db:code> by default, and can be any of the following:</db:para>
         <db:informaltable>
            <db:thead>
               <db:tr>
                  <db:th>
                     <db:para>Format</db:para>
                  </db:th>
                  <db:th>
                     <db:para>Meaning</db:para>
                  </db:th>
               </db:tr>
            </db:thead>
            <db:tr>
               <db:td>
                  <db:para>
                     <db:code>e</db:code>
                  </db:para>
               </db:td>
               <db:td>
                  <db:para>format as [-]9.9e[+|-]999</db:para>
               </db:td>
            </db:tr>
            <db:tr>
               <db:td>
                  <db:para>
                     <db:code>E</db:code>
                  </db:para>
               </db:td>
               <db:td>
                  <db:para>format as [-]9.9E[+|-]999</db:para>
               </db:td>
            </db:tr>
            <db:tr>
               <db:td>
                  <db:para>
                     <db:code>f</db:code>
                  </db:para>
               </db:td>
               <db:td>
                  <db:para>format as [-]9.9</db:para>
               </db:td>
            </db:tr>
            <db:tr>
               <db:td>
                  <db:para>
                     <db:code>g</db:code>
                  </db:para>
               </db:td>
               <db:td>
                  <db:para>use <db:code>e</db:code> or <db:code>f</db:code> format, whichever is the most concise</db:para>
               </db:td>
            </db:tr>
            <db:tr>
               <db:td>
                  <db:para>
                     <db:code>G</db:code>
                  </db:para>
               </db:td>
               <db:td>
                  <db:para>use <db:code>E</db:code> or <db:code>f</db:code> format, whichever is the most concise</db:para>
               </db:td>
            </db:tr>
         </db:informaltable>
         <db:para>With 'e', 'E', and 'f', <db:code role="argument">prec</db:code> is the number of digits after the decimal point. With 'g' and 'G', <db:code role="argument">prec</db:code> is the maximum number of significant digits (trailing zeroes are omitted).</db:para>
         <db:programlisting language="other">QByteArray ba = QByteArray::number(12.3456, 'E', 3);
// ba == 1.235E+01</db:programlisting>
         <db:note>
            <db:para> The format of the number is not localized; the default C locale is used irrespective of the user's locale.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toDouble" xrefstyle="function" annotations="toDouble()">toDouble()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="number">
         <db:title>QByteArray number(int n, int base)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>number</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>n</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns a byte array containing the string equivalent of the number <db:code role="argument">n</db:code> to base <db:code role="argument">base</db:code> (10 by default). The <db:code role="argument">base</db:code> can be any value between 2 and 36.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">int n = 63;
QByteArray::number(n);              // returns "63"
QByteArray::number(n, 16);          // returns "3f"
QByteArray::number(n, 16).toUpper();  // returns "3F"</db:programlisting>
         <db:note>
            <db:para> The format of the number is not localized; the default C locale is used irrespective of the user's locale.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#setNum" xrefstyle="function" annotations="setNum()">setNum()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toInt" xrefstyle="function" annotations="toInt()">toInt()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="number-2">
         <db:title>QByteArray number(qlonglong n, int base)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>number</db:methodname>
            <db:methodparam>
               <db:type>qlonglong</db:type>
               <db:parameter>n</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toLongLong" xrefstyle="function" annotations="toLongLong()">toLongLong()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="number-3">
         <db:title>QByteArray number(qulonglong n, int base)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>number</db:methodname>
            <db:methodparam>
               <db:type>qulonglong</db:type>
               <db:parameter>n</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toULongLong" xrefstyle="function" annotations="toULongLong()">toULongLong()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="number-1">
         <db:title>QByteArray number(uint n, int base)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>number</db:methodname>
            <db:methodparam>
               <db:type>uint</db:type>
               <db:parameter>n</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toUInt" xrefstyle="function" annotations="toUInt()">toUInt()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="repeated">
         <db:title>QByteArray repeated(int times) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>repeated</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>times</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns a copy of this byte array repeated the specified number of <db:code role="argument">times</db:code>.</db:para>
         <db:para>If <db:code role="argument">times</db:code> is less than 1, an empty byte array is returned.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray ba("ab");
ba.repeated(4);             // returns "abababab"</db:programlisting>
         <db:para>This property was introduced in Qt 4.5.</db:para>
      </db:section>
      <db:section xml:id="right">
         <db:title>QByteArray right(int len) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>right</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>len</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns a byte array that contains the rightmost <db:code role="argument">len</db:code> bytes of this byte array.</db:para>
         <db:para>The entire byte array is returned if <db:code role="argument">len</db:code> is greater than <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray x("Pineapple");
QByteArray y = x.right(5);
// y == "apple"</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#endsWith" xrefstyle="function" annotations="endsWith()">endsWith()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#left" xrefstyle="function" annotations="left()">left()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#mid" xrefstyle="function" annotations="mid()">mid()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#chopped" xrefstyle="function" annotations="chopped()">chopped()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#chop" xrefstyle="function" annotations="chop()">chop()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#truncate" xrefstyle="function" annotations="truncate()">truncate()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="rightJustified">
         <db:title>QByteArray rightJustified(int width, char fill, bool truncate) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>rightJustified</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>width</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>fill</db:parameter>
               <db:initializer>' '</db:initializer>
            </db:methodparam>
            <db:methodparam>
               <db:type>bool</db:type>
               <db:parameter>truncate</db:parameter>
               <db:initializer>false</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns a byte array of size <db:code role="argument">width</db:code> that contains the <db:code role="argument">fill</db:code> character followed by this byte array.</db:para>
         <db:para>If <db:code role="argument">truncate</db:code> is false and the size of the byte array is more than <db:code role="argument">width</db:code>, then the returned byte array is a copy of this byte array.</db:para>
         <db:para>If <db:code role="argument">truncate</db:code> is true and the size of the byte array is more than <db:code role="argument">width</db:code>, then the resulting byte array is truncated at position <db:code role="argument">width</db:code>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray x("apple");
QByteArray y = x.rightJustified(8, '.');    // y == "...apple"</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#leftJustified" xrefstyle="function" annotations="leftJustified()">leftJustified()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="simplified">
         <db:title>QByteArray simplified() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>simplified</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a byte array that has whitespace removed from the start and the end, and which has each sequence of internal whitespace replaced with a single space.</db:para>
         <db:para>Whitespace means any character for which the standard C++ <db:code>isspace()</db:code> function returns <db:code>true</db:code> in the C locale. This includes the ASCII isspace() function returns <db:code>true</db:code> in the C locale. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray ba("  lots\t of\nwhitespace\r\n ");
ba = ba.simplified();
// ba == "lots of whitespace";</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#trimmed" xrefstyle="function" annotations="trimmed()">trimmed()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="toBase64">
         <db:title>QByteArray toBase64() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>toBase64</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a copy of the byte array, encoded as Base64.</db:para>
         <db:programlisting language="other">QByteArray text("Qt is great!");
text.toBase64();        // returns "UXQgaXMgZ3JlYXQh"</db:programlisting>
         <db:para>The algorithm used to encode Base64-encoded data is defined in <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt" xrefstyle="" annotations="RFC 4648">RFC 4648</db:link>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromBase64" xrefstyle="function" annotations="fromBase64()">fromBase64()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="toBase64-1">
         <db:title>QByteArray toBase64(QByteArray::Base64Options options) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>toBase64</db:methodname>
            <db:methodparam>
               <db:type>QByteArray::Base64Options</db:type>
               <db:parameter>options</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns a copy of the byte array, encoded using the options <db:code role="argument">options</db:code>.</db:para>
         <db:programlisting language="other">QByteArray text("&lt;p&gt;Hello?&lt;/p&gt;");
text.toBase64(QByteArray::Base64Encoding | QByteArray::OmitTrailingEquals);      // returns "PHA+SGVsbG8/PC9wPg"
text.toBase64(QByteArray::Base64Encoding);                                       // returns "PHA+SGVsbG8/PC9wPg=="
text.toBase64(QByteArray::Base64UrlEncoding);                                    // returns "PHA-SGVsbG8_PC9wPg=="
text.toBase64(QByteArray::Base64UrlEncoding | QByteArray::OmitTrailingEquals);   // returns "PHA-SGVsbG8_PC9wPg"</db:programlisting>
         <db:para>The algorithm used to encode Base64-encoded data is defined in <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt" xrefstyle="" annotations="RFC 4648">RFC 4648</db:link>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromBase64" xrefstyle="function" annotations="fromBase64()">fromBase64()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.2.</db:para>
      </db:section>
      <db:section xml:id="toHex">
         <db:title>QByteArray toHex() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>toHex</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a hex encoded copy of the byte array. The hex encoding uses the numbers 0-9 and the letters a-f.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromHex" xrefstyle="function" annotations="fromHex()">fromHex()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="toHex-1">
         <db:title>QByteArray toHex(char separator) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>toHex</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>separator</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns a hex encoded copy of the byte array. The hex encoding uses the numbers 0-9 and the letters a-f.</db:para>
         <db:para>If <db:code role="argument">separator</db:code> is not '\0', the separator character is inserted between the hex bytes.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray macAddress = QByteArray::fromHex("123456abcdef");
macAddress.toHex(':'); // returns "12:34:56:ab:cd:ef"
macAddress.toHex(0);   // returns "123456abcdef"</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromHex" xrefstyle="function" annotations="fromHex()">fromHex()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.9.</db:para>
      </db:section>
      <db:section xml:id="toLower">
         <db:title>QByteArray toLower() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>toLower</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a lowercase copy of the byte array. The bytearray is interpreted as a Latin-1 encoded string.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray x("Qt by THE QT COMPANY");
QByteArray y = x.toLower();
// y == "qt by the qt company"</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#isLower" xrefstyle="function" annotations="isLower()">isLower()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toUpper" xrefstyle="function" annotations="toUpper()">toUpper()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#8-bit-character-comparisons" xrefstyle="class" annotations="8-bit Character Comparisons">8-bit Character Comparisons</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="toPercentEncoding">
         <db:title>QByteArray toPercentEncoding(const QByteArray &amp;exclude, const QByteArray &amp;include, char percent) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>toPercentEncoding</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>exclude</db:parameter>
               <db:initializer>QByteArray()</db:initializer>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>include</db:parameter>
               <db:initializer>QByteArray()</db:initializer>
            </db:methodparam>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>percent</db:parameter>
               <db:initializer>'%'</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns a URI/URL-style percent-encoded copy of this byte array. The <db:code role="argument">percent</db:code> parameter allows you to override the default '%' character for another.</db:para>
         <db:para>By default, this function will encode all characters that are not one of the following:</db:para>
         <db:para>ALPHA ("a" to "z" and "A" to "Z") / DIGIT (0 to 9) / "-" / "." / "_" / "~"</db:para>
         <db:para>To prevent characters from being encoded pass them to <db:code role="argument">exclude</db:code>. To force characters to be encoded pass them to <db:code role="argument">include</db:code>. The <db:code role="argument">percent</db:code> character is always encoded.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray text = "{a fishy string?}";
QByteArray ba = text.toPercentEncoding("{}", "s");
qDebug(ba.constData());
// prints "{a fi%73hy %73tring%3F}"</db:programlisting>
         <db:para>The hex encoding uses the numbers 0-9 and the uppercase letters A-F.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromPercentEncoding" xrefstyle="function" annotations="fromPercentEncoding()">fromPercentEncoding()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qurl.html#toPercentEncoding" xrefstyle="function" annotations="QUrl::toPercentEncoding()">QUrl::toPercentEncoding()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 4.4.</db:para>
      </db:section>
      <db:section xml:id="toUpper">
         <db:title>QByteArray toUpper() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>toUpper</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns an uppercase copy of the byte array. The bytearray is interpreted as a Latin-1 encoded string.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray x("Qt by THE QT COMPANY");
QByteArray y = x.toUpper();
// y == "QT BY THE QT COMPANY"</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#isUpper" xrefstyle="function" annotations="isUpper()">isUpper()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toLower" xrefstyle="function" annotations="toLower()">toLower()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#8-bit-character-comparisons" xrefstyle="class" annotations="8-bit Character Comparisons">8-bit Character Comparisons</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="trimmed">
         <db:title>QByteArray trimmed() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray</db:type>
            <db:methodname>trimmed</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a byte array that has whitespace removed from the start and the end.</db:para>
         <db:para>Whitespace means any character for which the standard C++ <db:code>isspace()</db:code> function returns <db:code>true</db:code> in the C locale. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray ba("  lots\t of\nwhitespace\r\n ");
ba = ba.trimmed();
// ba == "lots\t of\nwhitespace";</db:programlisting>
         <db:para>Unlike <db:code><db:link xlink:href="qbytearray.html#simplified" xrefstyle="function" annotations="simplified()">simplified()</db:link></db:code>,  leaves internal whitespace alone.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#simplified" xrefstyle="function" annotations="simplified()">simplified()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="QByteArray-3">
         <db:title>QByteArray(QByteArray &amp;&amp;other)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:methodname>QByteArray</db:methodname>
            <db:methodparam>
               <db:type>QByteArray &amp;&amp;</db:type>
               <db:parameter>other</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Move-constructs a <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> instance, making it point at the same object that <db:code role="argument">other</db:code> was pointing to.</db:para>
         <db:para>This property was introduced in Qt 5.2.</db:para>
      </db:section>
      <db:section xml:id="begin-1">
         <db:title>QByteArray::const_iterator begin() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray::const_iterator</db:type>
            <db:methodname>begin</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>This function overloads <db:code><db:link xlink:href="qbytearray.html#begin" xrefstyle="function" annotations="begin()">begin()</db:link></db:code>.</db:para>
      </db:section>
      <db:section xml:id="cbegin">
         <db:title>QByteArray::const_iterator cbegin() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray::const_iterator</db:type>
            <db:methodname>cbegin</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a const <db:link xlink:href="containers.html#stl-style-iterators" xrefstyle="page" annotations="STL-style iterators">STL-style iterator</db:link> pointing to the first character in the byte-array.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#begin" xrefstyle="function" annotations="begin()">begin()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#cend" xrefstyle="function" annotations="cend()">cend()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.0.</db:para>
      </db:section>
      <db:section xml:id="cend">
         <db:title>QByteArray::const_iterator cend() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray::const_iterator</db:type>
            <db:methodname>cend</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a const <db:link xlink:href="containers.html#stl-style-iterators" xrefstyle="page" annotations="STL-style iterators">STL-style iterator</db:link> pointing to the imaginary character after the last character in the list.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#cbegin" xrefstyle="function" annotations="cbegin()">cbegin()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#end" xrefstyle="function" annotations="end()">end()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.0.</db:para>
      </db:section>
      <db:section xml:id="constBegin">
         <db:title>QByteArray::const_iterator constBegin() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray::const_iterator</db:type>
            <db:methodname>constBegin</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a const <db:link xlink:href="containers.html#stl-style-iterators" xrefstyle="page" annotations="STL-style iterators">STL-style iterator</db:link> pointing to the first character in the byte-array.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#begin" xrefstyle="function" annotations="begin()">begin()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#constEnd" xrefstyle="function" annotations="constEnd()">constEnd()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="constEnd">
         <db:title>QByteArray::const_iterator constEnd() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray::const_iterator</db:type>
            <db:methodname>constEnd</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a const <db:link xlink:href="containers.html#stl-style-iterators" xrefstyle="page" annotations="STL-style iterators">STL-style iterator</db:link> pointing to the imaginary character after the last character in the list.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#constBegin" xrefstyle="function" annotations="constBegin()">constBegin()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#end" xrefstyle="function" annotations="end()">end()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="end-1">
         <db:title>QByteArray::const_iterator end() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray::const_iterator</db:type>
            <db:methodname>end</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>This function overloads <db:code><db:link xlink:href="qbytearray.html#end" xrefstyle="function" annotations="end()">end()</db:link></db:code>.</db:para>
      </db:section>
      <db:section xml:id="crbegin">
         <db:title>QByteArray::const_reverse_iterator crbegin() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray::const_reverse_iterator</db:type>
            <db:methodname>crbegin</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a const <db:link xlink:href="containers.html#stl-style-iterators" xrefstyle="page" annotations="STL-style iterators">STL-style</db:link> reverse iterator pointing to the first character in the byte-array, in reverse order.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#begin" xrefstyle="function" annotations="begin()">begin()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#rbegin" xrefstyle="function" annotations="rbegin()">rbegin()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#rend" xrefstyle="function" annotations="rend()">rend()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.6.</db:para>
      </db:section>
      <db:section xml:id="crend">
         <db:title>QByteArray::const_reverse_iterator crend() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray::const_reverse_iterator</db:type>
            <db:methodname>crend</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a const <db:link xlink:href="containers.html#stl-style-iterators" xrefstyle="page" annotations="STL-style iterators">STL-style</db:link> reverse iterator pointing to one past the last character in the byte-array, in reverse order.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#end" xrefstyle="function" annotations="end()">end()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#rend" xrefstyle="function" annotations="rend()">rend()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#rbegin" xrefstyle="function" annotations="rbegin()">rbegin()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.6.</db:para>
      </db:section>
      <db:section xml:id="rbegin-1">
         <db:title>QByteArray::const_reverse_iterator rbegin() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray::const_reverse_iterator</db:type>
            <db:methodname>rbegin</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>This property was introduced in Qt 5.6.</db:para>
      </db:section>
      <db:section xml:id="rend-1">
         <db:title>QByteArray::const_reverse_iterator rend() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray::const_reverse_iterator</db:type>
            <db:methodname>rend</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>This property was introduced in Qt 5.6.</db:para>
      </db:section>
      <db:section xml:id="begin">
         <db:title>QByteArray::iterator begin()</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray::iterator</db:type>
            <db:methodname>begin</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns an <db:link xlink:href="containers.html#stl-style-iterators" xrefstyle="page" annotations="STL-style iterators">STL-style iterator</db:link> pointing to the first character in the byte-array.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#constBegin" xrefstyle="function" annotations="constBegin()">constBegin()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#end" xrefstyle="function" annotations="end()">end()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="end">
         <db:title>QByteArray::iterator end()</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray::iterator</db:type>
            <db:methodname>end</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns an <db:link xlink:href="containers.html#stl-style-iterators" xrefstyle="page" annotations="STL-style iterators">STL-style iterator</db:link> pointing to the imaginary character after the last character in the byte-array.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#begin" xrefstyle="function" annotations="begin()">begin()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#constEnd" xrefstyle="function" annotations="constEnd()">constEnd()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="rbegin">
         <db:title>QByteArray::reverse_iterator rbegin()</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray::reverse_iterator</db:type>
            <db:methodname>rbegin</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a <db:link xlink:href="containers.html#stl-style-iterators" xrefstyle="page" annotations="STL-style iterators">STL-style</db:link> reverse iterator pointing to the first character in the byte-array, in reverse order.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#begin" xrefstyle="function" annotations="begin()">begin()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#crbegin" xrefstyle="function" annotations="crbegin()">crbegin()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#rend" xrefstyle="function" annotations="rend()">rend()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.6.</db:para>
      </db:section>
      <db:section xml:id="rend">
         <db:title>QByteArray::reverse_iterator rend()</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteArray::reverse_iterator</db:type>
            <db:methodname>rend</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a <db:link xlink:href="containers.html#stl-style-iterators" xrefstyle="page" annotations="STL-style iterators">STL-style</db:link> reverse iterator pointing to one past the last character in the byte-array, in reverse order.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#end" xrefstyle="function" annotations="end()">end()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#crend" xrefstyle="function" annotations="crend()">crend()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#rbegin" xrefstyle="function" annotations="rbegin()">rbegin()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.6.</db:para>
      </db:section>
      <db:section xml:id="back-1">
         <db:title>QByteRef back()</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteRef</db:type>
            <db:methodname>back</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a reference to the last character in the byte array. Same as <db:code>operator[](size() - 1)</db:code>.</db:para>
         <db:para>This function is provided for STL compatibility.</db:para>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> Calling this function on an empty byte array constitutes undefined behavior.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#front" xrefstyle="function" annotations="front()">front()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#at" xrefstyle="function" annotations="at()">at()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-5b-5d" xrefstyle="function" annotations="operator[]()">operator[]()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.10.</db:para>
      </db:section>
      <db:section xml:id="front-1">
         <db:title>QByteRef front()</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteRef</db:type>
            <db:methodname>front</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a reference to the first character in the byte array. Same as <db:code>operator[](0)</db:code>.</db:para>
         <db:para>This function is provided for STL compatibility.</db:para>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> Calling this function on an empty byte array constitutes undefined behavior.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#back" xrefstyle="function" annotations="back()">back()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#at" xrefstyle="function" annotations="at()">at()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-5b-5d" xrefstyle="function" annotations="operator[]()">operator[]()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.10.</db:para>
      </db:section>
      <db:section xml:id="operator-5b-5d">
         <db:title>QByteRef operator[](int i)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteRef</db:type>
            <db:methodname>operator[]</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>i</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns the byte at index position <db:code role="argument">i</db:code> as a modifiable reference.</db:para>
         <db:para>If an assignment is made beyond the end of the byte array, the array is extended with <db:code><db:link xlink:href="qbytearray.html#resize" xrefstyle="function" annotations="resize()">resize()</db:link></db:code> before the assignment takes place.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray ba;
for (int i = 0; i &lt; 10; ++i)
    ba[i] = 'A' + i;
// ba == "ABCDEFGHIJ"</db:programlisting>
         <db:para>The return value is of type <db:code><db:link xlink:href="qbyteref.html" xrefstyle="class" annotations="QByteRef">QByteRef</db:link></db:code>, a helper class for <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>. When you get an object of type <db:code><db:link xlink:href="qbyteref.html" xrefstyle="class" annotations="QByteRef">QByteRef</db:link></db:code>, you can use it as if it were a char &amp;. If you assign to it, the assignment will apply to the character in the <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> from which you got the reference.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#at" xrefstyle="function" annotations="at()">at()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="operator-5b-5d-3">
         <db:title>QByteRef operator[](uint i)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QByteRef</db:type>
            <db:methodname>operator[]</db:methodname>
            <db:methodparam>
               <db:type>uint</db:type>
               <db:parameter>i</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
      </db:section>
      <db:section xml:id="operator-lt-lt-rnd-3186">
         <db:title>QDataStream &amp; operator&lt;&lt;(QDataStream &amp;s, const QVariant &amp;p)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QDataStream &amp;</db:type>
            <db:methodname>operator&lt;&lt;</db:methodname>
            <db:methodparam>
               <db:type>QDataStream &amp;</db:type>
               <db:parameter>s</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QVariant &amp;</db:type>
               <db:parameter>p</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Writes a variant <db:code role="argument">p</db:code> to the stream <db:code role="argument">s</db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:link xlink:href="datastreamformat.html" xrefstyle="page" annotations="Serializing Qt Data Types">Format of the QDataStream operators</db:link>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="operator-lt-lt-rnd-3201">
         <db:title>QDataStream &amp; operator&lt;&lt;(QDataStream &amp;s, const QVariant::Type p)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QDataStream &amp;</db:type>
            <db:methodname>operator&lt;&lt;</db:methodname>
            <db:methodparam>
               <db:type>QDataStream &amp;</db:type>
               <db:parameter>s</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QVariant::Type</db:type>
               <db:parameter>p</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Writes a variant type <db:code role="argument">p</db:code> to the stream <db:code role="argument">s</db:code>.</db:para>
      </db:section>
      <db:section xml:id="operator-gt-gt-rnd-4334">
         <db:title>QDataStream &amp; operator&gt;&gt;(QDataStream &amp;s, QVariant &amp;p)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QDataStream &amp;</db:type>
            <db:methodname>operator&gt;&gt;</db:methodname>
            <db:methodparam>
               <db:type>QDataStream &amp;</db:type>
               <db:parameter>s</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>QVariant &amp;</db:type>
               <db:parameter>p</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Reads a variant <db:code role="argument">p</db:code> from the stream <db:code role="argument">s</db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:link xlink:href="datastreamformat.html" xrefstyle="page" annotations="Serializing Qt Data Types">Format of the QDataStream operators</db:link>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 4.4.</db:para>
      </db:section>
      <db:section xml:id="operator-gt-gt-rnd-4349">
         <db:title>QDataStream &amp; operator&gt;&gt;(QDataStream &amp;s, QVariant::Type &amp;p)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QDataStream &amp;</db:type>
            <db:methodname>operator&gt;&gt;</db:methodname>
            <db:methodparam>
               <db:type>QDataStream &amp;</db:type>
               <db:parameter>s</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>QVariant::Type &amp;</db:type>
               <db:parameter>p</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Reads a variant type <db:code role="argument">p</db:code> in enum representation from the stream <db:code role="argument">s</db:code>.</db:para>
      </db:section>
      <db:section xml:id="split">
         <db:title>QList&lt;QByteArray&gt; split(char sep) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>QList&lt;QByteArray&gt;</db:type>
            <db:methodname>split</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>sep</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Splits the byte array into subarrays wherever <db:code role="argument">sep</db:code> occurs, and returns the list of those arrays. If <db:code role="argument">sep</db:code> does not match anywhere in the byte array,  returns a single-element list containing this byte array.</db:para>
      </db:section>
      <db:section xml:id="contains-1">
         <db:title>bool contains(char ch) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>contains</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if the byte array contains the character <db:code role="argument">ch</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="contains">
         <db:title>bool contains(const QByteArray &amp;ba) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>contains</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>ba</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns <db:code>true</db:code> if the byte array contains an occurrence of the byte array <db:code role="argument">ba</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#indexOf" xrefstyle="function" annotations="indexOf()">indexOf()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#count-3" xrefstyle="function" annotations="count()">count()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="contains-2">
         <db:title>bool contains(const char *str) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>contains</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if the byte array contains the string <db:code role="argument">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="endsWith-1">
         <db:title>bool endsWith(char ch) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>endsWith</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if this byte array ends with character <db:code role="argument">ch</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="endsWith">
         <db:title>bool endsWith(const QByteArray &amp;ba) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>endsWith</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>ba</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns <db:code>true</db:code> if this byte array ends with byte array <db:code role="argument">ba</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray url("http://qt-project.org/doc/qt-5.0/qtdoc/index.html");
if (url.endsWith(".html"))
    ...</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#startsWith" xrefstyle="function" annotations="startsWith()">startsWith()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#right" xrefstyle="function" annotations="right()">right()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="endsWith-2">
         <db:title>bool endsWith(const char *str) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>endsWith</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if this byte array ends with string <db:code role="argument">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="isEmpty">
         <db:title>bool isEmpty() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>isEmpty</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns <db:code>true</db:code> if the byte array has size 0; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray().isEmpty();         // returns true
QByteArray("").isEmpty();       // returns true
QByteArray("abc").isEmpty();    // returns false</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="isLower">
         <db:title>bool isLower() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>isLower</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns <db:code>true</db:code> if this byte array contains only lowercase letters, otherwise returns <db:code>false</db:code>. The byte array is interpreted as a Latin-1 encoded string.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#isUpper" xrefstyle="function" annotations="isUpper()">isUpper()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toLower" xrefstyle="function" annotations="toLower()">toLower()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.12.</db:para>
      </db:section>
      <db:section xml:id="isNull">
         <db:title>bool isNull() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>isNull</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns <db:code>true</db:code> if this byte array is null; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray().isNull();          // returns true
QByteArray("").isNull();        // returns false
QByteArray("abc").isNull();     // returns false</db:programlisting>
         <db:para>Qt makes a distinction between null byte arrays and empty byte arrays for historical reasons. For most applications, what matters is whether or not a byte array contains any data, and this can be determined using <db:code><db:link xlink:href="qbytearray.html#isEmpty" xrefstyle="function" annotations="isEmpty()">isEmpty()</db:link></db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#isEmpty" xrefstyle="function" annotations="isEmpty()">isEmpty()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="isUpper">
         <db:title>bool isUpper() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>isUpper</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns <db:code>true</db:code> if this byte array contains only uppercase letters, otherwise returns <db:code>false</db:code>. The byte array is interpreted as a Latin-1 encoded string.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#isLower" xrefstyle="function" annotations="isLower()">isLower()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#toUpper" xrefstyle="function" annotations="toUpper()">toUpper()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.12.</db:para>
      </db:section>
      <db:section xml:id="operator-not-eq">
         <db:title>bool operator!=(const QString &amp;str) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>operator!=</db:methodname>
            <db:methodparam>
               <db:type>const QString &amp;</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns <db:code>true</db:code> if this byte array is not equal to string <db:code role="argument">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>The Unicode data is converted into 8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code>.</db:para>
         <db:para>The comparison is case sensitive.</db:para>
         <db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#fromUtf8" xrefstyle="function" annotations="QString::fromUtf8()">QString::fromUtf8()</db:link></db:code>, <db:code><db:link xlink:href="qstring.html#fromLatin1" xrefstyle="function" annotations="QString::fromLatin1()">QString::fromLatin1()</db:link></db:code>, or <db:code><db:link xlink:href="qstring.html#fromLocal8Bit" xrefstyle="function" annotations="QString::fromLocal8Bit()">QString::fromLocal8Bit()</db:link></db:code> explicitly if you want to convert the byte array to a <db:code><db:link xlink:href="qstring.html" xrefstyle="class" annotations="QString">QString</db:link></db:code> before doing the comparison.</db:para>
      </db:section>
      <db:section xml:id="operator-lt">
         <db:title>bool operator&lt;(const QString &amp;str) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>operator&lt;</db:methodname>
            <db:methodparam>
               <db:type>const QString &amp;</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns <db:code>true</db:code> if this byte array is lexically less than string <db:code role="argument">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>The Unicode data is converted into 8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code>.</db:para>
         <db:para>The comparison is case sensitive.</db:para>
         <db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#fromUtf8" xrefstyle="function" annotations="QString::fromUtf8()">QString::fromUtf8()</db:link></db:code>, <db:code><db:link xlink:href="qstring.html#fromLatin1" xrefstyle="function" annotations="QString::fromLatin1()">QString::fromLatin1()</db:link></db:code>, or <db:code><db:link xlink:href="qstring.html#fromLocal8Bit" xrefstyle="function" annotations="QString::fromLocal8Bit()">QString::fromLocal8Bit()</db:link></db:code> explicitly if you want to convert the byte array to a <db:code><db:link xlink:href="qstring.html" xrefstyle="class" annotations="QString">QString</db:link></db:code> before doing the comparison.</db:para>
      </db:section>
      <db:section xml:id="operator-lt-eq">
         <db:title>bool operator&lt;=(const QString &amp;str) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>operator&lt;=</db:methodname>
            <db:methodparam>
               <db:type>const QString &amp;</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns <db:code>true</db:code> if this byte array is lexically less than or equal to string <db:code role="argument">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>The Unicode data is converted into 8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code>.</db:para>
         <db:para>The comparison is case sensitive.</db:para>
         <db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#fromUtf8" xrefstyle="function" annotations="QString::fromUtf8()">QString::fromUtf8()</db:link></db:code>, <db:code><db:link xlink:href="qstring.html#fromLatin1" xrefstyle="function" annotations="QString::fromLatin1()">QString::fromLatin1()</db:link></db:code>, or <db:code><db:link xlink:href="qstring.html#fromLocal8Bit" xrefstyle="function" annotations="QString::fromLocal8Bit()">QString::fromLocal8Bit()</db:link></db:code> explicitly if you want to convert the byte array to a <db:code><db:link xlink:href="qstring.html" xrefstyle="class" annotations="QString">QString</db:link></db:code> before doing the comparison.</db:para>
      </db:section>
      <db:section xml:id="operator-eq-eq">
         <db:title>bool operator==(const QString &amp;str) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>operator==</db:methodname>
            <db:methodparam>
               <db:type>const QString &amp;</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns <db:code>true</db:code> if this byte array is equal to string <db:code role="argument">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>The Unicode data is converted into 8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code>.</db:para>
         <db:para>The comparison is case sensitive.</db:para>
         <db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#fromUtf8" xrefstyle="function" annotations="QString::fromUtf8()">QString::fromUtf8()</db:link></db:code>, <db:code><db:link xlink:href="qstring.html#fromLatin1" xrefstyle="function" annotations="QString::fromLatin1()">QString::fromLatin1()</db:link></db:code>, or <db:code><db:link xlink:href="qstring.html#fromLocal8Bit" xrefstyle="function" annotations="QString::fromLocal8Bit()">QString::fromLocal8Bit()</db:link></db:code> explicitly if you want to convert the byte array to a <db:code><db:link xlink:href="qstring.html" xrefstyle="class" annotations="QString">QString</db:link></db:code> before doing the comparison.</db:para>
      </db:section>
      <db:section xml:id="operator-gt">
         <db:title>bool operator&gt;(const QString &amp;str) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>operator&gt;</db:methodname>
            <db:methodparam>
               <db:type>const QString &amp;</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns <db:code>true</db:code> if this byte array is lexically greater than string <db:code role="argument">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>The Unicode data is converted into 8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code>.</db:para>
         <db:para>The comparison is case sensitive.</db:para>
         <db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#fromUtf8" xrefstyle="function" annotations="QString::fromUtf8()">QString::fromUtf8()</db:link></db:code>, <db:code><db:link xlink:href="qstring.html#fromLatin1" xrefstyle="function" annotations="QString::fromLatin1()">QString::fromLatin1()</db:link></db:code>, or <db:code><db:link xlink:href="qstring.html#fromLocal8Bit" xrefstyle="function" annotations="QString::fromLocal8Bit()">QString::fromLocal8Bit()</db:link></db:code> explicitly if you want to convert the byte array to a <db:code><db:link xlink:href="qstring.html" xrefstyle="class" annotations="QString">QString</db:link></db:code> before doing the comparison.</db:para>
      </db:section>
      <db:section xml:id="operator-gt-eq">
         <db:title>bool operator&gt;=(const QString &amp;str) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>operator&gt;=</db:methodname>
            <db:methodparam>
               <db:type>const QString &amp;</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns <db:code>true</db:code> if this byte array is greater than or equal to string <db:code role="argument">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>The Unicode data is converted into 8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code>.</db:para>
         <db:para>The comparison is case sensitive.</db:para>
         <db:para>You can disable this operator by defining <db:code>QT_NO_CAST_FROM_ASCII</db:code> when you compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#fromUtf8" xrefstyle="function" annotations="QString::fromUtf8()">QString::fromUtf8()</db:link></db:code>, <db:code><db:link xlink:href="qstring.html#fromLatin1" xrefstyle="function" annotations="QString::fromLatin1()">QString::fromLatin1()</db:link></db:code>, or <db:code><db:link xlink:href="qstring.html#fromLocal8Bit" xrefstyle="function" annotations="QString::fromLocal8Bit()">QString::fromLocal8Bit()</db:link></db:code> explicitly if you want to convert the byte array to a <db:code><db:link xlink:href="qstring.html" xrefstyle="class" annotations="QString">QString</db:link></db:code> before doing the comparison.</db:para>
      </db:section>
      <db:section xml:id="startsWith-1">
         <db:title>bool startsWith(char ch) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>startsWith</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if this byte array starts with character <db:code role="argument">ch</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="startsWith">
         <db:title>bool startsWith(const QByteArray &amp;ba) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>startsWith</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>ba</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns <db:code>true</db:code> if this byte array starts with byte array <db:code role="argument">ba</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray url("ftp://ftp.qt-project.org/");
if (url.startsWith("ftp:"))
    ...</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#endsWith" xrefstyle="function" annotations="endsWith()">endsWith()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#left" xrefstyle="function" annotations="left()">left()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="startsWith-2">
         <db:title>bool startsWith(const char *str) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>bool</db:type>
            <db:methodname>startsWith</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns <db:code>true</db:code> if this byte array starts with string <db:code role="argument">str</db:code>; otherwise returns <db:code>false</db:code>.</db:para>
      </db:section>
      <db:section xml:id="data">
         <db:title>char * data()</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>char *</db:type>
            <db:methodname>data</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a pointer to the data stored in the byte array. The pointer can be used to access and modify the bytes that compose the array. The data is '\0'-terminated, i.e. the number of bytes in the returned character string is <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code> + 1 for the '\0' terminator.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray ba("Hello world");
char *data = ba.data();
while (*data) {
    cout &lt;&lt; "[" &lt;&lt; *data &lt;&lt; "]" &lt;&lt; endl;
    ++data;
}</db:programlisting>
         <db:para>The pointer remains valid as long as the byte array isn't reallocated or destroyed. For read-only access, <db:code><db:link xlink:href="qbytearray.html#constData" xrefstyle="function" annotations="constData()">constData()</db:link></db:code> is faster because it never causes a <db:link xlink:href="implicit-sharing.html#deep-copy" xrefstyle="page" annotations="deep copy">deep copy</db:link> to occur.</db:para>
         <db:para>This function is mostly useful to pass a byte array to a function that accepts a <db:code>const char *</db:code>.</db:para>
         <db:para>The following example makes a copy of the char* returned by , but it will corrupt the heap and cause a crash because it does not allocate a byte for the '\0' at the end:</db:para>
         <db:programlisting language="other">QString tmp = "test";
QByteArray text = tmp.toLocal8Bit();
char *data = new char[text.size()];
strcpy(data, text.data());
delete [] data;</db:programlisting>
         <db:para>This one allocates the correct amount of space:</db:para>
         <db:programlisting language="other">QString tmp = "test";
QByteArray text = tmp.toLocal8Bit();
char *data = new char[text.size() + 1];
strcpy(data, text.data());
delete [] data;</db:programlisting>
         <db:para>Note: A <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> can store any byte values including '\0's, but most functions that take <db:code>char *</db:code> arguments assume that the data ends at the first '\0' they encounter.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#constData" xrefstyle="function" annotations="constData()">constData()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-5b-5d" xrefstyle="function" annotations="operator[]()">operator[]()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="at">
         <db:title>char at(int i) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>char</db:type>
            <db:methodname>at</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>i</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns the character at index position <db:code role="argument">i</db:code> in the byte array.</db:para>
         <db:para>
            <db:code role="argument">i</db:code> must be a valid index position in the byte array (i.e., 0 &lt;= <db:code role="argument">i</db:code> &lt; <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>).</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-5b-5d" xrefstyle="function" annotations="operator[]()">operator[]()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="back">
         <db:title>char back() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>char</db:type>
            <db:methodname>back</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns the last character in the byte array. Same as <db:code>at(size() - 1)</db:code>.</db:para>
         <db:para>This function is provided for STL compatibility.</db:para>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> Calling this function on an empty byte array constitutes undefined behavior.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#front" xrefstyle="function" annotations="front()">front()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#at" xrefstyle="function" annotations="at()">at()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-5b-5d" xrefstyle="function" annotations="operator[]()">operator[]()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.10.</db:para>
      </db:section>
      <db:section xml:id="front">
         <db:title>char front() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>char</db:type>
            <db:methodname>front</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns the first character in the byte array. Same as <db:code>at(0)</db:code>.</db:para>
         <db:para>This function is provided for STL compatibility.</db:para>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> Calling this function on an empty byte array constitutes undefined behavior.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#back" xrefstyle="function" annotations="back()">back()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#at" xrefstyle="function" annotations="at()">at()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-5b-5d" xrefstyle="function" annotations="operator[]()">operator[]()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.10.</db:para>
      </db:section>
      <db:section xml:id="operator-5b-5d-1">
         <db:title>char operator[](int i) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>char</db:type>
            <db:methodname>operator[]</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>i</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Same as at(<db:code role="argument">i</db:code>).</db:para>
      </db:section>
      <db:section xml:id="operator-5b-5d-2">
         <db:title>char operator[](uint i) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>char</db:type>
            <db:methodname>operator[]</db:methodname>
            <db:methodparam>
               <db:type>uint</db:type>
               <db:parameter>i</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
      </db:section>
      <db:section xml:id="constData">
         <db:title>const char * constData() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>const char *</db:type>
            <db:methodname>constData</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a pointer to the data stored in the byte array. The pointer can be used to access the bytes that compose the array. The data is '\0'-terminated unless the <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> object was created from raw data. The pointer remains valid as long as the byte array isn't reallocated or destroyed.</db:para>
         <db:para>This function is mostly useful to pass a byte array to a function that accepts a <db:code>const char *</db:code>.</db:para>
         <db:para>Note: A <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> can store any byte values including '\0's, but most functions that take <db:code>char *</db:code> arguments assume that the data ends at the first '\0' they encounter.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#data" xrefstyle="function" annotations="data()">data()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-5b-5d" xrefstyle="function" annotations="operator[]()">operator[]()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromRawData" xrefstyle="function" annotations="fromRawData()">fromRawData()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="data-1">
         <db:title>const char * data() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>const char *</db:type>
            <db:methodname>data</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
      </db:section>
      <db:section xml:id="operator-const-char--2a">
         <db:title>const char * operator const char *() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>const char *</db:type>
            <db:methodname>operator const char *</db:methodname>
            <db:void/>
         </db:methodsynopsis>
      </db:section>
      <db:section xml:id="operator-const-void--2a">
         <db:title>const void * operator const void *() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>const void *</db:type>
            <db:methodname>operator const void *</db:methodname>
            <db:void/>
         </db:methodsynopsis>
      </db:section>
      <db:section xml:id="toDouble">
         <db:title>double toDouble(bool *ok) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>double</db:type>
            <db:methodname>toDouble</db:methodname>
            <db:methodparam>
               <db:type>bool *</db:type>
               <db:parameter>ok</db:parameter>
               <db:initializer>nullptr</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns the byte array converted to a <db:code>double</db:code> value.</db:para>
         <db:para>Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g. underflow).</db:para>
         <db:para>If <db:code role="argument">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="argument">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="argument">ok</db:code> to <db:code>true</db:code>.</db:para>
         <db:programlisting language="other">QByteArray string("1234.56");
bool ok;
double a = string.toDouble(&amp;ok);   // a == 1234.56, ok == true

string = "1234.56 Volt";
a = str.toDouble(&amp;ok);             // a == 0, ok == false</db:programlisting>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> The <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</db:para>
         <db:note>
            <db:para> The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
         </db:note>
         <db:para>This function ignores leading and trailing whitespace.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number" xrefstyle="function" annotations="number()">number()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="toFloat">
         <db:title>float toFloat(bool *ok) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>float</db:type>
            <db:methodname>toFloat</db:methodname>
            <db:methodparam>
               <db:type>bool *</db:type>
               <db:parameter>ok</db:parameter>
               <db:initializer>nullptr</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns the byte array converted to a <db:code>float</db:code> value.</db:para>
         <db:para>Returns an infinity if the conversion overflows or 0.0 if the conversion fails for other reasons (e.g. underflow).</db:para>
         <db:para>If <db:code role="argument">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="argument">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="argument">ok</db:code> to <db:code>true</db:code>.</db:para>
         <db:programlisting language="other">QByteArray string("1234.56");
bool ok;
float a = string.toFloat(&amp;ok);    // a == 1234.56, ok == true

string = "1234.56 Volt";
a = str.toFloat(&amp;ok);              // a == 0, ok == false</db:programlisting>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> The <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> content may only contain valid numerical characters which includes the plus/minus sign, the character e used in scientific notation, and the decimal point. Including the unit or additional characters leads to a conversion error.</db:para>
         <db:note>
            <db:para> The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
         </db:note>
         <db:para>This function ignores leading and trailing whitespace.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number" xrefstyle="function" annotations="number()">number()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="capacity">
         <db:title>int capacity() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>capacity</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns the maximum number of bytes that can be stored in the byte array without forcing a reallocation.</db:para>
         <db:para>The sole purpose of this function is to provide a means of fine tuning <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many bytes are in the byte array, call <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#reserve" xrefstyle="function" annotations="reserve()">reserve()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#squeeze" xrefstyle="function" annotations="squeeze()">squeeze()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="compare-1">
         <db:title>int compare(const QByteArray &amp;a, Qt::CaseSensitivity cs) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>compare</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>a</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>Qt::CaseSensitivity</db:type>
               <db:parameter>cs</db:parameter>
               <db:initializer>...</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns an integer less than, equal to, or greater than zero depending on whether this <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> sorts before, at the same position, or after the <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>
            <db:code role="argument">a</db:code>. The comparison is performed according to case sensitivity <db:code role="argument">cs</db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-eq-eq" xrefstyle="function" annotations="operator==">operator==</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.12.</db:para>
      </db:section>
      <db:section xml:id="compare">
         <db:title>int compare(const char *c, Qt::CaseSensitivity cs) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>compare</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>c</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>Qt::CaseSensitivity</db:type>
               <db:parameter>cs</db:parameter>
               <db:initializer>...</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns an integer less than, equal to, or greater than zero depending on whether this <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> sorts before, at the same position, or after the string pointed to by <db:code role="argument">c</db:code>. The comparison is performed according to case sensitivity <db:code role="argument">cs</db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#operator-eq-eq" xrefstyle="function" annotations="operator==">operator==</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.12.</db:para>
      </db:section>
      <db:section xml:id="count-3">
         <db:title>int count() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>count</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Same as <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>.</db:para>
      </db:section>
      <db:section xml:id="count-1">
         <db:title>int count(char ch) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>count</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns the number of occurrences of character <db:code role="argument">ch</db:code> in the byte array.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#contains" xrefstyle="function" annotations="contains()">contains()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#indexOf" xrefstyle="function" annotations="indexOf()">indexOf()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="count">
         <db:title>int count(const QByteArray &amp;ba) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>count</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>ba</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns the number of (potentially overlapping) occurrences of byte array <db:code role="argument">ba</db:code> in this byte array.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#contains" xrefstyle="function" annotations="contains()">contains()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#indexOf" xrefstyle="function" annotations="indexOf()">indexOf()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="count-2">
         <db:title>int count(const char *str) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>count</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns the number of (potentially overlapping) occurrences of string <db:code role="argument">str</db:code> in the byte array.</db:para>
      </db:section>
      <db:section xml:id="indexOf-1">
         <db:title>int indexOf(char ch, int from) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>indexOf</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>from</db:parameter>
               <db:initializer>0</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns the index position of the first occurrence of the character <db:code role="argument">ch</db:code> in the byte array, searching forward from index position <db:code role="argument">from</db:code>. Returns -1 if <db:code role="argument">ch</db:code> could not be found.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray ba("ABCBA");
ba.indexOf("B");            // returns 1
ba.indexOf("B", 1);         // returns 1
ba.indexOf("B", 2);         // returns 3
ba.indexOf("X");            // returns -1</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#lastIndexOf" xrefstyle="function" annotations="lastIndexOf()">lastIndexOf()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#contains" xrefstyle="function" annotations="contains()">contains()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="indexOf">
         <db:title>int indexOf(const QByteArray &amp;ba, int from) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>indexOf</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>ba</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>from</db:parameter>
               <db:initializer>0</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns the index position of the first occurrence of the byte array <db:code role="argument">ba</db:code> in this byte array, searching forward from index position <db:code role="argument">from</db:code>. Returns -1 if <db:code role="argument">ba</db:code> could not be found.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray x("sticky question");
QByteArray y("sti");
x.indexOf(y);               // returns 0
x.indexOf(y, 1);            // returns 10
x.indexOf(y, 10);           // returns 10
x.indexOf(y, 11);           // returns -1</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#lastIndexOf" xrefstyle="function" annotations="lastIndexOf()">lastIndexOf()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#contains" xrefstyle="function" annotations="contains()">contains()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#count-3" xrefstyle="function" annotations="count()">count()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="indexOf-3">
         <db:title>int indexOf(const QString &amp;str, int from) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>indexOf</db:methodname>
            <db:methodparam>
               <db:type>const QString &amp;</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>from</db:parameter>
               <db:initializer>0</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns the index position of the first occurrence of the string <db:code role="argument">str</db:code> in the byte array, searching forward from index position <db:code role="argument">from</db:code>. Returns -1 if <db:code role="argument">str</db:code> could not be found.</db:para>
         <db:para>The Unicode data is converted into 8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code>.</db:para>
         <db:para>You can disable this function by defining <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code> (or <db:code><db:link xlink:href="qstring.html#toLatin1" xrefstyle="function" annotations="QString::toLatin1()">QString::toLatin1()</db:link></db:code> or <db:code><db:link xlink:href="qstring.html#toLocal8Bit" xrefstyle="function" annotations="QString::toLocal8Bit()">QString::toLocal8Bit()</db:link></db:code>) explicitly if you want to convert the data to <db:code>const char *</db:code>.</db:para>
      </db:section>
      <db:section xml:id="indexOf-2">
         <db:title>int indexOf(const char *str, int from) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>indexOf</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>from</db:parameter>
               <db:initializer>0</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns the index position of the first occurrence of the string <db:code role="argument">str</db:code> in the byte array, searching forward from index position <db:code role="argument">from</db:code>. Returns -1 if <db:code role="argument">str</db:code> could not be found.</db:para>
      </db:section>
      <db:section xml:id="lastIndexOf-1">
         <db:title>int lastIndexOf(char ch, int from) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>lastIndexOf</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>from</db:parameter>
               <db:initializer>-1</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns the index position of the last occurrence of character <db:code role="argument">ch</db:code> in the byte array, searching backward from index position <db:code role="argument">from</db:code>. If <db:code role="argument">from</db:code> is -1 (the default), the search starts at the last (<db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code> - 1) byte. Returns -1 if <db:code role="argument">ch</db:code> could not be found.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray ba("ABCBA");
ba.lastIndexOf("B");        // returns 3
ba.lastIndexOf("B", 3);     // returns 3
ba.lastIndexOf("B", 2);     // returns 1
ba.lastIndexOf("X");        // returns -1</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#indexOf" xrefstyle="function" annotations="indexOf()">indexOf()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#contains" xrefstyle="function" annotations="contains()">contains()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="lastIndexOf">
         <db:title>int lastIndexOf(const QByteArray &amp;ba, int from) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>lastIndexOf</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>ba</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>from</db:parameter>
               <db:initializer>-1</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns the index position of the last occurrence of the byte array <db:code role="argument">ba</db:code> in this byte array, searching backward from index position <db:code role="argument">from</db:code>. If <db:code role="argument">from</db:code> is -1 (the default), the search starts at the last byte. Returns -1 if <db:code role="argument">ba</db:code> could not be found.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray x("crazy azimuths");
QByteArray y("az");
x.lastIndexOf(y);           // returns 6
x.lastIndexOf(y, 6);        // returns 6
x.lastIndexOf(y, 5);        // returns 2
x.lastIndexOf(y, 1);        // returns -1</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#indexOf" xrefstyle="function" annotations="indexOf()">indexOf()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#contains" xrefstyle="function" annotations="contains()">contains()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#count-3" xrefstyle="function" annotations="count()">count()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="lastIndexOf-3">
         <db:title>int lastIndexOf(const QString &amp;str, int from) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>lastIndexOf</db:methodname>
            <db:methodparam>
               <db:type>const QString &amp;</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>from</db:parameter>
               <db:initializer>-1</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns the index position of the last occurrence of the string <db:code role="argument">str</db:code> in the byte array, searching backward from index position <db:code role="argument">from</db:code>. If <db:code role="argument">from</db:code> is -1 (the default), the search starts at the last (<db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code> - 1) byte. Returns -1 if <db:code role="argument">str</db:code> could not be found.</db:para>
         <db:para>The Unicode data is converted into 8-bit characters using <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code>.</db:para>
         <db:para>You can disable this function by defining <db:code>QT_NO_CAST_TO_ASCII</db:code> when you compile your applications. You then need to call <db:code><db:link xlink:href="qstring.html#toUtf8" xrefstyle="function" annotations="QString::toUtf8()">QString::toUtf8()</db:link></db:code> (or <db:code><db:link xlink:href="qstring.html#toLatin1" xrefstyle="function" annotations="QString::toLatin1()">QString::toLatin1()</db:link></db:code> or <db:code><db:link xlink:href="qstring.html#toLocal8Bit" xrefstyle="function" annotations="QString::toLocal8Bit()">QString::toLocal8Bit()</db:link></db:code>) explicitly if you want to convert the data to <db:code>const char *</db:code>.</db:para>
      </db:section>
      <db:section xml:id="lastIndexOf-2">
         <db:title>int lastIndexOf(const char *str, int from) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>lastIndexOf</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>from</db:parameter>
               <db:initializer>-1</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Returns the index position of the last occurrence of the string <db:code role="argument">str</db:code> in the byte array, searching backward from index position <db:code role="argument">from</db:code>. If <db:code role="argument">from</db:code> is -1 (the default), the search starts at the last (<db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code> - 1) byte. Returns -1 if <db:code role="argument">str</db:code> could not be found.</db:para>
      </db:section>
      <db:section xml:id="length">
         <db:title>int length() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>length</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Same as <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>.</db:para>
      </db:section>
      <db:section xml:id="size">
         <db:title>int size() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>size</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns the number of bytes in this byte array.</db:para>
         <db:para>The last byte in the byte array is at position  - 1. In addition, <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> ensures that the byte at position  is always '\0', so that you can use the return value of <db:code><db:link xlink:href="qbytearray.html#data" xrefstyle="function" annotations="data()">data()</db:link></db:code> and <db:code><db:link xlink:href="qbytearray.html#constData" xrefstyle="function" annotations="constData()">constData()</db:link></db:code> as arguments to functions that expect '\0'-terminated strings. If the <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> object was created from a <db:code><db:link xlink:href="qbytearray.html#fromRawData" xrefstyle="function" annotations="fromRawData()">raw data</db:link></db:code> that didn't include the trailing null-termination character then <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> doesn't add it automaticall unless the <db:link xlink:href="implicit-sharing.html#deep-copy" xrefstyle="page" annotations="deep copy">deep copy</db:link> is created.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray ba("Hello");
int n = ba.size();          // n == 5
ba.data()[0];               // returns 'H'
ba.data()[4];               // returns 'o'
ba.data()[5];               // returns '\0'</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#isEmpty" xrefstyle="function" annotations="isEmpty()">isEmpty()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#resize" xrefstyle="function" annotations="resize()">resize()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="toInt">
         <db:title>int toInt(bool *ok, int base) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>int</db:type>
            <db:methodname>toInt</db:methodname>
            <db:methodparam>
               <db:type>bool *</db:type>
               <db:parameter>ok</db:parameter>
               <db:initializer>nullptr</db:initializer>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns the byte array converted to an <db:code>int</db:code> using base <db:code role="argument">base</db:code>, which is 10 by default and must be between 2 and 36, or 0.</db:para>
         <db:para>If <db:code role="argument">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
         <db:para>Returns 0 if the conversion fails.</db:para>
         <db:para>If <db:code role="argument">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="argument">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="argument">ok</db:code> to <db:code>true</db:code>.</db:para>
         <db:programlisting language="other">QByteArray str("FF");
bool ok;
int hex = str.toInt(&amp;ok, 16);     // hex == 255, ok == true
int dec = str.toInt(&amp;ok, 10);     // dec == 0, ok == false</db:programlisting>
         <db:note>
            <db:para> The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number" xrefstyle="function" annotations="number()">number()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="toLong">
         <db:title>long toLong(bool *ok, int base) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>long</db:type>
            <db:methodname>toLong</db:methodname>
            <db:methodparam>
               <db:type>bool *</db:type>
               <db:parameter>ok</db:parameter>
               <db:initializer>nullptr</db:initializer>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns the byte array converted to a <db:code>long</db:code> int using base <db:code role="argument">base</db:code>, which is 10 by default and must be between 2 and 36, or 0.</db:para>
         <db:para>If <db:code role="argument">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
         <db:para>Returns 0 if the conversion fails.</db:para>
         <db:para>If <db:code role="argument">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="argument">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="argument">ok</db:code> to <db:code>true</db:code>.</db:para>
         <db:programlisting language="other">QByteArray str("FF");
bool ok;
long hex = str.toLong(&amp;ok, 16);   // hex == 255, ok == true
long dec = str.toLong(&amp;ok, 10);   // dec == 0, ok == false</db:programlisting>
         <db:note>
            <db:para> The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number" xrefstyle="function" annotations="number()">number()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 4.1.</db:para>
      </db:section>
      <db:section xml:id="toLongLong">
         <db:title>qlonglong toLongLong(bool *ok, int base) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>qlonglong</db:type>
            <db:methodname>toLongLong</db:methodname>
            <db:methodparam>
               <db:type>bool *</db:type>
               <db:parameter>ok</db:parameter>
               <db:initializer>nullptr</db:initializer>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns the byte array converted to a <db:code>long long</db:code> using base <db:code role="argument">base</db:code>, which is 10 by default and must be between 2 and 36, or 0.</db:para>
         <db:para>If <db:code role="argument">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
         <db:para>Returns 0 if the conversion fails.</db:para>
         <db:para>If <db:code role="argument">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="argument">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="argument">ok</db:code> to <db:code>true</db:code>.</db:para>
         <db:note>
            <db:para> The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number" xrefstyle="function" annotations="number()">number()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="toULongLong">
         <db:title>qulonglong toULongLong(bool *ok, int base) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>qulonglong</db:type>
            <db:methodname>toULongLong</db:methodname>
            <db:methodparam>
               <db:type>bool *</db:type>
               <db:parameter>ok</db:parameter>
               <db:initializer>nullptr</db:initializer>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns the byte array converted to an <db:code>unsigned long long</db:code> using base <db:code role="argument">base</db:code>, which is 10 by default and must be between 2 and 36, or 0.</db:para>
         <db:para>If <db:code role="argument">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
         <db:para>Returns 0 if the conversion fails.</db:para>
         <db:para>If <db:code role="argument">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="argument">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="argument">ok</db:code> to <db:code>true</db:code>.</db:para>
         <db:note>
            <db:para> The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number" xrefstyle="function" annotations="number()">number()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="toShort">
         <db:title>short toShort(bool *ok, int base) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>short</db:type>
            <db:methodname>toShort</db:methodname>
            <db:methodparam>
               <db:type>bool *</db:type>
               <db:parameter>ok</db:parameter>
               <db:initializer>nullptr</db:initializer>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns the byte array converted to a <db:code>short</db:code> using base <db:code role="argument">base</db:code>, which is 10 by default and must be between 2 and 36, or 0.</db:para>
         <db:para>If <db:code role="argument">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
         <db:para>Returns 0 if the conversion fails.</db:para>
         <db:para>If <db:code role="argument">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="argument">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="argument">ok</db:code> to <db:code>true</db:code>.</db:para>
         <db:note>
            <db:para> The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number" xrefstyle="function" annotations="number()">number()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="toStdString">
         <db:title>std::string toStdString() const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>std::string</db:type>
            <db:methodname>toStdString</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Returns a std::string object with the data contained in this <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>.</db:para>
         <db:para>This operator is mostly useful to pass a <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> to a function that accepts a std::string object.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#fromStdString" xrefstyle="function" annotations="fromStdString()">fromStdString()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qstring.html#toStdString" xrefstyle="function" annotations="QString::toStdString()">QString::toStdString()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.4.</db:para>
      </db:section>
      <db:section xml:id="toUInt">
         <db:title>uint toUInt(bool *ok, int base) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>uint</db:type>
            <db:methodname>toUInt</db:methodname>
            <db:methodparam>
               <db:type>bool *</db:type>
               <db:parameter>ok</db:parameter>
               <db:initializer>nullptr</db:initializer>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns the byte array converted to an <db:code>unsigned int</db:code> using base <db:code role="argument">base</db:code>, which is 10 by default and must be between 2 and 36, or 0.</db:para>
         <db:para>If <db:code role="argument">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
         <db:para>Returns 0 if the conversion fails.</db:para>
         <db:para>If <db:code role="argument">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="argument">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="argument">ok</db:code> to <db:code>true</db:code>.</db:para>
         <db:note>
            <db:para> The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number" xrefstyle="function" annotations="number()">number()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="toULong">
         <db:title>ulong toULong(bool *ok, int base) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>ulong</db:type>
            <db:methodname>toULong</db:methodname>
            <db:methodparam>
               <db:type>bool *</db:type>
               <db:parameter>ok</db:parameter>
               <db:initializer>nullptr</db:initializer>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns the byte array converted to an <db:code>unsigned long int</db:code> using base <db:code role="argument">base</db:code>, which is 10 by default and must be between 2 and 36, or 0.</db:para>
         <db:para>If <db:code role="argument">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
         <db:para>Returns 0 if the conversion fails.</db:para>
         <db:para>If <db:code role="argument">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="argument">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="argument">ok</db:code> to <db:code>true</db:code>.</db:para>
         <db:note>
            <db:para> The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number" xrefstyle="function" annotations="number()">number()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 4.1.</db:para>
      </db:section>
      <db:section xml:id="toUShort">
         <db:title>ushort toUShort(bool *ok, int base) const</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:type>ushort</db:type>
            <db:methodname>toUShort</db:methodname>
            <db:methodparam>
               <db:type>bool *</db:type>
               <db:parameter>ok</db:parameter>
               <db:initializer>nullptr</db:initializer>
            </db:methodparam>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>base</db:parameter>
               <db:initializer>10</db:initializer>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Returns the byte array converted to an <db:code>unsigned short</db:code> using base <db:code role="argument">base</db:code>, which is 10 by default and must be between 2 and 36, or 0.</db:para>
         <db:para>If <db:code role="argument">base</db:code> is 0, the base is determined automatically using the following rules: If the byte array begins with "0x", it is assumed to be hexadecimal; if it begins with "0", it is assumed to be octal; otherwise it is assumed to be decimal.</db:para>
         <db:para>Returns 0 if the conversion fails.</db:para>
         <db:para>If <db:code role="argument">ok</db:code> is not <db:code>nullptr</db:code>, failure is reported by setting *<db:code role="argument">ok</db:code> to <db:code>false</db:code>, and success by setting *<db:code role="argument">ok</db:code> to <db:code>true</db:code>.</db:para>
         <db:note>
            <db:para> The conversion of the number is performed in the default C locale, irrespective of the user's locale.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#number" xrefstyle="function" annotations="number()">number()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="chop">
         <db:title>void chop(int n)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:void/>
            <db:methodname>chop</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>n</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Removes <db:code role="argument">n</db:code> bytes from the end of the byte array.</db:para>
         <db:para>If <db:code role="argument">n</db:code> is greater than <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>, the result is an empty byte array.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray ba("STARTTLS\r\n");
ba.chop(2);                 // ba == "STARTTLS"</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#truncate" xrefstyle="function" annotations="truncate()">truncate()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#resize" xrefstyle="function" annotations="resize()">resize()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#left" xrefstyle="function" annotations="left()">left()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="clear">
         <db:title>void clear()</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:void/>
            <db:methodname>clear</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Clears the contents of the byte array and makes it null.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#resize" xrefstyle="function" annotations="resize()">resize()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#isNull" xrefstyle="function" annotations="isNull()">isNull()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="push_back-1">
         <db:title>void push_back(char ch)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:void/>
            <db:methodname>push_back</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Same as append(<db:code role="argument">ch</db:code>).</db:para>
      </db:section>
      <db:section xml:id="push_back">
         <db:title>void push_back(const QByteArray &amp;other)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:void/>
            <db:methodname>push_back</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>other</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This function is provided for STL compatibility. It is equivalent to append(<db:code role="argument">other</db:code>).</db:para>
      </db:section>
      <db:section xml:id="push_back-2">
         <db:title>void push_back(const char *str)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:void/>
            <db:methodname>push_back</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Same as append(<db:code role="argument">str</db:code>).</db:para>
      </db:section>
      <db:section xml:id="push_front-1">
         <db:title>void push_front(char ch)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:void/>
            <db:methodname>push_front</db:methodname>
            <db:methodparam>
               <db:type>char</db:type>
               <db:parameter>ch</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Same as prepend(<db:code role="argument">ch</db:code>).</db:para>
      </db:section>
      <db:section xml:id="push_front">
         <db:title>void push_front(const QByteArray &amp;other)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:void/>
            <db:methodname>push_front</db:methodname>
            <db:methodparam>
               <db:type>const QByteArray &amp;</db:type>
               <db:parameter>other</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This function is provided for STL compatibility. It is equivalent to prepend(<db:code role="argument">other</db:code>).</db:para>
      </db:section>
      <db:section xml:id="push_front-2">
         <db:title>void push_front(const char *str)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:void/>
            <db:methodname>push_front</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>str</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This is an overloaded function.</db:para>
         <db:para>Same as prepend(<db:code role="argument">str</db:code>).</db:para>
      </db:section>
      <db:section xml:id="reserve">
         <db:title>void reserve(int size)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:void/>
            <db:methodname>reserve</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>size</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Attempts to allocate memory for at least <db:code role="argument">size</db:code> bytes. If you know in advance how large the byte array will be, you can call this function, and if you call <db:code><db:link xlink:href="qbytearray.html#resize" xrefstyle="function" annotations="resize()">resize()</db:link></db:code> often you are likely to get better performance. If <db:code role="argument">size</db:code> is an underestimate, the worst that will happen is that the <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code> will be a bit slower.</db:para>
         <db:para>The sole purpose of this function is to provide a means of fine tuning <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>'s memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the byte array, call <db:code><db:link xlink:href="qbytearray.html#resize" xrefstyle="function" annotations="resize()">resize()</db:link></db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#squeeze" xrefstyle="function" annotations="squeeze()">squeeze()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#capacity" xrefstyle="function" annotations="capacity()">capacity()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="resize">
         <db:title>void resize(int size)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:void/>
            <db:methodname>resize</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>size</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Sets the size of the byte array to <db:code role="argument">size</db:code> bytes.</db:para>
         <db:para>If <db:code role="argument">size</db:code> is greater than the current size, the byte array is extended to make it <db:code role="argument">size</db:code> bytes with the extra bytes added to the end. The new bytes are uninitialized.</db:para>
         <db:para>If <db:code role="argument">size</db:code> is less than the current size, bytes are removed from the end.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#size" xrefstyle="function" annotations="size()">size()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#truncate" xrefstyle="function" annotations="truncate()">truncate()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="shrink_to_fit">
         <db:title>void shrink_to_fit()</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:void/>
            <db:methodname>shrink_to_fit</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>This function is provided for STL compatibility. It is equivalent to <db:code><db:link xlink:href="qbytearray.html#squeeze" xrefstyle="function" annotations="squeeze()">squeeze()</db:link></db:code>.</db:para>
         <db:para>This property was introduced in Qt 5.10.</db:para>
      </db:section>
      <db:section xml:id="squeeze">
         <db:title>void squeeze()</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:void/>
            <db:methodname>squeeze</db:methodname>
            <db:void/>
         </db:methodsynopsis>
         <db:para>Releases any memory not required to store the array's data.</db:para>
         <db:para>The sole purpose of this function is to provide a means of fine tuning <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>'s memory usage. In general, you will rarely ever need to call this function.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#reserve" xrefstyle="function" annotations="reserve()">reserve()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#capacity" xrefstyle="function" annotations="capacity()">capacity()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section xml:id="swap">
         <db:title>void swap(QByteArray &amp;other)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:void/>
            <db:methodname>swap</db:methodname>
            <db:methodparam>
               <db:type>QByteArray &amp;</db:type>
               <db:parameter>other</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Swaps byte array <db:code role="argument">other</db:code> with this byte array. This operation is very fast and never fails.</db:para>
         <db:para>This property was introduced in Qt 4.8.</db:para>
      </db:section>
      <db:section xml:id="truncate">
         <db:title>void truncate(int pos)</db:title>
         <db:methodsynopsis>
            <db:modifier/>
            <db:modifier>public</db:modifier>
            <db:modifier>delete</db:modifier>
            <db:modifier>default</db:modifier>
            <db:modifier>overload</db:modifier>
            <db:void/>
            <db:methodname>truncate</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>pos</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>Truncates the byte array at index position <db:code role="argument">pos</db:code>.</db:para>
         <db:para>If <db:code role="argument">pos</db:code> is beyond the end of the array, nothing happens.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting language="other">QByteArray ba("Stockholm");
ba.truncate(5);             // ba == "Stock"</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#chop" xrefstyle="function" annotations="chop()">chop()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#resize" xrefstyle="function" annotations="resize()">resize()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qbytearray.html#left" xrefstyle="function" annotations="left()">left()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
   </db:section>
   <db:section>
      <db:title>Types Documentation</db:title>
      <db:section xml:id="Base64Option-enum">
         <db:title>enum QByteArray::Base64Option, flags QByteArray::Base64Options</db:title>
         <db:enumsynopsis>
            <db:enumname>QByteArray::Base64Option</db:enumname>
            <db:enumsynopsisinfo role="since">5.2</db:enumsynopsisinfo>
            <db:enumitem>
               <db:enumidentifier>Base64Encoding</db:enumidentifier>
               <db:enumvalue>0</db:enumvalue>
            </db:enumitem>
            <db:enumitem>
               <db:enumidentifier>Base64UrlEncoding</db:enumidentifier>
               <db:enumvalue>1</db:enumvalue>
            </db:enumitem>
            <db:enumitem>
               <db:enumidentifier>KeepTrailingEquals</db:enumidentifier>
               <db:enumvalue>0</db:enumvalue>
            </db:enumitem>
            <db:enumitem>
               <db:enumidentifier>OmitTrailingEquals</db:enumidentifier>
               <db:enumvalue>2</db:enumvalue>
            </db:enumitem>
         </db:enumsynopsis>
         <db:typedefsynopsis>
            <db:typedefname>QByteArray::reference</db:typedefname>
         </db:typedefsynopsis>
         <db:para>This enum contains the options available for encoding and decoding Base64. Base64 is defined by <db:link xlink:href="http://www.ietf.org/rfc/rfc4648.txt" xrefstyle="" annotations="RFC 4648">RFC 4648</db:link>, with the following options:</db:para>
         <db:informaltable>
            <db:thead>
               <db:tr>
                  <db:th>
                     <db:para>Constant</db:para>
                  </db:th>
                  <db:th>
                     <db:para>Value</db:para>
                  </db:th>
                  <db:th>
                     <db:para>Description</db:para>
                  </db:th>
               </db:tr>
            </db:thead>
            <db:tbody>
               <db:tr>
                  <db:td>QByteArray::Base64Encoding</db:td>
                  <db:td>0</db:td>
                  <db:td>
                     <db:para>(default) The regular Base64 alphabet, called simply "base64"</db:para>
                  </db:td>
               </db:tr>
               <db:tr>
                  <db:td>QByteArray::Base64UrlEncoding</db:td>
                  <db:td>1</db:td>
                  <db:td>
                     <db:para>An alternate alphabet, called "base64url", which replaces two characters in the alphabet to be more friendly to URLs.</db:para>
                  </db:td>
               </db:tr>
               <db:tr>
                  <db:td>QByteArray::KeepTrailingEquals</db:td>
                  <db:td>0</db:td>
                  <db:td>
                     <db:para>(default) Keeps the trailing padding equal signs at the end of the encoded data, so the data is always a size multiple of four.</db:para>
                  </db:td>
               </db:tr>
               <db:tr>
                  <db:td>QByteArray::OmitTrailingEquals</db:td>
                  <db:td>2</db:td>
                  <db:td>
                     <db:para>Omits adding the padding equal signs at the end of the encoded data.</db:para>
                  </db:td>
               </db:tr>
            </db:tbody>
         </db:informaltable>
         <db:para>
            <db:code><db:link xlink:href="qbytearray.html#fromBase64" xrefstyle="function" annotations="QByteArray::fromBase64()">QByteArray::fromBase64()</db:link></db:code> ignores the  and  options and will not flag errors in case they are missing or if there are too many of them.</db:para>
         <db:para>This enum was introduced or modified in Qt 5.2.</db:para>
         <db:para>The <db:code>reference</db:code> type is a typedef for <db:code>QFlags&lt;Base64Option&gt;</db:code>. It stores an OR combination of  values.</db:para>
      </db:section>
      <db:section xml:id="const_iterator-typedef">
         <db:title>typedef const_iterator</db:title>
         <db:typedefsynopsis>
            <db:typedefname>QByteArray::const_iterator</db:typedefname>
         </db:typedefsynopsis>
         <db:typedefsynopsis>
            <db:typedefname>QByteArray::Base64Options</db:typedefname>
         </db:typedefsynopsis>
         <db:para>This typedef provides an STL-style const iterator for <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:link xlink:href="qbytearray.html#const_reverse_iterator-typedef" xrefstyle="typedef" annotations="QByteArray::const_reverse_iterator">QByteArray::const_reverse_iterator</db:link>
               </db:member>
               <db:member>
                  <db:link xlink:href="qbytearray.html#iterator-typedef" xrefstyle="typedef" annotations="QByteArray::iterator">QByteArray::iterator</db:link>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>The <db:code>Base64Options</db:code> type is a typedef for <db:code>QFlags&lt;const_iterator&gt;</db:code>. It stores an OR combination of  values.</db:para>
      </db:section>
      <db:section xml:id="const_reverse_iterator-typedef">
         <db:title>typedef const_reverse_iterator</db:title>
         <db:typedefsynopsis>
            <db:typedefname>QByteArray::const_reverse_iterator</db:typedefname>
         </db:typedefsynopsis>
         <db:para>This typedef provides an STL-style const reverse iterator for <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:link xlink:href="qbytearray.html#reverse_iterator-typedef" xrefstyle="typedef" annotations="QByteArray::reverse_iterator">QByteArray::reverse_iterator</db:link>
               </db:member>
               <db:member>
                  <db:link xlink:href="qbytearray.html#const_iterator-typedef" xrefstyle="typedef" annotations="QByteArray::const_iterator">QByteArray::const_iterator</db:link>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This enum was introduced or modified in Qt 5.6.</db:para>
      </db:section>
      <db:section xml:id="iterator-typedef">
         <db:title>typedef iterator</db:title>
         <db:typedefsynopsis>
            <db:typedefname>QByteArray::iterator</db:typedefname>
         </db:typedefsynopsis>
         <db:typedefsynopsis>
            <db:typedefname>QByteArray::Data</db:typedefname>
         </db:typedefsynopsis>
         <db:para>This typedef provides an STL-style non-const iterator for <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:link xlink:href="qbytearray.html#reverse_iterator-typedef" xrefstyle="typedef" annotations="QByteArray::reverse_iterator">QByteArray::reverse_iterator</db:link>
               </db:member>
               <db:member>
                  <db:link xlink:href="qbytearray.html#const_iterator-typedef" xrefstyle="typedef" annotations="QByteArray::const_iterator">QByteArray::const_iterator</db:link>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>The <db:code>Data</db:code> type is a typedef for <db:code>QFlags&lt;iterator&gt;</db:code>. It stores an OR combination of  values.</db:para>
      </db:section>
      <db:section xml:id="reverse_iterator-typedef">
         <db:title>typedef reverse_iterator</db:title>
         <db:typedefsynopsis>
            <db:typedefname>QByteArray::reverse_iterator</db:typedefname>
         </db:typedefsynopsis>
         <db:typedefsynopsis>
            <db:typedefname>QByteArray::const_reference</db:typedefname>
         </db:typedefsynopsis>
         <db:para>This typedef provides an STL-style non-const reverse iterator for <db:code><db:link xlink:href="qbytearray.html" xrefstyle="class" annotations="QByteArray">QByteArray</db:link></db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert" role="see-also">
               <db:member>
                  <db:link xlink:href="qbytearray.html#const_reverse_iterator-typedef" xrefstyle="typedef" annotations="QByteArray::const_reverse_iterator">QByteArray::const_reverse_iterator</db:link>
               </db:member>
               <db:member>
                  <db:link xlink:href="qbytearray.html#iterator-typedef" xrefstyle="typedef" annotations="QByteArray::iterator">QByteArray::iterator</db:link>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This enum was introduced or modified in Qt 5.6.</db:para>
         <db:para>The <db:code>const_reference</db:code> type is a typedef for <db:code>QFlags&lt;reverse_iterator&gt;</db:code>. It stores an OR combination of  values.</db:para>
      </db:section>
   </db:section>
</db:article>
