<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink"
  version="5.2"
  xml:lang="en">
  <db:info>
    <db:title>COM App Example (ActiveQt)</db:title>
    <db:abstract>
      <db:para>COM App example shows how to use ActiveQt to develop a Qt application that can be automated via COM. Different QObject based classes are exposed as COM objects that communicate with the GUI of the running Qt application. The APIs of those COM objects has been designed to resemble the APIs of standard COM applications; i.e. those from Microsoft Office</db:para>
    </db:abstract>
    <db:pubdate>2018-09-26+02:00</db:pubdate>
    <db:date>2018-09-26+02:00</db:date>
    <db:productname>Qt</db:productname>
    <db:productnumber>1.2</db:productnumber>
  </db:info>
  <db:para>The COM App example shows how to use <db:link xlink:href="activeqt-index.html" xrefstyle="page" annotations="ActiveQt">ActiveQt</db:link> to develop a Qt application that can be automated via COM. Different <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> based classes are exposed as COM objects that communicate with the GUI of the running Qt application. The APIs of those COM objects has been designed to resemble the APIs of standard COM applications; i.e. those from Microsoft Office.</db:para>
  <db:programlisting>
    class Application : public QObject
    {
    Q_OBJECT
    
    Q_CLASSINFO("ClassID", "{b50a71db-c4a7-4551-8d14-49983566afee}")
    Q_CLASSINFO("InterfaceID", "{4a427759-16ef-4ed8-be79-59ffe5789042}")
    Q_CLASSINFO("RegisterObject", "yes")
    
    Q_PROPERTY(DocumentList* documents READ documents)
    Q_PROPERTY(QString id READ id)
    Q_PROPERTY(bool visible READ isVisible WRITE setVisible)
    
    public:
    explicit Application(QObject *parent = nullptr);
    DocumentList *documents() const;
    
    QString id() const { return objectName(); }
    
    void setVisible(bool on);
    bool isVisible() const;
    
    QTabWidget *window() const { return m_ui.data(); }
    
    public slots:
    void quit();
    
    private:
    QScopedPointer &lt;DocumentList&gt; m_docs;
    QScopedPointer &lt;QTabWidget&gt; m_ui;
    };
  </db:programlisting>
  <db:para>The first class <db:code>Application</db:code> represents the application object. It exposes read-only properties <db:code>documents</db:code> and <db:code>id</db:code> to get access to the list of documents, and an identifier. A read/write property <db:code>visible</db:code> controls whether the <db:code><db:link xlink:href="qtabwidget.html" xrefstyle="class" annotations="QTabWidget">QTabWidget</db:link></db:code>-based user interface of the application should be visible, and a slot <db:code>quit()</db:code> terminates the application.</db:para>
  <db:para>The <db:emphasis>RegisterObject</db:emphasis> attribute is set to make sure that instances of this class are registered in COM's running object table (ROT) - this allows COM clients to connect to an already instantiated COM object.</db:para>
  <db:programlisting>
    class DocumentList : public QObject
    {
    Q_OBJECT
    
    Q_CLASSINFO("ClassID", "{496b761d-924b-4554-a18a-8f3704d2a9a6}")
    Q_CLASSINFO("InterfaceID", "{6c9e30e8-3ff6-4e6a-9edc-d219d074a148}")
    
    Q_PROPERTY(Application* application READ application)
    Q_PROPERTY(int count READ count)
    
    public:
    explicit DocumentList(Application *application);
    
    int count() const;
    Application *application() const;
    
    public slots:
    Document *addDocument();
    Document *item(int index) const;
    
    private:
    QList&lt;Document *&gt; m_list;
    };
  </db:programlisting>
  <db:para>The <db:code>DocumentList</db:code> class stores a list of documents. It provides an API to read the number of documents, to access each document by index and to create a new document. The <db:code>application</db:code> property returns the root object.</db:para>
  <db:programlisting>
    class Document : public QObject
    {
    Q_OBJECT
    
    Q_CLASSINFO("ClassID", "{2b5775cd-72c2-43da-bc3b-b0e8d1e1c4f7}")
    Q_CLASSINFO("InterfaceID", "{2ce1761e-07a3-415c-bd11-0eab2c7283de}")
    
    Q_PROPERTY(Application *application READ application)
    Q_PROPERTY(QString title READ title WRITE setTitle)
    
    public:
    explicit Document(DocumentList *list);
    virtual ~Document();
    
    Application *application() const;
    
    QString title() const;
    void setTitle(const QString &amp;title);
    
    private:
    QScopedPointer &lt;QWidget&gt; m_page;
    };
  </db:programlisting>
  <db:para>The <db:code>Document</db:code> class finally represents a document in the application. Each document is represented by a page in the application's tab widget, and has a title that is readable and writable through the document's API. The <db:code>application</db:code> property again returns the root object.</db:para>
  <db:programlisting>
    Document::Document(DocumentList *list)
    : QObject(list)
    {
    QTabWidget *tabs = list-&gt;application()-&gt;window();
    m_page.reset(new QWidget(tabs));
    m_page-&gt;setWindowTitle(tr("Unnamed"));
    tabs-&gt;addTab(m_page.data(), m_page-&gt;windowTitle());
    
    m_page-&gt;show();
    }
    
    Document::~Document()
    {
    }
    
    Application *Document::application() const
    {
    return qobject_cast&lt;DocumentList *&gt;(parent())-&gt;application();
    }
    
    QString Document::title() const
    {
    return m_page-&gt;windowTitle();
    }
    
    void Document::setTitle(const QString &amp;t)
    {
    m_page-&gt;setWindowTitle(t);
    
    QTabWidget *tabs = application()-&gt;window();
    int index = tabs-&gt;indexOf(m_page.data());
    tabs-&gt;setTabText(index, m_page-&gt;windowTitle());
    }
    
  </db:programlisting>
  <db:para>The implementation of the <db:code>Document</db:code> class creates a new page for the tab widget, and uses the title of that page for the title property. The page is deleted when the document is deleted.</db:para>
  <db:programlisting>
    DocumentList::DocumentList(Application *application)
    : QObject(application)
    {
    }
    
    Application *DocumentList::application() const
    {
    return qobject_cast&lt;Application *&gt;(parent());
    }
    
    int DocumentList::count() const
    {
    return m_list.count();
    }
    
    Document *DocumentList::item(int index) const
    {
    return m_list.value(index, nullptr);
    }
    
    Document *DocumentList::addDocument()
    {
    Document *document = new Document(this);
    m_list.append(document);
    
    return document;
    }
    
  </db:programlisting>
  <db:para>The <db:code>DocumentList</db:code> implementation is straightforward.</db:para>
  <db:programlisting>
    Application::Application(QObject *parent)
    : QObject(parent),
    m_ui(new QTabWidget),
    m_docs(new DocumentList(this))
    {
    setObjectName(QStringLiteral("From QAxFactory"));
    }
    
    DocumentList *Application::documents() const
    {
    return m_docs.data();
    }
    
    void Application::setVisible(bool on)
    {
    m_ui-&gt;setVisible(on);
    }
    
    bool Application::isVisible() const
    {
    return m_ui-&gt;isVisible();
    }
    
    void Application::quit()
    {
    m_docs.reset();
    m_ui.reset();
    QTimer::singleShot(0 /*ms*/, qApp, &amp;QCoreApplication::quit);
    }
    
    #include "main.moc"
  </db:programlisting>
  <db:para>The <db:code>Application</db:code> class initializes the user interface in the constructor, and shows and hides it in the implementation of <db:code>setVisible()</db:code>. The object name (accessible through the <db:code>id</db:code> property) is set to <db:code>"From</db:code>
    <db:code><db:link xlink:href="qaxfactory.html" xrefstyle="class" annotations="QAxFactory">QAxFactory</db:link></db:code>" to indicate that this COM object has been created by COM. Note that there is no destructor that would delete the <db:code><db:link xlink:href="qtabwidget.html" xrefstyle="class" annotations="QTabWidget">QTabWidget</db:link></db:code> - this is instead done in the <db:code>quit()</db:code> slot, before calling <db:code><db:link xlink:href="qcoreapplication.html#quit" xrefstyle="function" annotations="QCoreApplication::quit()">quit()</db:link></db:code> through a single-shot-timer, which is necessary to ensure that the COM call to the slot is complete.</db:para>
  <db:programlisting>
    
    
    QAXFACTORY_BEGIN("{edd3e836-f537-4c6f-be7d-6014c155cc7a}", "{b7da3de8-83bb-4bbe-9ab7-99a05819e201}")
    QAXCLASS(Application)
    QAXTYPE(Document)
    QAXTYPE(DocumentList)
    QAXFACTORY_END()
    
  </db:programlisting>
  <db:para>The classes are exported from the server using the <db:code><db:link xlink:href="qaxfactory.html" xrefstyle="class" annotations="QAxFactory">QAxFactory</db:link></db:code> macros. Only <db:code>Application</db:code> objects can be instantiated from outside - the other APIs can only be used after accessing the respective objects throughout the <db:code>Application</db:code> API.</db:para>
  <db:programlisting>
    int main(int argc, char *argv[])
    {
    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
    QApplication app(argc, argv);
    app.setQuitOnLastWindowClosed(false);
    
    // started by COM - don't do anything
    if (QAxFactory::isServer())
    return app.exec();
    
    // started by user
    Application appobject;
    appobject.setObjectName(QStringLiteral("From Application"));
    
    QAxFactory::startServer();
    QAxFactory::registerActiveObject(&amp;appobject);
    
    appobject.window()-&gt;setMinimumSize(300, 100);
    appobject.setVisible(true);
    
    QObject::connect(&amp;app, &amp;QGuiApplication::lastWindowClosed, &amp;appobject, &amp;Application::quit);
    
    return app.exec();
    }
  </db:programlisting>
  <db:para>The main() entry point function creates a <db:code><db:link xlink:href="qapplication.html" xrefstyle="class" annotations="QApplication">QApplication</db:link></db:code>, and just enters the event loop if the application has been started by COM. If the application has been started by the user, then the <db:code>Application</db:code> object is created and the object name is set to "From Application". Then the COM server is started, and the application object is registered with COM. It is now accessible to COM clients through the client-specific APIs.</db:para>
  <db:para>Application exiting is controlled explicitly - if COM started the application, then the client code has to call quit(); if the user started the application, then the application terminates when the last window has been closed.</db:para>
  <db:para>Finally, the user interface is made visible, and the event loop is started.</db:para>
  <db:para>A simple Visual Basic application could now access this Qt application. In VB, start a new "Standard Exe" project and add a project reference to the comappLib type library. Create a form with a listbox "DocumentList", a static label "DocumentsCount" and a command button "NewDocument". Finally, implement the code for the form like this:</db:para>
  <db:programlisting>
    Private Application As comappLib.Application
    Private MyApp As Boolean
    
    Private Sub UpdateList()
    DocumentList.Clear
    DocumentsCount.Caption = Application.documents.Count
    For Index = 0 To Application.documents.Count - 1
    DocumentList.AddItem (Application.documents.Item(Index).Title)
    Next
    End Sub
    
    Private Sub Form_Load()
    On Error GoTo CreateNew
    Set Application = GetObject(, "comapp.Application")
    MyApp = False
    GoTo Initialized
    CreateNew:
    On Error GoTo InitializeFailed
    Set Application = New Application
    Application.Visible = True
    MyApp = True
    Initialized:
    Caption = Application.id
    UpdateList
    InitializeFailed:
    End Sub
    
    Private Sub Form_Unload(Cancel As Integer)
    If MyApp Then
    Application.quit
    End If
    End Sub
    
    Private Sub NewDocument_Click()
    Application.documents.addDocument
    UpdateList
    End Sub
  </db:programlisting>
  <db:para>To build the example you must first build the <db:link xlink:href="qaxserver-module.html" xrefstyle="module" annotations="QAxServer">QAxServer</db:link> library. Then run <db:code>qmake</db:code> and your make tool in <db:code>examples\activeqt\comapp</db:code>.</db:para>
</db:article>
