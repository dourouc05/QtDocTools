<?xml version="1.0" encoding="UTF-8"?>
<WebXML>
    <document>
        <page name="activeqt-dotnet.html" href="activeqt-dotnet.html" status="active" location="dotnet.qdoc" filepath="C:/Qt/5.11.1/Src/qtactiveqt/src/activeqt/doc/src/examples/dotnet.qdoc" lineno="28" subtype="page" title="Dot Net Example (ActiveQt)" fulltitle="Dot Net Example (ActiveQt)" subtitle="" module="ActiveQt" brief="Dot Net example demonstrates how Qt objects can be used in a .NET environment, and how .NET objects can be used in a Qt environment">
            <contents name="qt-vs-net" title="Qt vs. .NET" level="1"/>
            <contents name="walkthrough-net-interop-with-mc-and-ijw" title="Walkthrough: .NET Interop with MC++ and IJW" level="1"/>
            <contents name="walkthrough-net-com-interop-with-activeqt" title="Walkthrough: .NET/COM Interop with ActiveQt" level="1"/>
            <contents name="starting-a-project" title="Starting a Project" level="2"/>
            <contents name="importing-qt-widgets" title="Importing Qt Widgets" level="2"/>
            <contents name="using-qt-widgets" title="Using Qt Widgets" level="2"/>
            <contents name="handling-qt-signals" title="Handling Qt Signals" level="2"/>
            <contents name="summary" title="Summary" level="1"/>
            <contents name="limitations" title="Limitations" level="2"/>
            <contents name="performance-considerations" title="Performance Considerations" level="2"/>
            <description path="C:/Qt/5.11.1/Src/qtactiveqt/src/activeqt/doc/src/examples/dotnet.qdoc" line="28" column="4">
                <brief>The Dot Net example demonstrates how Qt objects can be used in a .NET environment, and how .NET objects can be used in a Qt environment.</brief>
                <para>Contents:</para>
                <section id="qt-vs-net">
                    <heading level="1">Qt vs. .NET</heading>
                    <para>Qt is a C++ library and is compiled into traditional, native binaries that make full use of the performance provided by the runtime environment.</para>
                    <para>One of the key concepts of .NET is the idea of &quot;intermediate language code&quot; - the source code is compiled into a bytecode format, and at runtime, that bytecode is executed in a virtual machine - the <italic>Common Language Runtime</italic> (CLR).</para>
                    <para>Another key concept is that of <italic>managed code</italic>. This is essentially intermediate language code written in such a way that the CLR can take care of the memory management, i.e. the CLR will do automatic garbage collection, so the application code does not need to explicitly free the memory for unused objects.</para>
                    <para>The MS compilers for C# and VB.NET will only produce managed code. Such programs cannot directly call normal, native functions or classes. <footnote>
                            <para>The .NET framework provides Platform Invocation Services - P/Invoke - that enable managed code to call native C (not C++) functions located in DLLs directly. The resulting application then becomes partially unmanaged.</para>
                        </footnote><para>The MS C++ compiler for .NET on the other hand, can produce both normal and managed code. To write a C++ class that can be compiled into managed code, the developer must flag the class as managed using the <teletype type="highlighted">__gc</teletype> keyword, and restrict the code to only use the subset of C++ known as &quot;Managed Extensions for C++&quot;, or MC++ for short. The advantage is that MC++ code can freely call and use normal C++ functions and classes. And it also works the other way around: normal C++ code can call managed functions and use managed classes (e.g. the entire .NET framework class library), including managed functions and classes implemented in C# or VB.NET. This feature of mixing managed and normal C++ code immensely eases the interoperability with .NET, and is by Microsoft referred to as the &quot;It Just Works&quot; (IJW) feature.</para>
                        <para>This document demonstrates two different ways of integrating normal C++ code (that uses Qt) with managed .NET code. First, the manual way is presented, which includes using a thin MC++ wrapper class around the normal Qt/C++ class. Then, the automated way is presented, which utilizes the <link raw="ActiveQt" href="activeqt-index.html" type="page" page="Active Qt">ActiveQt</link> framework as a generic bridge. The advantage of the first method is that it gives the application developer full control, while the second method requires less coding and relieves the developer of dealing with the conversion between managed and normal data objects.</para>
                        <para>The impatient reader, who right away wants to see a <link raw="QPushButton" href="qpushbutton.html" type="class">QPushButton</link> and a custom Qt widget (<link raw="activeqt/multiple" href="activeqt-activeqt-multiple-example.html" type="page" page="Multiple Example (ActiveQt)">QAxWidget2</link>) run in a .NET GUI application is referred to the example directory of <link raw="ActiveQt" href="activeqt-index.html" type="page" page="Active Qt">ActiveQt</link>. It contains the result of this walkthrough using both C# and VB.NET, created with Visual Studio .NET (not 2003). Load <teletype type="highlighted">examples/dotnet/walkthrough/csharp.csproj</teletype>, <teletype type="highlighted">examples/dotnet/walkthrough/vb.vbproj</teletype> or <teletype type="highlighted">examples/dotnet/wrapper/wrapper.sln</teletype> into the IDE and run the solution.</para>
                        <para>
                            <bold>Remark:</bold> You will notice that in the generated code the following line is commented out:</para>
                        <snippet location="doc_src_examples_activeqt_dotnet.qdoc" path="C:/Qt/5.11.1/Src/qtactiveqt/src/activeqt/doc/snippets/doc_src_examples_activeqt_dotnet.qdoc" identifier="0"/>
                        <para>This line is regenerated without comment whenever you change the dialog, in which case you have to comment it out again to be able to run the project. This is a bug in the original version of Visual Studio.NET, and is fixed in the 2003 edition.</para>
                    </para>
                    <section id="walkthrough-net-interop-with-mc-and-ijw">
                        <heading level="1">Walkthrough: .NET Interop with MC++ and IJW</heading>
                        <para>Normal C++ classes and functions can be used from managed .NET code by providing thin wrapper classes written in MC++. The wrapper class will take care of forwarding the calls to the normal C++ functions or methods, and converting parameter data as necessary. Since the wrapper class is a managed class, it can be used without further ado in any managed .NET application, whether written in C#, VB.NET, MC++ or other managed programming language.</para>
                        <snippet location="activeqt/dotnet/wrapper/lib/worker.h" path="C:/Qt/5.11.1/Src/qtactiveqt/examples/activeqt/dotnet/wrapper/lib/worker.h" identifier="0"/>
                        <para>The Qt class has nothing unusual for Qt users, and as even the Qt specialities like <teletype type="highlighted">Q_PROPERTY</teletype>, <teletype type="highlighted">slots</teletype> and <teletype type="highlighted">signals</teletype> are implemented with straight C++ they don't cause any trouble when compiling this class with any C++ compiler.</para>
                        <snippet location="activeqt/dotnet/wrapper/lib/networker.h" path="C:/Qt/5.11.1/Src/qtactiveqt/examples/activeqt/dotnet/wrapper/lib/networker.h" identifier="0"/>
                        <para>The .NET wrapper class uses keywords that are part of MC++ to indicate that the class is managed/garbage collected (<teletype type="highlighted">__gc</teletype>), and that <teletype type="highlighted">StatusString</teletype> should be accessible as a property in languages that support this concept (<teletype type="highlighted">__property</teletype>). We also declare an event function <teletype type="highlighted">statusStringChanged(String*)</teletype> (<teletype type="highlighted">__event</teletype>), the equivalent of the respective signal in the Qt class.</para>
                        <para>Before we can start implementing the wrapper class we need a way to convert Qt's datatypes (and potentionally your own) into .NET datatypes, e.g. <teletype type="highlighted">QString</teletype> objects need to be converted into objects of type <teletype type="highlighted">String*</teletype>.</para>
                        <para>When operating on managed objects in normal C++ code, a little extra care must be taken because of the CLR's garbage collection. A normal pointer variable should not <footnote>
                                <para>Indeed, the compiler will in many cases disallow it.</para>
                            </footnote> be used to refer to a managed object. The reason is that the garbage collection can kick in at any time and move the object to another place on the heap, leaving you with an invalid pointer.<para>However, two methods are provided that solves this problem easily. The first is to use a <italic>pinned</italic> pointer, i.e. declare the pointer variable with the <teletype type="highlighted">__pin</teletype> keyword. This guarantees that the object pointed to will not be moved by the garbage collector. It is recommended that this method not be used to keep a references to managed objects for a long time, since it will decrease the efficiency of the garbage collector. The second way is to use the <teletype type="highlighted">gcroot</teletype> smartpointer template type. This lets you create safe pointers to managed objects. E.g. a variable of type <teletype type="highlighted">gcroot&lt;String&gt;</teletype> will always point to the String object, even if it has been moved by the garbage collector, and it can be used just like a normal pointer.</para>
                            <snippet location="activeqt/dotnet/wrapper/lib/tools.cpp" path="C:/Qt/5.11.1/Src/qtactiveqt/examples/activeqt/dotnet/wrapper/lib/tools.cpp" identifier="0"/>
                            <codeline> </codeline>
                            <snippet location="activeqt/dotnet/wrapper/lib/tools.cpp" path="C:/Qt/5.11.1/Src/qtactiveqt/examples/activeqt/dotnet/wrapper/lib/tools.cpp" identifier="1"/>
                            <para>The convertor functions can then be used in the wrapper class implementation to call the functions in the native C++ class.</para>
                            <snippet location="activeqt/dotnet/wrapper/lib/networker.cpp" path="C:/Qt/5.11.1/Src/qtactiveqt/examples/activeqt/dotnet/wrapper/lib/networker.cpp" identifier="0"/>
                            <codeline> </codeline>
                            <snippet location="activeqt/dotnet/wrapper/lib/networker.cpp" path="C:/Qt/5.11.1/Src/qtactiveqt/examples/activeqt/dotnet/wrapper/lib/networker.cpp" identifier="1"/>
                            <para>The constructor and destructor simply create and destroy the Qt object wrapped using the C++ operators <teletype type="highlighted">new</teletype> and <teletype type="highlighted">delete</teletype>.</para>
                            <snippet location="activeqt/dotnet/wrapper/lib/networker.cpp" path="C:/Qt/5.11.1/Src/qtactiveqt/examples/activeqt/dotnet/wrapper/lib/networker.cpp" identifier="2"/>
                            <para>The netWorker class delegates calls from the .NET code to the native code. Although the transition between those two worlds implies a small performance hit for each function call, and for the type conversion, this should be negligible since we are anyway going to run within the CLR.</para>
                            <snippet location="activeqt/dotnet/wrapper/lib/networker.cpp" path="C:/Qt/5.11.1/Src/qtactiveqt/examples/activeqt/dotnet/wrapper/lib/networker.cpp" identifier="3"/>
                            <para>The property setter calls the native Qt class before firing the event using the <teletype type="highlighted">__raise</teletype> keyword.</para>
                            <para>This wrapper class can now be used in .NET code, e.g. using C++, C#, Visual Basic or any other programming language available for .NET.</para>
                            <snippet location="activeqt/dotnet/wrapper/main.cs" path="C:/Qt/5.11.1/Src/qtactiveqt/examples/activeqt/dotnet/wrapper/main.cs" identifier="0"/>
                            <snippet location="activeqt/dotnet/wrapper/main.cs" path="C:/Qt/5.11.1/Src/qtactiveqt/examples/activeqt/dotnet/wrapper/main.cs" identifier="1"/>
                            <snippet location="activeqt/dotnet/wrapper/main.cs" path="C:/Qt/5.11.1/Src/qtactiveqt/examples/activeqt/dotnet/wrapper/main.cs" identifier="2"/>
                            <snippet location="activeqt/dotnet/wrapper/main.cs" path="C:/Qt/5.11.1/Src/qtactiveqt/examples/activeqt/dotnet/wrapper/main.cs" identifier="3"/>
                        </para>
                        <section id="walkthrough-net-com-interop-with-activeqt">
                            <heading level="1">Walkthrough: .NET/COM Interop with ActiveQt</heading>
                            <para>Fortunately .NET provides a generic wrapper for COM objects, the <italic>Runtime Callable Wrapper</italic> (RCW). This RCW is a proxy for the COM object and is generated by the CLR when a .NET Framework client activates a COM object. This provides a generic way to reuse COM objects in a .NET Framework project.</para>
                            <para>Making a <link raw="QObject" href="qobject.html" type="class">QObject</link> class into a COM object is easily achieved with <link raw="ActiveQt" href="activeqt-index.html" type="page" page="Active Qt">ActiveQt</link> and demonstrated in the <link raw="QAxServer" href="qaxserver-module.html" type="module">QAxServer</link> examples (e.g., the <link raw="activeqt/simple" href="activeqt-activeqt-simple-example.html" type="page" page="Simple Example (ActiveQt)">Simple</link> example). The walkthrough will use the Qt classes implemented in those examples, so the first thing to do is to make sure that those examples have been built correctly, e.g. by opening the <link raw="qaxserver-demo-multiple.html" href="qaxserver-demo-multiple.html" type="page" page="Two Simple Qt Widgets">demonstration pages</link> in Internet Explorer to verify that the controls are functional.</para>
                        </section>
                        <section id="starting-a-project">
                            <heading level="2">Starting a Project</heading>
                            <para>Start Visual Studio.NET, and create a new C# project for writing a Windows application. This will present you with an empty form in Visual Studio's dialog editor. You should see the toolbox, which presents you with a number of available controls and objects in different categories. If you right-click on the toolbox it allows you to add new tabs. We will add the tab &quot;Qt&quot;.</para>
                        </section>
                        <section id="importing-qt-widgets">
                            <heading level="2">Importing Qt Widgets</heading>
                            <para>The category only has a pointer tool by default, and we have to add the Qt objects we want to use in our form. Right-click on the empty space, and select &quot;Customize&quot;. This opens a dialog that has two tabs, &quot;COM Components&quot; and &quot;.NET Framework Components&quot;. We used <link raw="ActiveQt" href="activeqt-index.html" type="page" page="Active Qt">ActiveQt</link> to wrap <link raw="QWidget" href="qwidget.html" type="class">QWidget</link>s into COM objects, so we select the &quot;COM Components&quot; page, and look for the classes we want to use, e.g. &quot;<link raw="QPushButton" href="qpushbutton.html" type="class">QPushButton</link>&quot; and &quot;QAxWidget2&quot;.</para>
                            <para>When we select those widgets and close the dialog the two widgets will now be available from the toolbox as grey squares with their name next to it <footnote>
                                    <para>Icons could be added by modifying the way the controls register themselves.</para>
                                </footnote>.</para>
                            <section id="using-qt-widgets">
                                <heading level="2">Using Qt Widgets</heading>
                                <para>We can now add an instance of QAxWidget2 and a <link raw="QPushButton" href="qpushbutton.html" type="class">QPushButton</link> to the form. Visual Studio will automatically generate the RCW for the object servers. The QAxWidget2 instance takes most of the upper part of the form, with the <link raw="QPushButton" href="qpushbutton.html" type="class">QPushButton</link> in the lower right corner.</para>
                                <para>In the property editor of Visual Studio we can modify the properties of our controls - <link raw="QPushButton" href="qpushbutton.html" type="class">QPushButton</link> exposes the <teletype type="highlighted">QWidget</teletype> API and has many properties, while QAxWidget2 has only the Visual Studio standard properties in addition to its own property &quot;lineWidth&quot; in the &quot;Miscellaneous&quot; category. The objects are named &quot;axQPushButton1&quot; and &quot;axQAxWidget21&quot;, and since especially the last name is a bit confusing we rename the objects to &quot;resetButton&quot; and &quot;circleWidget&quot;.</para>
                                <para>We can also change the Qt properties, e.g. set the &quot;text&quot; property of the <teletype type="highlighted">resetButton</teletype> to &quot;Reset&quot;, and the &quot;lineWidth&quot; property of the <teletype type="highlighted">circleWidget</teletype> to 5. We can also put those objects into the layout system that Visual Studio's dialog editor provides, e.g. by setting the anchors of the <teletype type="highlighted">circleWidget</teletype> to &quot;Left, Top, Right, Bottom&quot;, and the anchors of the <teletype type="highlighted">resetButton</teletype> to &quot;Bottom, Right&quot;.</para>
                                <para>Now we can compile and start the project, which will open a user interface with our two Qt widgets. If we can resize the dialog, the widgets will resize appropriately.</para>
                            </section>
                            <section id="handling-qt-signals">
                                <heading level="2">Handling Qt Signals</heading>
                                <para>We will now implement event handlers for the widgets. Select the <teletype type="highlighted">circleWidget</teletype> and select the &quot;Events&quot; page in the property editor. The widget exposes events because the QAxWidget2 class has the &quot;StockEvents&quot; attribute set in its class definition. We implement the event handler <teletype type="highlighted">circleClicked</teletype> for the <teletype type="highlighted">ClickEvent</teletype> to increase the line width by one for every click:</para>
                                <snippet location="activeqt/dotnet/walkthrough/Form1.cs" path="C:/Qt/5.11.1/Src/qtactiveqt/examples/activeqt/dotnet/walkthrough/Form1.cs" identifier="0"/>
                                <para>In general we can implement a default event handler by double clicking on the widget in the form, but the default events for our widgets are right now not defined.</para>
                                <para>We will also implement an event handler for the <teletype type="highlighted">clicked</teletype> signal emitted by <link raw="QPushButton" href="qpushbutton.html" type="class">QPushButton</link>. Add the event handler <teletype type="highlighted">resetLineWidth</teletype> to the <teletype type="highlighted">clicked</teletype> event, and implement the generated function:</para>
                                <snippet location="activeqt/dotnet/walkthrough/Form1.cs" path="C:/Qt/5.11.1/Src/qtactiveqt/examples/activeqt/dotnet/walkthrough/Form1.cs" identifier="1"/>
                                <para>We reset the property to 1, and also call the <teletype type="highlighted">setFocus()</teletype> slot to simulate the user style on Windows, where a button grabs focus when you click it (so that you can click it again with the spacebar).</para>
                                <para>If we now compile and run the project we can click on the circle widget to increase its line width, and press the reset button to set the line width back to 1.</para>
                            </section>
                            <section id="summary">
                                <heading level="1">Summary</heading>
                                <para>Using <link raw="ActiveQt" href="activeqt-index.html" type="page" page="Active Qt">ActiveQt</link> as a universal interoperability bridge between the .NET world and the native world of Qt is very easy, and makes it often unnecessary to implement a lot of handwritten wrapper classes. Instead, the <link raw="QAxFactory" href="qaxfactory.html" type="class">QAxFactory</link> implementation in the otherwise completely cross-platform Qt project provides the glue that .NET needs to to generate the RCW.</para>
                                <para>If this is not sufficient we can implement our own wrapper classes thanks to the C++ extensions provided by Microsoft.</para>
                            </section>
                            <section id="limitations">
                                <heading level="2">Limitations</heading>
                                <para>All the limitations when using <link raw="ActiveQt" href="activeqt-index.html" type="page" page="Active Qt">ActiveQt</link> are implied when using this technique to interoperate with .NET, e.g. the datatypes we can use in the APIs can only be those supported by <link raw="ActiveQt" href="activeqt-index.html" type="page" page="Active Qt">ActiveQt</link> and COM. However, since this includes subclasses of <link raw="QObject" href="qobject.html" type="class">QObject</link> and <link raw="QWidget" href="qwidget.html" type="class">QWidget</link> we can wrap any of our datatypes into a <link raw="QObject" href="qobject.html" type="class">QObject</link> subclass to make its API available to .NET. This has the positive side effect that the same API is automatically available when using <link raw="Qt Script" href="qtscript-index.html" type="page" page="Qt Script">Qt Script</link> to automate Qt applications and to COM clients in general.</para>
                                <para>When using the &quot;IJW&quot; method, in principle the only limitation is the time required to write the wrapper classes and data type conversion functions.</para>
                            </section>
                            <section id="performance-considerations">
                                <heading level="2">Performance Considerations</heading>
                                <para>Every call from CLR bytecode to native code implies a small performance hit, and necessary type conversions introduce an additional delay with every layer that exists between the two frameworks. Consequently every approach to mix .NET and native code should try to minimize the communication necessary between the different worlds.</para>
                                <para>As <link raw="ActiveQt" href="activeqt-index.html" type="page" page="Active Qt">ActiveQt</link> introduces three layers at once - the RCW, COM and finally <link raw="ActiveQt" href="activeqt-index.html" type="page" page="Active Qt">ActiveQt</link> itself - the performance penalty when using the generic Qt/<link raw="ActiveQt" href="activeqt-index.html" type="page" page="Active Qt">ActiveQt</link>/COM/RCW/.NET bridge is larger than when using a hand-crafted IJW-wrapper class. The execution speed however is still sufficient for connecting to and modifying interactive elements in a user interface, and as soon as the benefit of using Qt and C++ to implement and compile performance critical algorithms into native code kicks in, <link raw="ActiveQt" href="activeqt-index.html" type="page" page="Active Qt">ActiveQt</link> becomes a valid choice for making even non-visual parts of your application accessible to .NET.</para>
                            </section>
                        </section>
                    </section>
                </section>
            </description>
        </page>
    </document>
</WebXML>
