<?xml version="1.0" encoding="UTF-8"?>
<db:article xmlns:db="http://docbook.org/ns/docbook"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            xmlns:tc="http://dourouc05.github.io">
   <db:info>
      <db:title>QObject</db:title>
      <db:abstract>
         <db:para>The base class of all Qt objects</db:para>
      </db:abstract>
   </db:info>
   <db:classsynopsis>
      <db:ooclass>
         <db:classname>QObject</db:classname>
      </db:ooclass>
      <db:classsynopsisinfo role="threadsafety">reentrant</db:classsynopsisinfo>
      <db:classsynopsisinfo role="module">QtCore</db:classsynopsisinfo>
      <db:namespacesynopsisinfo role="headers">#include &lt;qobject.h&gt;</db:namespacesynopsisinfo>
      <db:classsynopsisinfo role="group">objectmodel</db:classsynopsisinfo>
   </db:classsynopsis>
   <db:section xml:id="details">
      <db:title>Detailed Description</db:title>
      <db:para>The <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> class is the base class of all Qt objects.</db:para>
      <db:para>
         <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> is the heart of the Qt <db:link xlink:href="object.html" xrefstyle="page" annotations="Object Model">Object Model</db:link>. The central feature in this model is a very powerful mechanism for seamless object communication called <db:link xlink:href="signalsandslots.html" xrefstyle="page" annotations="signals and slots">signals and slots</db:link>. You can connect a signal to a slot with <db:code><db:link xlink:href="qobject.html#connect" xrefstyle="function" annotations="connect()">connect()</db:link></db:code> and destroy the connection with <db:code><db:link xlink:href="qobject.html#disconnect" xrefstyle="function" annotations="disconnect()">disconnect()</db:link></db:code>. To avoid never ending notification loops you can temporarily block signals with <db:code><db:link xlink:href="qobject.html#blockSignals" xrefstyle="function" annotations="blockSignals()">blockSignals()</db:link></db:code>. The protected functions <db:code><db:link xlink:href="qobject.html#connectNotify" xrefstyle="function" annotations="connectNotify()">connectNotify()</db:link></db:code> and <db:code><db:link xlink:href="qobject.html#disconnectNotify" xrefstyle="function" annotations="disconnectNotify()">disconnectNotify()</db:link></db:code> make it possible to track connections.</db:para>
      <db:para>QObjects organize themselves in <db:link xlink:href="objecttrees.html" xrefstyle="page" annotations="Object Trees &amp; Ownership">object trees</db:link>. When you create a <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> with another object as parent, the object will automatically add itself to the parent's <db:code><db:link xlink:href="qobject.html#children" xrefstyle="function" annotations="children()">children()</db:link></db:code> list. The parent takes ownership of the object; i.e., it will automatically delete its children in its destructor. You can look for an object by name and optionally type using <db:code><db:link xlink:href="qobject.html#findChild" xrefstyle="function" annotations="findChild()">findChild()</db:link></db:code> or <db:code><db:link xlink:href="qobject.html#findChildren" xrefstyle="function" annotations="findChildren()">findChildren()</db:link></db:code>.</db:para>
      <db:para>Every object has an <db:code><db:link xlink:href="qobject.html#objectName-prop" xrefstyle="function" annotations="objectName()">objectName()</db:link></db:code> and its class name can be found via the corresponding <db:code><db:link xlink:href="qobject.html#metaObject" xrefstyle="function" annotations="metaObject()">metaObject()</db:link></db:code> (see <db:code><db:link xlink:href="qmetaobject.html#className" xrefstyle="function" annotations="QMetaObject::className()">QMetaObject::className()</db:link></db:code>). You can determine whether the object's class inherits another class in the <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> inheritance hierarchy by using the <db:code><db:link xlink:href="qobject.html#inherits" xrefstyle="function" annotations="inherits()">inherits()</db:link></db:code> function.</db:para>
      <db:para>When an object is deleted, it emits a <db:code><db:link xlink:href="qobject.html#destroyed" xrefstyle="function" annotations="destroyed()">destroyed()</db:link></db:code> signal. You can catch this signal to avoid dangling references to QObjects.</db:para>
      <db:para>QObjects can receive events through <db:code><db:link xlink:href="qobject.html#event" xrefstyle="function" annotations="event()">event()</db:link></db:code> and filter the events of other objects. See <db:code><db:link xlink:href="qobject.html#installEventFilter" xrefstyle="function" annotations="installEventFilter()">installEventFilter()</db:link></db:code> and <db:code><db:link xlink:href="qobject.html#eventFilter" xrefstyle="function" annotations="eventFilter()">eventFilter()</db:link></db:code> for details. A convenience handler, <db:code><db:link xlink:href="qobject.html#childEvent" xrefstyle="function" annotations="childEvent()">childEvent()</db:link></db:code>, can be reimplemented to catch child events.</db:para>
      <db:para>Last but not least, <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> provides the basic timer support in Qt; see <db:code><db:link xlink:href="qtimer.html" xrefstyle="class" annotations="QTimer">QTimer</db:link></db:code> for high-level support for timers.</db:para>
      <db:para>Notice that the <db:code><db:link xlink:href="qobject.html#Q_OBJECT" xrefstyle="function" annotations="Q_OBJECT">Q_OBJECT</db:link></db:code> macro is mandatory for any object that implements signals, slots or properties. You also need to run the <db:link xlink:href="moc.html" xrefstyle="page" annotations="moc">Meta Object Compiler</db:link> on the source file. We strongly recommend the use of this macro in all subclasses of <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> regardless of whether or not they actually use signals, slots and properties, since failure to do so may lead certain functions to exhibit strange behavior.</db:para>
      <db:para>All Qt widgets inherit <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code>. The convenience function <db:code><db:link xlink:href="qobject.html#isWidgetType" xrefstyle="function" annotations="isWidgetType()">isWidgetType()</db:link></db:code> returns whether an object is actually a widget. It is much faster than qobject_cast&lt;<db:code><db:link xlink:href="qwidget.html" xrefstyle="class" annotations="QWidget">QWidget</db:link></db:code> *&gt;(<db:emphasis>obj</db:emphasis>) or <db:emphasis>obj</db:emphasis>-&gt;<db:code><db:link xlink:href="qobject.html#inherits" xrefstyle="function" annotations="inherits()">inherits</db:link></db:code>("<db:code><db:link xlink:href="qwidget.html" xrefstyle="class" annotations="QWidget">QWidget</db:link></db:code>").</db:para>
      <db:para>Some <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> functions, e.g. <db:code><db:link xlink:href="qobject.html#children" xrefstyle="function" annotations="children()">children()</db:link></db:code>, return a <db:link xlink:href="qobject.html#QObjectList-typedef" xrefstyle="typedef" annotations="QObjectList">QObjectList</db:link>. <db:link xlink:href="qobject.html#QObjectList-typedef" xrefstyle="typedef" annotations="QObjectList">QObjectList</db:link> is a typedef for <db:code><db:link xlink:href="qlist.html" xrefstyle="class" annotations="QList">QList</db:link></db:code>&lt;<db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> *&gt;.</db:para>
      <db:section xml:id="thread-affinity">
         <db:title>Thread Affinity</db:title>
         <db:para>A <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> instance is said to have a <db:emphasis>thread affinity</db:emphasis>, or that it <db:emphasis>lives</db:emphasis> in a certain thread. When a <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> receives a <db:code><db:link xlink:href="qt.html#ConnectionType-enum" xrefstyle="enum" annotations="Qt::QueuedConnection">queued signal</db:link></db:code> or a <db:link xlink:href="eventsandfilters.html#sending-events" xrefstyle="page" annotations="The Event System#Sending Events">posted event</db:link>, the slot or event handler will run in the thread that the object lives in.</db:para>
         <db:note>
            <db:para> If a <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> has no thread affinity (that is, if <db:code><db:link xlink:href="qobject.html#thread" xrefstyle="function" annotations="thread()">thread()</db:link></db:code> returns zero), or if it lives in a thread that has no running event loop, then it cannot receive queued signals or posted events.</db:para>
         </db:note>
         <db:para>By default, a <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> lives in the thread in which it is created. An object's thread affinity can be queried using <db:code><db:link xlink:href="qobject.html#thread" xrefstyle="function" annotations="thread()">thread()</db:link></db:code> and changed using <db:code><db:link xlink:href="qobject.html#moveToThread" xrefstyle="function" annotations="moveToThread()">moveToThread()</db:link></db:code>.</db:para>
         <db:para>All QObjects must live in the same thread as their parent. Consequently:</db:para>
         <db:itemizedlist>
            <db:listitem>
               <db:para>
                  <db:code><db:link xlink:href="qobject.html#setParent" xrefstyle="function" annotations="setParent()">setParent()</db:link></db:code> will fail if the two QObjects involved live in different threads.</db:para>
            </db:listitem>
            <db:listitem>
               <db:para>When a <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> is moved to another thread, all its children will be automatically moved too.</db:para>
            </db:listitem>
            <db:listitem>
               <db:para>
                  <db:code><db:link xlink:href="qobject.html#moveToThread" xrefstyle="function" annotations="moveToThread()">moveToThread()</db:link></db:code> will fail if the <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> has a parent.</db:para>
            </db:listitem>
            <db:listitem>
               <db:para>If QObjects are created within <db:code><db:link xlink:href="qthread.html#run" xrefstyle="function" annotations="QThread::run()">QThread::run()</db:link></db:code>, they cannot become children of the <db:code><db:link xlink:href="qthread.html" xrefstyle="class" annotations="QThread">QThread</db:link></db:code> object because the <db:code><db:link xlink:href="qthread.html" xrefstyle="class" annotations="QThread">QThread</db:link></db:code> does not live in the thread that calls <db:code><db:link xlink:href="qthread.html#run" xrefstyle="function" annotations="QThread::run()">QThread::run()</db:link></db:code>.</db:para>
            </db:listitem>
         </db:itemizedlist>
         <db:note>
            <db:para> A <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code>'s member variables <db:emphasis>do not</db:emphasis> automatically become its children. The parent-child relationship must be set by either passing a pointer to the child's <db:code><db:link xlink:href="qobject.html#QObject" xrefstyle="function" annotations="QObject()">constructor</db:link></db:code>, or by calling <db:code><db:link xlink:href="qobject.html#setParent" xrefstyle="function" annotations="setParent()">setParent()</db:link></db:code>. Without this step, the object's member variables will remain in the old thread when <db:code><db:link xlink:href="qobject.html#moveToThread" xrefstyle="function" annotations="moveToThread()">moveToThread()</db:link></db:code> is called.</db:para>
         </db:note>
      </db:section>
      <db:section xml:id="no-copy-constructor-or-assignment-operator">
         <db:title>No Copy Constructor or Assignment Operator</db:title>
         <db:para>
            <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> has neither a copy constructor nor an assignment operator. This is by design. Actually, they are declared, but in a <db:code>private</db:code> section with the macro <db:code><db:link xlink:href="qobject.html#Q_DISABLE_COPY" xrefstyle="function" annotations="Q_DISABLE_COPY()">Q_DISABLE_COPY()</db:link></db:code>. In fact, all Qt classes derived from <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> (direct or indirect) use this macro to declare their copy constructor and assignment operator to be private. The reasoning is found in the discussion on <db:link xlink:href="object.html#identity-vs-value" xrefstyle="page" annotations="Identity vs Value">Identity vs Value</db:link> on the Qt <db:link xlink:href="object.html" xrefstyle="page" annotations="Object Model">Object Model</db:link> page.</db:para>
         <db:para>The main consequence is that you should use pointers to <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> (or to your <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> subclass) where you might otherwise be tempted to use your <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> subclass as a value. For example, without a copy constructor, you can't use a subclass of <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> as the value to be stored in one of the container classes. You must store pointers.</db:para>
      </db:section>
      <db:section xml:id="auto-connection">
         <db:title>Auto-Connection</db:title>
         <db:para>Qt's meta-object system provides a mechanism to automatically connect signals and slots between <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> subclasses and their children. As long as objects are defined with suitable object names, and slots follow a simple naming convention, this connection can be performed at run-time by the <db:code><db:link xlink:href="qmetaobject.html#connectSlotsByName" xrefstyle="function" annotations="QMetaObject::connectSlotsByName()">QMetaObject::connectSlotsByName()</db:link></db:code> function.</db:para>
         <db:para>
            <db:link xlink:href="uic.html" xrefstyle="page" annotations="uic">uic</db:link> generates code that invokes this function to enable auto-connection to be performed between widgets on forms created with <db:emphasis>Qt Designer</db:emphasis>. More information about using auto-connection with <db:emphasis>Qt Designer</db:emphasis> is given in the <db:link xlink:href="designer-using-a-ui-file.html" xrefstyle="page" annotations="Using a Designer UI File in Your Application">Using a Designer UI File in Your Application</db:link> section of the <db:emphasis>Qt Designer</db:emphasis> manual.</db:para>
      </db:section>
      <db:section xml:id="dynamic-properties">
         <db:title>Dynamic Properties</db:title>
         <db:para>From Qt 4.2, dynamic properties can be added to and removed from <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> instances at run-time. Dynamic properties do not need to be declared at compile-time, yet they provide the same advantages as static properties and are manipulated using the same API - using <db:code><db:link xlink:href="qobject.html#property" xrefstyle="function" annotations="property()">property()</db:link></db:code> to read them and <db:code><db:link xlink:href="qobject.html#setProperty" xrefstyle="function" annotations="setProperty()">setProperty()</db:link></db:code> to write them.</db:para>
         <db:para>From Qt 4.3, dynamic properties are supported by <db:link xlink:href="designer-widget-mode.html#the-property-editor" xrefstyle="page" annotations="Qt Designer's Widget Editing Mode#The Property Editor">Qt Designer</db:link>, and both standard Qt widgets and user-created forms can be given dynamic properties.</db:para>
      </db:section>
      <db:section xml:id="internationalization-i18n">
         <db:title>Internationalization (I18n)</db:title>
         <db:para>All <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> subclasses support Qt's translation features, making it possible to translate an application's user interface into different languages.</db:para>
         <db:para>To make user-visible text translatable, it must be wrapped in calls to the <db:code><db:link xlink:href="qobject.html#tr" xrefstyle="function" annotations="tr()">tr()</db:link></db:code> function. This is explained in detail in the <db:link xlink:href="i18n-source-translation.html" xrefstyle="page" annotations="Writing Source Code for Translation">Writing Source Code for Translation</db:link> document.</db:para>
      </db:section>
      <db:para>
         <db:emphasis role="bold">See Also:</db:emphasis>
         <db:simplelist type="vert">
            <db:member>
               <db:code><db:link xlink:href="qmetaobject.html" xrefstyle="class" annotations="QMetaObject">QMetaObject</db:link></db:code>
            </db:member>
            <db:member>
               <db:code><db:link xlink:href="qpointer.html" xrefstyle="class" annotations="QPointer">QPointer</db:link></db:code>
            </db:member>
            <db:member>
               <db:code><db:link xlink:href="qobjectcleanuphandler.html" xrefstyle="class" annotations="QObjectCleanupHandler">QObjectCleanupHandler</db:link></db:code>
            </db:member>
            <db:member>
               <db:code><db:link xlink:href="qobject.html#Q_DISABLE_COPY" xrefstyle="function" annotations="Q_DISABLE_COPY()">Q_DISABLE_COPY()</db:link></db:code>
            </db:member>
            <db:member>
               <db:link xlink:href="objecttrees.html" xrefstyle="page" annotations="Object Trees &amp; Ownership">Object Trees &amp; Ownership</db:link>
            </db:member>
         </db:simplelist>
      </db:para>
   </db:section>
   <db:section>
      <db:title>Type Documentation</db:title>
   </db:section>
   <db:section>
      <db:title>Properties</db:title>
      <db:section>
         <db:title>objectName : QString</db:title>
         <db:fieldsynopsis>
            <db:modifier>(Qt property)</db:modifier>
            <db:type>QString</db:type>
            <db:varname>objectName</db:varname>
         </db:fieldsynopsis>
         <db:methodsynopsis>
            <db:type>QString</db:type>
            <db:methodname>objectName</db:methodname>
            <db:void/>
            <db:modifier>const</db:modifier>
         </db:methodsynopsis>
         <db:methodsynopsis>
            <db:void/>
            <db:methodname>setObjectName</db:methodname>
            <db:methodparam>
               <db:type>QString</db:type>
               <db:parameter>objectName</db:parameter>
            </db:methodparam>
         </db:methodsynopsis>
         <db:para>This property holds the name of this object.</db:para>
         <db:para>You can find an object by name (and type) using <db:code><db:link xlink:href="qobject.html#findChild" xrefstyle="function" annotations="findChild()">findChild()</db:link></db:code>. You can find a set of objects with <db:code><db:link xlink:href="qobject.html#findChildren" xrefstyle="function" annotations="findChildren()">findChildren()</db:link></db:code>.</db:para>
         <db:programlisting>
qDebug("MyClass::setPrecision(): (%s) invalid precision %f",
       qPrintable(objectName()), newPrecision);
</db:programlisting>
         <db:para>By default, this property contains an empty string.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#metaObject" xrefstyle="function" annotations="metaObject()">metaObject()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qmetaobject.html#className" xrefstyle="function" annotations="QMetaObject::className()">QMetaObject::className()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>
            <db:emphasis role="bold">Access Functions:</db:emphasis>
            <db:informaltable>
               <db:tbody>
                  <db:tr>
                     <db:td>QString</db:td>
                     <db:td>objectName() const
                  </db:td>
                  </db:tr>
                  <db:tr>
                     <db:td>
                    void
                  </db:td>
                     <db:td>setObjectName(QStringobjectName)
                  </db:td>
                  </db:tr>
               </db:tbody>
            </db:informaltable>
         </db:para>
      </db:section>
   </db:section>
   <db:section>
      <db:title>Member Variable Documentation</db:title>
   </db:section>
   <db:section>
      <db:title>Member Function Documentation</db:title>
      <db:section>
         <db:title> QObject::QObject(QObject *parent)</db:title>
         <db:constructorsynopsis>
            <db:methodname>QObject</db:methodname>
            <db:methodparam>
               <db:type>QObject *</db:type>
               <db:parameter>parent</db:parameter>
               <db:initializer>nullptr</db:initializer>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:constructorsynopsis>
         <db:para>Constructs an object with parent object <db:code role="argument">parent</db:code>.</db:para>
         <db:para>The parent of an object may be viewed as the object's owner. For instance, a <db:code><db:link xlink:href="qdialog.html" xrefstyle="class" annotations="QDialog">dialog box</db:link></db:code> is the parent of the OK and Cancel buttons it contains.</db:para>
         <db:para>The destructor of a parent object destroys all child objects.</db:para>
         <db:para>Setting <db:code role="argument">parent</db:code> to 0 constructs an object with no parent. If the object is a widget, it will become a top-level window.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#parent" xrefstyle="function" annotations="parent()">parent()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#findChild" xrefstyle="function" annotations="findChild()">findChild()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#findChildren" xrefstyle="function" annotations="findChildren()">findChildren()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title> QObject::~QObject()</db:title>
         <db:destructorsynopsis>
            <db:methodname>~QObject</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:destructorsynopsis>
         <db:para>Destroys the object, deleting all its child objects.</db:para>
         <db:para>All signals to and from the object are automatically disconnected, and any pending posted events for the object are removed from the event queue. However, it is often safer to use <db:code><db:link xlink:href="qobject.html#deleteLater" xrefstyle="function" annotations="deleteLater()">deleteLater()</db:link></db:code> rather than deleting a <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> subclass directly.</db:para>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> All child objects are deleted. If any of these objects are on the stack or global, sooner or later your program will crash. We do not recommend holding pointers to child objects from outside the parent. If you still do, the <db:code><db:link xlink:href="qobject.html#destroyed" xrefstyle="function" annotations="destroyed()">destroyed()</db:link></db:code> signal gives you an opportunity to detect when an object is destroyed.</db:para>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> Deleting a <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> while pending events are waiting to be delivered can cause a crash. You must not delete the <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> directly if it exists in a different thread than the one currently executing. Use <db:code><db:link xlink:href="qobject.html#deleteLater" xrefstyle="function" annotations="deleteLater()">deleteLater()</db:link></db:code> instead, which will cause the event loop to delete the object after all pending events have been delivered to it.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#deleteLater" xrefstyle="function" annotations="deleteLater()">deleteLater()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>QList&lt;QByteArray&gt; QObject::dynamicPropertyNames() const</db:title>
         <db:methodsynopsis>
            <db:type>QList&lt;QByteArray&gt;</db:type>
            <db:methodname>dynamicPropertyNames</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Returns the names of all properties that were dynamically added to the object using <db:code><db:link xlink:href="qobject.html#setProperty" xrefstyle="function" annotations="setProperty()">setProperty()</db:link></db:code>.</db:para>
         <db:para>This property was introduced in Qt 4.2.</db:para>
      </db:section>
      <db:section>
         <db:title>QMetaObject::Connection QObject::connect(const QObject *sender, const QMetaMethod &amp;signal, const QObject *receiver, const QMetaMethod &amp;method, Qt::ConnectionType type)</db:title>
         <db:methodsynopsis>
            <db:type>QMetaObject::Connection</db:type>
            <db:methodname>connect</db:methodname>
            <db:methodparam>
               <db:type>const QObject *</db:type>
               <db:parameter>sender</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QMetaMethod &amp;</db:type>
               <db:parameter>signal</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QObject *</db:type>
               <db:parameter>receiver</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QMetaMethod &amp;</db:type>
               <db:parameter>method</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>Qt::ConnectionType</db:type>
               <db:parameter>type</db:parameter>
               <db:initializer>Qt::AutoConnection</db:initializer>
            </db:methodparam>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
         </db:methodsynopsis>
         <db:para>Creates a connection of the given <db:code role="argument">type</db:code> from the <db:code role="argument">signal</db:code> in the <db:code role="argument">sender</db:code> object to the <db:code role="argument">method</db:code> in the <db:code role="argument">receiver</db:code> object. Returns a handle to the connection that can be used to disconnect it later.</db:para>
         <db:para>The Connection handle will be invalid if it cannot create the connection, for example, the parameters were invalid. You can check if the <db:code><db:link xlink:href="qmetaobject-connection.html" xrefstyle="class" annotations="QMetaObject::Connection">QMetaObject::Connection</db:link></db:code> is valid by casting it to a bool.</db:para>
         <db:para>This function works in the same way as <db:code>connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)</db:code> but it uses <db:code><db:link xlink:href="qmetamethod.html" xrefstyle="class" annotations="QMetaMethod">QMetaMethod</db:link></db:code> to specify signal and method.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#connect" xrefstyle="function" annotations="connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)">connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 4.8.</db:para>
      </db:section>
      <db:section>
         <db:title>QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)</db:title>
         <db:methodsynopsis>
            <db:type>QMetaObject::Connection</db:type>
            <db:methodname>connect</db:methodname>
            <db:methodparam>
               <db:type>const QObject *</db:type>
               <db:parameter>sender</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>signal</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QObject *</db:type>
               <db:parameter>receiver</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>method</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>Qt::ConnectionType</db:type>
               <db:parameter>type</db:parameter>
               <db:initializer>Qt::AutoConnection</db:initializer>
            </db:methodparam>
            <db:modifier>thread safe</db:modifier>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
         </db:methodsynopsis>
         <db:para>Creates a connection of the given <db:code role="argument">type</db:code> from the <db:code role="argument">signal</db:code> in the <db:code role="argument">sender</db:code> object to the <db:code role="argument">method</db:code> in the <db:code role="argument">receiver</db:code> object. Returns a handle to the connection that can be used to disconnect it later.</db:para>
         <db:para>You must use the <db:code>SIGNAL()</db:code> and <db:code>SLOT()</db:code> macros when specifying the <db:code role="argument">signal</db:code> and the <db:code role="argument">method</db:code>, for example:</db:para>
         <db:programlisting>
QLabel *label = new QLabel;
QScrollBar *scrollBar = new QScrollBar;
QObject::connect(scrollBar, SIGNAL(valueChanged(int)),
                 label,  SLOT(setNum(int)));
</db:programlisting>
         <db:para>This example ensures that the label always displays the current scroll bar value. Note that the signal and slots parameters must not contain any variable names, only the type. E.g. the following would not work and return false:</db:para>
         <db:programlisting>
// WRONG
QObject::connect(scrollBar, SIGNAL(valueChanged(int value)),
                 label, SLOT(setNum(int value)));
</db:programlisting>
         <db:para>A signal can also be connected to another signal:</db:para>
         <db:programlisting>
class MyWidget : public QWidget
{
    Q_OBJECT

public:
    MyWidget();

signals:
    void buttonClicked();

private:
    QPushButton *myButton;
};

MyWidget::MyWidget()
{
    myButton = new QPushButton(this);
    connect(myButton, SIGNAL(clicked()),
            this, SIGNAL(buttonClicked()));
}
</db:programlisting>
         <db:para>In this example, the <db:code>MyWidget</db:code> constructor relays a signal from a private member variable, and makes it available under a name that relates to <db:code>MyWidget</db:code>.</db:para>
         <db:para>A signal can be connected to many slots and signals. Many signals can be connected to one slot.</db:para>
         <db:para>If a signal is connected to several slots, the slots are activated in the same order in which the connections were made, when the signal is emitted.</db:para>
         <db:para>The function returns a <db:code><db:link xlink:href="qmetaobject-connection.html" xrefstyle="class" annotations="QMetaObject::Connection">QMetaObject::Connection</db:link></db:code> that represents a handle to a connection if it successfully connects the signal to the slot. The connection handle will be invalid if it cannot create the connection, for example, if <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> is unable to verify the existence of either <db:code role="argument">signal</db:code> or <db:code role="argument">method</db:code>, or if their signatures aren't compatible. You can check if the handle is valid by casting it to a bool.</db:para>
         <db:para>By default, a signal is emitted for every connection you make; two signals are emitted for duplicate connections. You can break all of these connections with a single <db:code><db:link xlink:href="qobject.html#disconnect" xrefstyle="function" annotations="disconnect()">disconnect()</db:link></db:code> call. If you pass the <db:code><db:link xlink:href="qt.html#ConnectionType-enum" xrefstyle="enum" annotations="Qt::UniqueConnection">Qt::UniqueConnection</db:link></db:code>
            <db:code role="argument">type</db:code>, the connection will only be made if it is not a duplicate. If there is already a duplicate (exact same signal to the exact same slot on the same objects), the connection will fail and connect will return an invalid <db:code><db:link xlink:href="qmetaobject-connection.html" xrefstyle="class" annotations="QMetaObject::Connection">QMetaObject::Connection</db:link></db:code>.</db:para>
         <db:note>
            <db:para> Qt::UniqueConnections do not work for lambdas, non-member functions and functors; they only apply to connecting to member functions.</db:para>
         </db:note>
         <db:para>The optional <db:code role="argument">type</db:code> parameter describes the type of connection to establish. In particular, it determines whether a particular signal is delivered to a slot immediately or queued for delivery at a later time. If the signal is queued, the parameters must be of types that are known to Qt's meta-object system, because Qt needs to copy the arguments to store them in an event behind the scenes. If you try to use a queued connection and get the error message</db:para>
         <db:programlisting>
QObject::connect: Cannot queue arguments of type 'MyType'
(Make sure 'MyType' is registered using qRegisterMetaType().)
</db:programlisting>
         <db:para>call <db:code><db:link xlink:href="qmetatype.html#qRegisterMetaType-1" xrefstyle="function" annotations="qRegisterMetaType()">qRegisterMetaType()</db:link></db:code> to register the data type before you establish the connection.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#disconnect" xrefstyle="function" annotations="disconnect()">disconnect()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#sender" xrefstyle="function" annotations="sender()">sender()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qmetatype.html#qRegisterMetaType-1" xrefstyle="function" annotations="qRegisterMetaType()">qRegisterMetaType()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qmetatype.html#Q_DECLARE_METATYPE" xrefstyle="function" annotations="Q_DECLARE_METATYPE()">Q_DECLARE_METATYPE()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:link xlink:href="signalsandslots-syntaxes.html" xrefstyle="page" annotations="Differences between String-Based and Functor-Based Connections">Differences between String-Based and Functor-Based Connections</db:link>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>QObject * QObject::sender() const</db:title>
         <db:methodsynopsis>
            <db:type>QObject *</db:type>
            <db:methodname>sender</db:methodname>
            <db:void/>
            <db:modifier>protected</db:modifier>
         </db:methodsynopsis>
         <db:para>Returns a pointer to the object that sent the signal, if called in a slot activated by a signal; otherwise it returns 0. The pointer is valid only during the execution of the slot that calls this function from this object's thread context.</db:para>
         <db:para>The pointer returned by this function becomes invalid if the sender is destroyed, or if the slot is disconnected from the sender's signal.</db:para>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> This function violates the object-oriented principle of modularity. However, getting access to the sender might be useful when many signals are connected to a single slot.</db:para>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> As mentioned above, the return value of this function is not valid when the slot is called via a <db:code><db:link xlink:href="qt.html#ConnectionType-enum" xrefstyle="enum" annotations="Qt::DirectConnection">Qt::DirectConnection</db:link></db:code> from a thread different from this object's thread. Do not use this function in this type of scenario.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#senderSignalIndex" xrefstyle="function" annotations="senderSignalIndex()">senderSignalIndex()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>QThread * QObject::thread() const</db:title>
         <db:methodsynopsis>
            <db:type>QThread *</db:type>
            <db:methodname>thread</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Returns the thread in which the object lives.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#moveToThread" xrefstyle="function" annotations="moveToThread()">moveToThread()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>QVariant QObject::property(const char *name) const</db:title>
         <db:methodsynopsis>
            <db:type>QVariant</db:type>
            <db:methodname>property</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>name</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Returns the value of the object's <db:code role="argument">name</db:code> property.</db:para>
         <db:para>If no such property exists, the returned variant is invalid.</db:para>
         <db:para>Information about all available properties is provided through the <db:code><db:link xlink:href="qobject.html#metaObject" xrefstyle="function" annotations="metaObject()">metaObject()</db:link></db:code> and <db:code><db:link xlink:href="qobject.html#dynamicPropertyNames" xrefstyle="function" annotations="dynamicPropertyNames()">dynamicPropertyNames()</db:link></db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#setProperty" xrefstyle="function" annotations="setProperty()">setProperty()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qvariant.html#isValid" xrefstyle="function" annotations="QVariant::isValid()">QVariant::isValid()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#metaObject" xrefstyle="function" annotations="metaObject()">metaObject()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#dynamicPropertyNames" xrefstyle="function" annotations="dynamicPropertyNames()">dynamicPropertyNames()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>bool QObject::blockSignals(bool block)</db:title>
         <db:methodsynopsis>
            <db:type>bool</db:type>
            <db:methodname>blockSignals</db:methodname>
            <db:methodparam>
               <db:type>bool</db:type>
               <db:parameter>block</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>If <db:code role="argument">block</db:code> is true, signals emitted by this object are blocked (i.e., emitting a signal will not invoke anything connected to it). If <db:code role="argument">block</db:code> is false, no such blocking will occur.</db:para>
         <db:para>The return value is the previous value of <db:code><db:link xlink:href="qobject.html#signalsBlocked" xrefstyle="function" annotations="signalsBlocked()">signalsBlocked()</db:link></db:code>.</db:para>
         <db:para>Note that the <db:code><db:link xlink:href="qobject.html#destroyed" xrefstyle="function" annotations="destroyed()">destroyed()</db:link></db:code> signal will be emitted even if the signals for this object have been blocked.</db:para>
         <db:para>Signals emitted while being blocked are not buffered.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#signalsBlocked" xrefstyle="function" annotations="signalsBlocked()">signalsBlocked()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qsignalblocker.html" xrefstyle="class" annotations="QSignalBlocker">QSignalBlocker</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>bool QObject::disconnect(const QMetaObject::Connection &amp;connection)</db:title>
         <db:methodsynopsis>
            <db:type>bool</db:type>
            <db:methodname>disconnect</db:methodname>
            <db:methodparam>
               <db:type>const QMetaObject::Connection &amp;</db:type>
               <db:parameter>connection</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
         </db:methodsynopsis>
         <db:para>Disconnect a connection.</db:para>
         <db:para>If the <db:code role="argument">connection</db:code> is invalid or has already been disconnected, do nothing and return false.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#connect" xrefstyle="function" annotations="connect()">connect()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>bool QObject::disconnect(const QObject *sender, const QMetaMethod &amp;signal, const QObject *receiver, const QMetaMethod &amp;method)</db:title>
         <db:methodsynopsis>
            <db:type>bool</db:type>
            <db:methodname>disconnect</db:methodname>
            <db:methodparam>
               <db:type>const QObject *</db:type>
               <db:parameter>sender</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QMetaMethod &amp;</db:type>
               <db:parameter>signal</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QObject *</db:type>
               <db:parameter>receiver</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QMetaMethod &amp;</db:type>
               <db:parameter>method</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
         </db:methodsynopsis>
         <db:para>Disconnects <db:code role="argument">signal</db:code> in object <db:code role="argument">sender</db:code> from <db:code role="argument">method</db:code> in object <db:code role="argument">receiver</db:code>. Returns <db:code>true</db:code> if the connection is successfully broken; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>This function provides the same possibilities like <db:code>disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)</db:code> but uses <db:code><db:link xlink:href="qmetamethod.html" xrefstyle="class" annotations="QMetaMethod">QMetaMethod</db:link></db:code> to represent the signal and the method to be disconnected.</db:para>
         <db:para>Additionally this function returnsfalse and no signals and slots disconnected if:</db:para>
         <db:orderedlist>
            <db:listitem>
               <db:para>
                  <db:code role="argument">signal</db:code> is not a member of sender class or one of its parent classes.</db:para>
            </db:listitem>
            <db:listitem>
               <db:para>
                  <db:code role="argument">method</db:code> is not a member of receiver class or one of its parent classes.</db:para>
            </db:listitem>
            <db:listitem>
               <db:para>
                  <db:code role="argument">signal</db:code> instance represents not a signal.</db:para>
            </db:listitem>
         </db:orderedlist>
         <db:para>QMetaMethod() may be used as wildcard in the meaning "any signal" or "any slot in receiving object". In the same way 0 can be used for <db:code role="argument">receiver</db:code> in the meaning "any receiving object". In this case method should also be QMetaMethod(). <db:code role="argument">sender</db:code> parameter should be never 0.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#disconnect" xrefstyle="function" annotations="disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)">disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 4.8.</db:para>
      </db:section>
      <db:section>
         <db:title>bool QObject::disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)</db:title>
         <db:methodsynopsis>
            <db:type>bool</db:type>
            <db:methodname>disconnect</db:methodname>
            <db:methodparam>
               <db:type>const QObject *</db:type>
               <db:parameter>sender</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>signal</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QObject *</db:type>
               <db:parameter>receiver</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>method</db:parameter>
            </db:methodparam>
            <db:modifier>thread safe</db:modifier>
            <db:modifier>public</db:modifier>
            <db:modifier>static</db:modifier>
         </db:methodsynopsis>
         <db:para>Disconnects <db:code role="argument">signal</db:code> in object <db:code role="argument">sender</db:code> from <db:code role="argument">method</db:code> in object <db:code role="argument">receiver</db:code>. Returns <db:code>true</db:code> if the connection is successfully broken; otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>A signal-slot connection is removed when either of the objects involved are destroyed.</db:para>
         <db:para> is typically used in three ways, as the following examples demonstrate.</db:para>
         <db:orderedlist>
            <db:listitem>
               <db:para>Disconnect everything connected to an object's signals:</db:para>
               <db:programlisting>
disconnect(myObject, 0, 0, 0);
</db:programlisting>
               <db:para>equivalent to the non-static overloaded function</db:para>
               <db:programlisting>
myObject-&gt;disconnect();
</db:programlisting>
            </db:listitem>
            <db:listitem>
               <db:para>Disconnect everything connected to a specific signal:</db:para>
               <db:programlisting>
disconnect(myObject, SIGNAL(mySignal()), 0, 0);
</db:programlisting>
               <db:para>equivalent to the non-static overloaded function</db:para>
               <db:programlisting>
myObject-&gt;disconnect(SIGNAL(mySignal()));
</db:programlisting>
            </db:listitem>
            <db:listitem>
               <db:para>Disconnect a specific receiver:</db:para>
               <db:programlisting>
disconnect(myObject, 0, myReceiver, 0);
</db:programlisting>
               <db:para>equivalent to the non-static overloaded function</db:para>
               <db:programlisting>
myObject-&gt;disconnect(myReceiver);
</db:programlisting>
            </db:listitem>
         </db:orderedlist>
         <db:para>0 may be used as a wildcard, meaning "any signal", "any receiving object", or "any slot in the receiving object", respectively.</db:para>
         <db:para>The <db:code role="argument">sender</db:code> may never be 0. (You cannot disconnect signals from more than one object in a single call.)</db:para>
         <db:para>If <db:code role="argument">signal</db:code> is 0, it disconnects <db:code role="argument">receiver</db:code> and <db:code role="argument">method</db:code> from any signal. If not, only the specified signal is disconnected.</db:para>
         <db:para>If <db:code role="argument">receiver</db:code> is 0, it disconnects anything connected to <db:code role="argument">signal</db:code>. If not, slots in objects other than <db:code role="argument">receiver</db:code> are not disconnected.</db:para>
         <db:para>If <db:code role="argument">method</db:code> is 0, it disconnects anything that is connected to <db:code role="argument">receiver</db:code>. If not, only slots named <db:code role="argument">method</db:code> will be disconnected, and all other slots are left alone. The <db:code role="argument">method</db:code> must be 0 if <db:code role="argument">receiver</db:code> is left out, so you cannot disconnect a specifically-named slot on all objects.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#connect" xrefstyle="function" annotations="connect()">connect()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>bool QObject::event(QEvent *e)</db:title>
         <db:methodsynopsis>
            <db:type>bool</db:type>
            <db:methodname>event</db:methodname>
            <db:methodparam>
               <db:type>QEvent *</db:type>
               <db:parameter>e</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>This virtual function receives events to an object and should return true if the event <db:code role="argument">e</db:code> was recognized and processed.</db:para>
         <db:para>The  function can be reimplemented to customize the behavior of an object.</db:para>
         <db:para>Make sure you call the parent event class implementation for all the events you did not handle.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>
class MyClass : public QWidget
{
    Q_OBJECT

public:
    MyClass(QWidget *parent = 0);
    ~MyClass();

    bool event(QEvent* ev)
    {
        if (ev-&gt;type() == QEvent::PolishRequest) {
            // overwrite handling of PolishRequest if any
            doThings();
            return true;
        } else  if (ev-&gt;type() == QEvent::Show) {
            // complement handling of Show if any
            doThings2();
            QWidget::event(ev);
            return true;
        }
        // Make sure the rest of events are handled
        return QWidget::event(ev);
    }
};
</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#installEventFilter" xrefstyle="function" annotations="installEventFilter()">installEventFilter()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#timerEvent" xrefstyle="function" annotations="timerEvent()">timerEvent()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qcoreapplication.html#sendEvent" xrefstyle="function" annotations="QCoreApplication::sendEvent()">QCoreApplication::sendEvent()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qcoreapplication.html#postEvent" xrefstyle="function" annotations="QCoreApplication::postEvent()">QCoreApplication::postEvent()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>bool QObject::eventFilter(QObject *watched, QEvent *event)</db:title>
         <db:methodsynopsis>
            <db:type>bool</db:type>
            <db:methodname>eventFilter</db:methodname>
            <db:methodparam>
               <db:type>QObject *</db:type>
               <db:parameter>watched</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>QEvent *</db:type>
               <db:parameter>event</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Filters events if this object has been installed as an event filter for the <db:code role="argument">watched</db:code> object.</db:para>
         <db:para>In your reimplementation of this function, if you want to filter the <db:code role="argument">event</db:code> out, i.e. stop it being handled further, return true; otherwise return false.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>
class MainWindow : public QMainWindow
{
public:
    MainWindow();

protected:
    bool eventFilter(QObject *obj, QEvent *ev);

private:
    QTextEdit *textEdit;
};

MainWindow::MainWindow()
{
    textEdit = new QTextEdit;
    setCentralWidget(textEdit);

    textEdit-&gt;installEventFilter(this);
}

bool MainWindow::eventFilter(QObject *obj, QEvent *event)
{
    if (obj == textEdit) {
        if (event-&gt;type() == QEvent::KeyPress) {
            QKeyEvent *keyEvent = static_cast&lt;QKeyEvent*&gt;(event);
            qDebug() &lt;&lt; "Ate key press" &lt;&lt; keyEvent-&gt;key();
            return true;
        } else {
            return false;
        }
    } else {
        // pass the event on to the parent class
        return QMainWindow::eventFilter(obj, event);
    }
}
</db:programlisting>
         <db:para>Notice in the example above that unhandled events are passed to the base class's  function, since the base class might have reimplemented  for its own internal purposes.</db:para>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> If you delete the receiver object in this function, be sure to return true. Otherwise, Qt will forward the event to the deleted object and the program might crash.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#installEventFilter" xrefstyle="function" annotations="installEventFilter()">installEventFilter()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>bool QObject::isSignalConnected(const QMetaMethod &amp;signal) const</db:title>
         <db:methodsynopsis>
            <db:type>bool</db:type>
            <db:methodname>isSignalConnected</db:methodname>
            <db:methodparam>
               <db:type>const QMetaMethod &amp;</db:type>
               <db:parameter>signal</db:parameter>
            </db:methodparam>
            <db:modifier>protected</db:modifier>
         </db:methodsynopsis>
         <db:para>Returns <db:code>true</db:code> if the <db:code role="argument">signal</db:code> is connected to at least one receiver, otherwise returns <db:code>false</db:code>.</db:para>
         <db:para>
            <db:code role="argument">signal</db:code> must be a signal member of this object, otherwise the behaviour is undefined.</db:para>
         <db:programlisting>
static const QMetaMethod valueChangedSignal = QMetaMethod::fromSignal(&amp;MyObject::valueChanged);
if (isSignalConnected(valueChangedSignal)) {
    QByteArray data;
    data = get_the_value();       // expensive operation
    emit valueChanged(data);
}
</db:programlisting>
         <db:para>As the code snippet above illustrates, you can use this function to avoid emitting a signal that nobody listens to.</db:para>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> This function violates the object-oriented principle of modularity. However, it might be useful when you need to perform expensive initialization only if something is connected to a signal.</db:para>
         <db:para>This property was introduced in Qt 5.0.</db:para>
      </db:section>
      <db:section>
         <db:title>bool QObject::setProperty(const char *name, const QVariant &amp;value)</db:title>
         <db:methodsynopsis>
            <db:type>bool</db:type>
            <db:methodname>setProperty</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>name</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>const QVariant &amp;</db:type>
               <db:parameter>value</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Sets the value of the object's <db:code role="argument">name</db:code> property to <db:code role="argument">value</db:code>.</db:para>
         <db:para>If the property is defined in the class using <db:code><db:link xlink:href="qobject.html#Q_PROPERTY" xrefstyle="function" annotations="Q_PROPERTY">Q_PROPERTY</db:link></db:code> then true is returned on success and false otherwise. If the property is not defined using <db:code><db:link xlink:href="qobject.html#Q_PROPERTY" xrefstyle="function" annotations="Q_PROPERTY">Q_PROPERTY</db:link></db:code>, and therefore not listed in the meta-object, it is added as a dynamic property and false is returned.</db:para>
         <db:para>Information about all available properties is provided through the <db:code><db:link xlink:href="qobject.html#metaObject" xrefstyle="function" annotations="metaObject()">metaObject()</db:link></db:code> and <db:code><db:link xlink:href="qobject.html#dynamicPropertyNames" xrefstyle="function" annotations="dynamicPropertyNames()">dynamicPropertyNames()</db:link></db:code>.</db:para>
         <db:para>Dynamic properties can be queried again using <db:code><db:link xlink:href="qobject.html#property" xrefstyle="function" annotations="property()">property()</db:link></db:code> and can be removed by setting the property value to an invalid <db:code><db:link xlink:href="qvariant.html" xrefstyle="class" annotations="QVariant">QVariant</db:link></db:code>. Changing the value of a dynamic property causes a <db:code><db:link xlink:href="qdynamicpropertychangeevent.html" xrefstyle="class" annotations="QDynamicPropertyChangeEvent">QDynamicPropertyChangeEvent</db:link></db:code> to be sent to the object.</db:para>
         <db:note>
            <db:para> Dynamic properties starting with "_q_" are reserved for internal purposes.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#property" xrefstyle="function" annotations="property()">property()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#metaObject" xrefstyle="function" annotations="metaObject()">metaObject()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#dynamicPropertyNames" xrefstyle="function" annotations="dynamicPropertyNames()">dynamicPropertyNames()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qmetaproperty.html#write" xrefstyle="function" annotations="QMetaProperty::write()">QMetaProperty::write()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>int QObject::receivers(const char *signal) const</db:title>
         <db:methodsynopsis>
            <db:type>int</db:type>
            <db:methodname>receivers</db:methodname>
            <db:methodparam>
               <db:type>const char *</db:type>
               <db:parameter>signal</db:parameter>
            </db:methodparam>
            <db:modifier>protected</db:modifier>
         </db:methodsynopsis>
         <db:para>Returns the number of receivers connected to the <db:code role="argument">signal</db:code>.</db:para>
         <db:para>Since both slots and signals can be used as receivers for signals, and the same connections can be made many times, the number of receivers is the same as the number of connections made from this signal.</db:para>
         <db:para>When calling this function, you can use the <db:code>SIGNAL()</db:code> macro to pass a specific signal:</db:para>
         <db:programlisting>
if (receivers(SIGNAL(valueChanged(QByteArray))) &gt; 0) {
    QByteArray data;
    get_the_value(&amp;data);       // expensive operation
    emit valueChanged(data);
}
</db:programlisting>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> This function violates the object-oriented principle of modularity. However, it might be useful when you need to perform expensive initialization only if something is connected to a signal.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#isSignalConnected" xrefstyle="function" annotations="isSignalConnected()">isSignalConnected()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>int QObject::senderSignalIndex() const</db:title>
         <db:methodsynopsis>
            <db:type>int</db:type>
            <db:methodname>senderSignalIndex</db:methodname>
            <db:void/>
            <db:modifier>protected</db:modifier>
         </db:methodsynopsis>
         <db:para>Returns the meta-method index of the signal that called the currently executing slot, which is a member of the class returned by <db:code><db:link xlink:href="qobject.html#sender" xrefstyle="function" annotations="sender()">sender()</db:link></db:code>. If called outside of a slot activated by a signal, -1 is returned.</db:para>
         <db:para>For signals with default parameters, this function will always return the index with all parameters, regardless of which was used with <db:code><db:link xlink:href="qobject.html#connect" xrefstyle="function" annotations="connect()">connect()</db:link></db:code>. For example, the signal <db:code>destroyed(QObject *obj = 0)</db:code> will have two different indexes (with and without the parameter), but this function will always return the index with a parameter. This does not apply when overloading signals with different parameters.</db:para>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> This function violates the object-oriented principle of modularity. However, getting access to the signal index might be useful when many signals are connected to a single slot.</db:para>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> The return value of this function is not valid when the slot is called via a <db:code><db:link xlink:href="qt.html#ConnectionType-enum" xrefstyle="enum" annotations="Qt::DirectConnection">Qt::DirectConnection</db:link></db:code> from a thread different from this object's thread. Do not use this function in this type of scenario.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#sender" xrefstyle="function" annotations="sender()">sender()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qmetaobject.html#indexOfSignal" xrefstyle="function" annotations="QMetaObject::indexOfSignal()">QMetaObject::indexOfSignal()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qmetaobject.html#method" xrefstyle="function" annotations="QMetaObject::method()">QMetaObject::method()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 4.8.</db:para>
      </db:section>
      <db:section>
         <db:title>int QObject::startTimer(int interval, Qt::TimerType timerType)</db:title>
         <db:methodsynopsis>
            <db:type>int</db:type>
            <db:methodname>startTimer</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>interval</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type>Qt::TimerType</db:type>
               <db:parameter>timerType</db:parameter>
               <db:initializer>Qt::CoarseTimer</db:initializer>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Starts a timer and returns a timer identifier, or returns zero if it could not start a timer.</db:para>
         <db:para>A timer event will occur every <db:code role="argument">interval</db:code> milliseconds until <db:code><db:link xlink:href="qobject.html#killTimer" xrefstyle="function" annotations="killTimer()">killTimer()</db:link></db:code> is called. If <db:code role="argument">interval</db:code> is 0, then the timer event occurs once every time there are no more window system events to process.</db:para>
         <db:para>The virtual <db:code><db:link xlink:href="qobject.html#timerEvent" xrefstyle="function" annotations="timerEvent()">timerEvent()</db:link></db:code> function is called with the <db:code><db:link xlink:href="qtimerevent.html" xrefstyle="class" annotations="QTimerEvent">QTimerEvent</db:link></db:code> event parameter class when a timer event occurs. Reimplement this function to get timer events.</db:para>
         <db:para>If multiple timers are running, the <db:code><db:link xlink:href="qtimerevent.html#timerId" xrefstyle="function" annotations="QTimerEvent::timerId()">QTimerEvent::timerId()</db:link></db:code> can be used to find out which timer was activated.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>
class MyObject : public QObject
{
    Q_OBJECT

public:
    MyObject(QObject *parent = 0);

protected:
    void timerEvent(QTimerEvent *event);
};

MyObject::MyObject(QObject *parent)
    : QObject(parent)
{
    startTimer(50);     // 50-millisecond timer
    startTimer(1000);   // 1-second timer
    startTimer(60000);  // 1-minute timer

    using namespace std::chrono;
    startTimer(milliseconds(50));
    startTimer(seconds(1));
    startTimer(minutes(1));

    // since C++14 we can use std::chrono::duration literals, e.g.:
    startTimer(100ms);
    startTimer(5s);
    startTimer(2min);
    startTimer(1h);
}

void MyObject::timerEvent(QTimerEvent *event)
{
    qDebug() &lt;&lt; "Timer ID:" &lt;&lt; event-&gt;timerId();
}
</db:programlisting>
         <db:para>Note that <db:code><db:link xlink:href="qtimer.html" xrefstyle="class" annotations="QTimer">QTimer</db:link></db:code>'s accuracy depends on the underlying operating system and hardware. The <db:code role="argument">timerType</db:code> argument allows you to customize the accuracy of the timer. See <db:code><db:link xlink:href="qt.html#TimerType-enum" xrefstyle="enum" annotations="Qt::TimerType">Qt::TimerType</db:link></db:code> for information on the different timer types. Most platforms support an accuracy of 20 milliseconds; some provide more. If Qt is unable to deliver the requested number of timer events, it will silently discard some.</db:para>
         <db:para>The <db:code><db:link xlink:href="qtimer.html" xrefstyle="class" annotations="QTimer">QTimer</db:link></db:code> class provides a high-level programming interface with single-shot timers and timer signals instead of events. There is also a <db:code><db:link xlink:href="qbasictimer.html" xrefstyle="class" annotations="QBasicTimer">QBasicTimer</db:link></db:code> class that is more lightweight than <db:code><db:link xlink:href="qtimer.html" xrefstyle="class" annotations="QTimer">QTimer</db:link></db:code> and less clumsy than using timer IDs directly.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#timerEvent" xrefstyle="function" annotations="timerEvent()">timerEvent()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#killTimer" xrefstyle="function" annotations="killTimer()">killTimer()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qtimer.html#singleShot" xrefstyle="function" annotations="QTimer::singleShot()">QTimer::singleShot()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>void QObject::childEvent(QChildEvent *event)</db:title>
         <db:methodsynopsis>
            <db:void/>
            <db:methodname>childEvent</db:methodname>
            <db:methodparam>
               <db:type>QChildEvent *</db:type>
               <db:parameter>event</db:parameter>
            </db:methodparam>
            <db:modifier>protected</db:modifier>
         </db:methodsynopsis>
         <db:para>This event handler can be reimplemented in a subclass to receive child events. The event is passed in the <db:code role="argument">event</db:code> parameter.</db:para>
         <db:para>
            <db:code><db:link xlink:href="qevent.html#Type-enum" xrefstyle="enum" annotations="QEvent::ChildAdded">QEvent::ChildAdded</db:link></db:code> and <db:code><db:link xlink:href="qevent.html#Type-enum" xrefstyle="enum" annotations="QEvent::ChildRemoved">QEvent::ChildRemoved</db:link></db:code> events are sent to objects when children are added or removed. In both cases you can only rely on the child being a <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code>, or if <db:code><db:link xlink:href="qobject.html#isWidgetType" xrefstyle="function" annotations="isWidgetType()">isWidgetType()</db:link></db:code> returns <db:code>true</db:code>, a <db:code><db:link xlink:href="qwidget.html" xrefstyle="class" annotations="QWidget">QWidget</db:link></db:code>. (This is because, in the <db:code><db:link xlink:href="qevent.html#Type-enum" xrefstyle="enum" annotations="QEvent::ChildAdded">ChildAdded</db:link></db:code> case, the child is not yet fully constructed, and in the <db:code><db:link xlink:href="qevent.html#Type-enum" xrefstyle="enum" annotations="QEvent::ChildRemoved">ChildRemoved</db:link></db:code> case it might have been destructed already).</db:para>
         <db:para>
            <db:code><db:link xlink:href="qevent.html#Type-enum" xrefstyle="enum" annotations="QEvent::ChildPolished">QEvent::ChildPolished</db:link></db:code> events are sent to widgets when children are polished, or when polished children are added. If you receive a child polished event, the child's construction is usually completed. However, this is not guaranteed, and multiple polish events may be delivered during the execution of a widget's constructor.</db:para>
         <db:para>For every child widget, you receive one <db:code><db:link xlink:href="qevent.html#Type-enum" xrefstyle="enum" annotations="QEvent::ChildAdded">ChildAdded</db:link></db:code> event, zero or more <db:code><db:link xlink:href="qevent.html#Type-enum" xrefstyle="enum" annotations="QEvent::ChildPolished">ChildPolished</db:link></db:code> events, and one <db:code><db:link xlink:href="qevent.html#Type-enum" xrefstyle="enum" annotations="QEvent::ChildRemoved">ChildRemoved</db:link></db:code> event.</db:para>
         <db:para>The <db:code><db:link xlink:href="qevent.html#Type-enum" xrefstyle="enum" annotations="QEvent::ChildPolished">ChildPolished</db:link></db:code> event is omitted if a child is removed immediately after it is added. If a child is polished several times during construction and destruction, you may receive several child polished events for the same child, each time with a different virtual table.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#event" xrefstyle="function" annotations="event()">event()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>void QObject::connectNotify(const QMetaMethod &amp;signal)</db:title>
         <db:methodsynopsis>
            <db:void/>
            <db:methodname>connectNotify</db:methodname>
            <db:methodparam>
               <db:type>const QMetaMethod &amp;</db:type>
               <db:parameter>signal</db:parameter>
            </db:methodparam>
            <db:modifier>protected</db:modifier>
         </db:methodsynopsis>
         <db:para>This virtual function is called when something has been connected to <db:code role="argument">signal</db:code> in this object.</db:para>
         <db:para>If you want to compare <db:code role="argument">signal</db:code> with a specific signal, you can use <db:code><db:link xlink:href="qmetamethod.html#fromSignal" xrefstyle="function" annotations="QMetaMethod::fromSignal()">QMetaMethod::fromSignal()</db:link></db:code> as follows:</db:para>
         <db:programlisting>
if (signal == QMetaMethod::fromSignal(&amp;MyObject::valueChanged)) {
    // signal is valueChanged
}
</db:programlisting>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> This function violates the object-oriented principle of modularity. However, it might be useful when you need to perform expensive initialization only if something is connected to a signal.</db:para>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> This function is called from the thread which performs the connection, which may be a different thread from the thread in which this object lives.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#connect" xrefstyle="function" annotations="connect()">connect()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#disconnectNotify" xrefstyle="function" annotations="disconnectNotify()">disconnectNotify()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.0.</db:para>
      </db:section>
      <db:section>
         <db:title>void QObject::customEvent(QEvent *event)</db:title>
         <db:methodsynopsis>
            <db:void/>
            <db:methodname>customEvent</db:methodname>
            <db:methodparam>
               <db:type>QEvent *</db:type>
               <db:parameter>event</db:parameter>
            </db:methodparam>
            <db:modifier>protected</db:modifier>
         </db:methodsynopsis>
         <db:para>This event handler can be reimplemented in a subclass to receive custom events. Custom events are user-defined events with a type value at least as large as the <db:code><db:link xlink:href="qevent.html#Type-enum" xrefstyle="enum" annotations="QEvent::User">QEvent::User</db:link></db:code> item of the <db:code><db:link xlink:href="qevent.html#Type-enum" xrefstyle="enum" annotations="QEvent::Type">QEvent::Type</db:link></db:code> enum, and is typically a <db:code><db:link xlink:href="qevent.html" xrefstyle="class" annotations="QEvent">QEvent</db:link></db:code> subclass. The event is passed in the <db:code role="argument">event</db:code> parameter.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#event" xrefstyle="function" annotations="event()">event()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qevent.html" xrefstyle="class" annotations="QEvent">QEvent</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>void QObject::deleteLater()</db:title>
         <db:methodsynopsis>
            <db:modifier>slot</db:modifier>
            <db:void/>
            <db:methodname>deleteLater</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Schedules this object for deletion.</db:para>
         <db:para>The object will be deleted when control returns to the event loop. If the event loop is not running when this function is called (e.g.  is called on an object before <db:code><db:link xlink:href="qcoreapplication.html#exec" xrefstyle="function" annotations="QCoreApplication::exec()">QCoreApplication::exec()</db:link></db:code>), the object will be deleted once the event loop is started. If  is called after the main event loop has stopped, the object will not be deleted. Since Qt 4.8, if  is called on an object that lives in a thread with no running event loop, the object will be destroyed when the thread finishes.</db:para>
         <db:para>Note that entering and leaving a new event loop (e.g., by opening a modal dialog) will <db:emphasis>not</db:emphasis> perform the deferred deletion; for the object to be deleted, the control must return to the event loop from which  was called.</db:para>
         <db:note>
            <db:para> It is safe to call this function more than once; when the first deferred deletion event is delivered, any pending events for the object are removed from the event queue.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#destroyed" xrefstyle="function" annotations="destroyed()">destroyed()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qpointer.html" xrefstyle="class" annotations="QPointer">QPointer</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>void QObject::disconnectNotify(const QMetaMethod &amp;signal)</db:title>
         <db:methodsynopsis>
            <db:void/>
            <db:methodname>disconnectNotify</db:methodname>
            <db:methodparam>
               <db:type>const QMetaMethod &amp;</db:type>
               <db:parameter>signal</db:parameter>
            </db:methodparam>
            <db:modifier>protected</db:modifier>
         </db:methodsynopsis>
         <db:para>This virtual function is called when something has been disconnected from <db:code role="argument">signal</db:code> in this object.</db:para>
         <db:para>See <db:code><db:link xlink:href="qobject.html#connectNotify" xrefstyle="function" annotations="connectNotify()">connectNotify()</db:link></db:code> for an example of how to compare <db:code role="argument">signal</db:code> with a specific signal.</db:para>
         <db:para>If all signals were disconnected from this object (e.g., the signal argument to <db:code><db:link xlink:href="qobject.html#disconnect" xrefstyle="function" annotations="disconnect()">disconnect()</db:link></db:code> was 0),  is only called once, and the <db:code role="argument">signal</db:code> will be an invalid <db:code><db:link xlink:href="qmetamethod.html" xrefstyle="class" annotations="QMetaMethod">QMetaMethod</db:link></db:code> (<db:code><db:link xlink:href="qmetamethod.html#isValid" xrefstyle="function" annotations="QMetaMethod::isValid()">QMetaMethod::isValid()</db:link></db:code> returns <db:code>false</db:code>).</db:para>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> This function violates the object-oriented principle of modularity. However, it might be useful for optimizing access to expensive resources.</db:para>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> This function is called from the thread which performs the disconnection, which may be a different thread from the thread in which this object lives. This function may also be called with a <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> internal mutex locked. It is therefore not allowed to re-enter any of any <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> functions from your reimplementation and if you lock a mutex in your reimplementation, make sure that you don't call <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> functions with that mutex held in other places or it will result in a deadlock.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#disconnect" xrefstyle="function" annotations="disconnect()">disconnect()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#connectNotify" xrefstyle="function" annotations="connectNotify()">connectNotify()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.0.</db:para>
      </db:section>
      <db:section>
         <db:title>void QObject::dumpObjectInfo() const</db:title>
         <db:methodsynopsis>
            <db:void/>
            <db:methodname>dumpObjectInfo</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Dumps information about signal connections, etc. for this object to the debug output.</db:para>
         <db:note>
            <db:para> before Qt 5.9, this function was not const.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#dumpObjectTree" xrefstyle="function" annotations="dumpObjectTree()">dumpObjectTree()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>void QObject::dumpObjectTree() const</db:title>
         <db:methodsynopsis>
            <db:void/>
            <db:methodname>dumpObjectTree</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Dumps a tree of children to the debug output.</db:para>
         <db:note>
            <db:para> before Qt 5.9, this function was not const.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#dumpObjectInfo" xrefstyle="function" annotations="dumpObjectInfo()">dumpObjectInfo()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>void QObject::killTimer(int id)</db:title>
         <db:methodsynopsis>
            <db:void/>
            <db:methodname>killTimer</db:methodname>
            <db:methodparam>
               <db:type>int</db:type>
               <db:parameter>id</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Kills the timer with timer identifier, <db:code role="argument">id</db:code>.</db:para>
         <db:para>The timer identifier is returned by <db:code><db:link xlink:href="qobject.html#startTimer" xrefstyle="function" annotations="startTimer()">startTimer()</db:link></db:code> when a timer event is started.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#timerEvent" xrefstyle="function" annotations="timerEvent()">timerEvent()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#startTimer" xrefstyle="function" annotations="startTimer()">startTimer()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>void QObject::moveToThread(QThread *targetThread)</db:title>
         <db:methodsynopsis>
            <db:void/>
            <db:methodname>moveToThread</db:methodname>
            <db:methodparam>
               <db:type>QThread *</db:type>
               <db:parameter>targetThread</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Changes the thread affinity for this object and its children. The object cannot be moved if it has a parent. Event processing will continue in the <db:code role="argument">targetThread</db:code>.</db:para>
         <db:para>To move an object to the main thread, use <db:code><db:link xlink:href="qcoreapplication.html#instance" xrefstyle="function" annotations="QApplication::instance()">QApplication::instance()</db:link></db:code> to retrieve a pointer to the current application, and then use <db:code><db:link xlink:href="qobject.html#thread" xrefstyle="function" annotations="QApplication::thread()">QApplication::thread()</db:link></db:code> to retrieve the thread in which the application lives. For example:</db:para>
         <db:programlisting>
myObject-&gt;moveToThread(QApplication::instance()-&gt;thread());
</db:programlisting>
         <db:para>If <db:code role="argument">targetThread</db:code> is zero, all event processing for this object and its children stops.</db:para>
         <db:para>Note that all active timers for the object will be reset. The timers are first stopped in the current thread and restarted (with the same interval) in the <db:code role="argument">targetThread</db:code>. As a result, constantly moving an object between threads can postpone timer events indefinitely.</db:para>
         <db:para>A <db:code><db:link xlink:href="qevent.html#Type-enum" xrefstyle="enum" annotations="QEvent::ThreadChange">QEvent::ThreadChange</db:link></db:code> event is sent to this object just before the thread affinity is changed. You can handle this event to perform any special processing. Note that any new events that are posted to this object will be handled in the <db:code role="argument">targetThread</db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">Warning:</db:emphasis> This function is <db:emphasis>not</db:emphasis> thread-safe; the current thread must be same as the current thread affinity. In other words, this function can only "push" an object from the current thread to another thread, it cannot "pull" an object from any arbitrary thread to the current thread.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#thread" xrefstyle="function" annotations="thread()">thread()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>void QObject::removeEventFilter(QObject *obj)</db:title>
         <db:methodsynopsis>
            <db:void/>
            <db:methodname>removeEventFilter</db:methodname>
            <db:methodparam>
               <db:type>QObject *</db:type>
               <db:parameter>obj</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Removes an event filter object <db:code role="argument">obj</db:code> from this object. The request is ignored if such an event filter has not been installed.</db:para>
         <db:para>All event filters for this object are automatically removed when this object is destroyed.</db:para>
         <db:para>It is always safe to remove an event filter, even during event filter activation (i.e. from the <db:code><db:link xlink:href="qobject.html#eventFilter" xrefstyle="function" annotations="eventFilter()">eventFilter()</db:link></db:code> function).</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#installEventFilter" xrefstyle="function" annotations="installEventFilter()">installEventFilter()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#eventFilter" xrefstyle="function" annotations="eventFilter()">eventFilter()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#event" xrefstyle="function" annotations="event()">event()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>void QObject::setParent(QObject *parent)</db:title>
         <db:methodsynopsis>
            <db:void/>
            <db:methodname>setParent</db:methodname>
            <db:methodparam>
               <db:type>QObject *</db:type>
               <db:parameter>parent</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Makes the object a child of <db:code role="argument">parent</db:code>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#parent" xrefstyle="function" annotations="parent()">parent()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#children" xrefstyle="function" annotations="children()">children()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
   </db:section>
   <db:section>
      <db:title>Related Non-Members</db:title>
   </db:section>
   <db:section>
      <db:title>Macro Documentation</db:title>
      <db:section>
         <db:title>QT_NO_NARROWING_CONVERSIONS_IN_CONNECT</db:title>
         <db:methodsynopsis>
            <db:methodname>QT_NO_NARROWING_CONVERSIONS_IN_CONNECT</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Defining this macro will disable narrowing and floating-point-to-integral conversions between the arguments carried by a signal and the arguments accepted by a slot, when the signal and the slot are connected using the PMF-based syntax.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#connect" xrefstyle="function" annotations="QObject::connect">QObject::connect</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.8.</db:para>
      </db:section>
      <db:section>
         <db:title>Q_CLASSINFO( Name,  Value)</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_CLASSINFO</db:methodname>
            <db:methodparam>
               <db:type/>
               <db:parameter>Name</db:parameter>
            </db:methodparam>
            <db:methodparam>
               <db:type/>
               <db:parameter>Value</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>This macro associates extra information to the class, which is available using <db:code><db:link xlink:href="qobject.html#metaObject" xrefstyle="function" annotations="QObject::metaObject()">QObject::metaObject()</db:link></db:code>. Qt makes only limited use of this feature, in the <db:link xlink:href="activeqt-index.html" xrefstyle="page" annotations="Active Qt">Active Qt</db:link>, <db:link xlink:href="qtdbus-index.html" xrefstyle="page" annotations="Qt D-Bus">Qt D-Bus</db:link> and <db:link xlink:href="whatsnew59.html#qt-qml-module" xrefstyle="page" annotations="Qt QML module">Qt QML</db:link>.</db:para>
         <db:para>The extra information takes the form of a <db:code role="argument">Name</db:code> string and a <db:code role="argument">Value</db:code> literal string.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>
class MyClass : public QObject
{
    Q_OBJECT
    Q_CLASSINFO("Author", "Pierre Gendron")
    Q_CLASSINFO("URL", "http://www.my-organization.qc.ca")

public:
    ...
};
</db:programlisting>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qmetaobject.html#classInfo" xrefstyle="function" annotations="QMetaObject::classInfo()">QMetaObject::classInfo()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qaxfactory.html" xrefstyle="class" annotations="QAxFactory">QAxFactory</db:link></db:code>
               </db:member>
               <db:member>
                  <db:link xlink:href="usingadaptors.html" xrefstyle="page" annotations="Using Qt D-Bus Adaptors">Using Qt D-Bus Adaptors</db:link>
               </db:member>
               <db:member>
                  <db:link xlink:href="qtquick-codesamples.html#extending-qml" xrefstyle="page" annotations="Extending QML">Extending QML</db:link>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>Q_DISABLE_COPY( Class)</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_DISABLE_COPY</db:methodname>
            <db:methodparam>
               <db:type/>
               <db:parameter>Class</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Disables the use of copy constructors and assignment operators for the given <db:code role="argument">Class</db:code>.</db:para>
         <db:para>Instances of subclasses of <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> should not be thought of as values that can be copied or assigned, but as unique identities. This means that when you create your own subclass of <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> (director or indirect), you should <db:emphasis>not</db:emphasis> give it a copy constructor or an assignment operator. However, it may not enough to simply omit them from your class, because, if you mistakenly write some code that requires a copy constructor or an assignment operator (it's easy to do), your compiler will thoughtfully create it for you. You must do more.</db:para>
         <db:para>The curious user will have seen that the Qt classes derived from <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> typically include this macro in a private section:</db:para>
         <db:programlisting>
class MyClass : public QObject
{

  private:
    Q_DISABLE_COPY(MyClass)
};

</db:programlisting>
         <db:para>It declares a copy constructor and an assignment operator in the private section, so that if you use them by mistake, the compiler will report an error.</db:para>
         <db:programlisting>
class MyClass : public QObject
{

  private:
     MyClass(const MyClass &amp;);
     MyClass &amp;operator=(const MyClass &amp;);
};
</db:programlisting>
         <db:para>But even this might not catch absolutely every case. You might be tempted to do something like this:</db:para>
         <db:programlisting>
  QWidget w = QWidget();
</db:programlisting>
         <db:para>First of all, don't do that. Most compilers will generate code that uses the copy constructor, so the privacy violation error will be reported, but your C++ compiler is not required to generate code for this statement in a specific way. It could generate code using <db:emphasis>neither</db:emphasis> the copy constructor <db:emphasis>nor</db:emphasis> the assignment operator we made private. In that case, no error would be reported, but your application would probably crash when you called a member function of <db:code>w</db:code>.</db:para>
      </db:section>
      <db:section>
         <db:title>Q_EMIT</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_EMIT</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Use this macro to replace the <db:code>emit</db:code> keyword for emitting signals, when you want to use Qt Signals and Slots with a <db:link xlink:href="signalsandslots.html#3rd-party-signals-and-slots" xrefstyle="page" annotations="3rd Party Signals and Slots">3rd party signal/slot mechanism</db:link>.</db:para>
         <db:para>The macro is normally used when <db:code>no_keywords</db:code> is specified with the <db:code>CONFIG</db:code> variable in the <db:code>.pro</db:code> file, but it can be used even when <db:code>no_keywords</db:code> is <db:emphasis>not</db:emphasis> specified.</db:para>
      </db:section>
      <db:section>
         <db:title>Q_ENUM( ... )</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_ENUM</db:methodname>
            <db:methodparam>
               <db:type> ...</db:type>
               <db:parameter/>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>This macro registers an enum type with the meta-object system. It must be placed after the enum declaration in a class that has the <db:code><db:link xlink:href="qobject.html#Q_OBJECT" xrefstyle="function" annotations="Q_OBJECT">Q_OBJECT</db:link></db:code> or the <db:code><db:link xlink:href="qobject.html#Q_GADGET" xrefstyle="function" annotations="Q_GADGET">Q_GADGET</db:link></db:code> macro. For namespaces use <db:code><db:link xlink:href="qobject.html#Q_ENUM_NS" xrefstyle="function" annotations="Q_ENUM_NS()">Q_ENUM_NS()</db:link></db:code> instead.</db:para>
         <db:para>For example:</db:para>
         <db:programlisting>
class MyClass : public QObject
{
    Q_OBJECT

public:
    MyClass(QObject *parent = 0);
    ~MyClass();

    enum Priority { High, Low, VeryHigh, VeryLow };
    Q_ENUM(Priority)
    void setPriority(Priority priority);
    Priority priority() const;
};
</db:programlisting>
         <db:para>Enumerations that are declared with  have their <db:code><db:link xlink:href="qmetaenum.html" xrefstyle="class" annotations="QMetaEnum">QMetaEnum</db:link></db:code> registered in the enclosing <db:code><db:link xlink:href="qmetaobject.html" xrefstyle="class" annotations="QMetaObject">QMetaObject</db:link></db:code>. You can also use <db:code><db:link xlink:href="qmetaenum.html#fromType" xrefstyle="function" annotations="QMetaEnum::fromType()">QMetaEnum::fromType()</db:link></db:code> to get the <db:code><db:link xlink:href="qmetaenum.html" xrefstyle="class" annotations="QMetaEnum">QMetaEnum</db:link></db:code>.</db:para>
         <db:para>Registered enumerations are automatically registered also to the Qt meta type system, making them known to <db:code><db:link xlink:href="qmetatype.html" xrefstyle="class" annotations="QMetaType">QMetaType</db:link></db:code> without the need to use <db:code><db:link xlink:href="qmetatype.html#Q_DECLARE_METATYPE" xrefstyle="function" annotations="Q_DECLARE_METATYPE()">Q_DECLARE_METATYPE()</db:link></db:code>. This will enable useful features; for example, if used in a <db:code><db:link xlink:href="qvariant.html" xrefstyle="class" annotations="QVariant">QVariant</db:link></db:code>, you can convert them to strings. Likewise, passing them to <db:code><db:link xlink:href="qdebug.html" xrefstyle="class" annotations="QDebug">QDebug</db:link></db:code> will print out their names.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:link xlink:href="properties.html" xrefstyle="page" annotations="Qt's Property System">Qt's Property System</db:link>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.5.</db:para>
      </db:section>
      <db:section>
         <db:title>Q_ENUM_NS( ... )</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_ENUM_NS</db:methodname>
            <db:methodparam>
               <db:type> ...</db:type>
               <db:parameter/>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>This macro registers an enum type with the meta-object system. It must be placed after the enum declaration in a namespace that has the <db:code><db:link xlink:href="qobject.html#Q_NAMESPACE" xrefstyle="function" annotations="Q_NAMESPACE">Q_NAMESPACE</db:link></db:code> macro. It is the same as <db:code><db:link xlink:href="qobject.html#Q_ENUM" xrefstyle="function" annotations="Q_ENUM">Q_ENUM</db:link></db:code> but in a namespace.</db:para>
         <db:para>Enumerations that are declared with  have their <db:code><db:link xlink:href="qmetaenum.html" xrefstyle="class" annotations="QMetaEnum">QMetaEnum</db:link></db:code> registered in the enclosing <db:code><db:link xlink:href="qmetaobject.html" xrefstyle="class" annotations="QMetaObject">QMetaObject</db:link></db:code>. You can also use <db:code><db:link xlink:href="qmetaenum.html#fromType" xrefstyle="function" annotations="QMetaEnum::fromType()">QMetaEnum::fromType()</db:link></db:code> to get the <db:code><db:link xlink:href="qmetaenum.html" xrefstyle="class" annotations="QMetaEnum">QMetaEnum</db:link></db:code>.</db:para>
         <db:para>Registered enumerations are automatically registered also to the Qt meta type system, making them known to <db:code><db:link xlink:href="qmetatype.html" xrefstyle="class" annotations="QMetaType">QMetaType</db:link></db:code> without the need to use <db:code><db:link xlink:href="qmetatype.html#Q_DECLARE_METATYPE" xrefstyle="function" annotations="Q_DECLARE_METATYPE()">Q_DECLARE_METATYPE()</db:link></db:code>. This will enable useful features; for example, if used in a <db:code><db:link xlink:href="qvariant.html" xrefstyle="class" annotations="QVariant">QVariant</db:link></db:code>, you can convert them to strings. Likewise, passing them to <db:code><db:link xlink:href="qdebug.html" xrefstyle="class" annotations="QDebug">QDebug</db:link></db:code> will print out their names.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:link xlink:href="properties.html" xrefstyle="page" annotations="Qt's Property System">Qt's Property System</db:link>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.8.</db:para>
      </db:section>
      <db:section>
         <db:title>Q_FLAG( ... )</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_FLAG</db:methodname>
            <db:methodparam>
               <db:type> ...</db:type>
               <db:parameter/>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>This macro registers a single <db:code><db:link xlink:href="qflags.html" xrefstyle="class" annotations="QFlags">flags type</db:link></db:code> with the meta-object system. It is typically used in a class definition to declare that values of a given enum can be used as flags and combined using the bitwise OR operator. For namespaces use <db:code><db:link xlink:href="qobject.html#Q_FLAG_NS" xrefstyle="function" annotations="Q_FLAG_NS()">Q_FLAG_NS()</db:link></db:code> instead.</db:para>
         <db:para>The macro must be placed after the enum declaration.</db:para>
         <db:para>For example, in <db:code><db:link xlink:href="qlibrary.html" xrefstyle="class" annotations="QLibrary">QLibrary</db:link></db:code>, the <db:link xlink:href="qlibrary.html#LoadHint-enum" xrefstyle="typedef" annotations="QLibrary::LoadHints">LoadHints</db:link> flag is declared in the following way:</db:para>
         <db:programlisting>
class QLibrary : public QObject
{
    Q_OBJECT

public:
    ...

    enum LoadHint {
        ResolveAllSymbolsHint = 0x01,
        ExportExternalSymbolsHint = 0x02,
        LoadArchiveMemberHint = 0x04
    };
    Q_DECLARE_FLAGS(LoadHints, LoadHint)
    Q_FLAG(LoadHints)
    ...
}
</db:programlisting>
         <db:para>The declaration of the flags themselves is performed in the public section of the <db:code><db:link xlink:href="qlibrary.html" xrefstyle="class" annotations="QLibrary">QLibrary</db:link></db:code> class itself, using the <db:code><db:link xlink:href="qflags.html#Q_DECLARE_FLAGS" xrefstyle="function" annotations="Q_DECLARE_FLAGS()">Q_DECLARE_FLAGS()</db:link></db:code> macro.</db:para>
         <db:note>
            <db:para> The  macro takes care of registering individual flag values with the meta-object system, so it is unnecessary to use <db:code><db:link xlink:href="qobject.html#Q_ENUM" xrefstyle="function" annotations="Q_ENUM()">Q_ENUM()</db:link></db:code> in addition to this macro.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:link xlink:href="properties.html" xrefstyle="page" annotations="Qt's Property System">Qt's Property System</db:link>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.5.</db:para>
      </db:section>
      <db:section>
         <db:title>Q_FLAG_NS( ... )</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_FLAG_NS</db:methodname>
            <db:methodparam>
               <db:type> ...</db:type>
               <db:parameter/>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>This macro registers a single <db:code><db:link xlink:href="qflags.html" xrefstyle="class" annotations="QFlags">flags type</db:link></db:code> with the meta-object system. It is used in a namespace that has the <db:code><db:link xlink:href="qobject.html#Q_NAMESPACE" xrefstyle="function" annotations="Q_NAMESPACE">Q_NAMESPACE</db:link></db:code> macro, to declare that values of a given enum can be used as flags and combined using the bitwise OR operator. It is the same as <db:code><db:link xlink:href="qobject.html#Q_FLAG" xrefstyle="function" annotations="Q_FLAG">Q_FLAG</db:link></db:code> but in a namespace.</db:para>
         <db:para>The macro must be placed after the enum declaration.</db:para>
         <db:note>
            <db:para> The  macro takes care of registering individual flag values with the meta-object system, so it is unnecessary to use <db:code><db:link xlink:href="qobject.html#Q_ENUM_NS" xrefstyle="function" annotations="Q_ENUM_NS()">Q_ENUM_NS()</db:link></db:code> in addition to this macro.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:link xlink:href="properties.html" xrefstyle="page" annotations="Qt's Property System">Qt's Property System</db:link>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.8.</db:para>
      </db:section>
      <db:section>
         <db:title>Q_GADGET</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_GADGET</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>The  macro is a lighter version of the <db:code><db:link xlink:href="qobject.html#Q_OBJECT" xrefstyle="function" annotations="Q_OBJECT">Q_OBJECT</db:link></db:code> macro for classes that do not inherit from <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> but still want to use some of the reflection capabilities offered by <db:code><db:link xlink:href="qmetaobject.html" xrefstyle="class" annotations="QMetaObject">QMetaObject</db:link></db:code>. Just like the <db:code><db:link xlink:href="qobject.html#Q_OBJECT" xrefstyle="function" annotations="Q_OBJECT">Q_OBJECT</db:link></db:code> macro, it must appear in the private section of a class definition.</db:para>
         <db:para>Q_GADGETs can have <db:code><db:link xlink:href="qobject.html#Q_ENUM" xrefstyle="function" annotations="Q_ENUM">Q_ENUM</db:link></db:code>, <db:code><db:link xlink:href="qobject.html#Q_PROPERTY" xrefstyle="function" annotations="Q_PROPERTY">Q_PROPERTY</db:link></db:code> and <db:code><db:link xlink:href="qobject.html#Q_INVOKABLE" xrefstyle="function" annotations="Q_INVOKABLE">Q_INVOKABLE</db:link></db:code>, but they cannot have signals or slots</db:para>
         <db:para> makes a class member, <db:code>staticMetaObject</db:code>, available. <db:code>staticMetaObject</db:code> is of type <db:code><db:link xlink:href="qmetaobject.html" xrefstyle="class" annotations="QMetaObject">QMetaObject</db:link></db:code> and provides access to the enums declared with <db:code><db:link xlink:href="qobject-obsolete.html#Q_ENUMS" xrefstyle="function" annotations="Q_ENUMS">Q_ENUMS</db:link></db:code>.</db:para>
      </db:section>
      <db:section>
         <db:title>Q_INTERFACES( ... )</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_INTERFACES</db:methodname>
            <db:methodparam>
               <db:type> ...</db:type>
               <db:parameter/>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>This macro tells Qt which interfaces the class implements. This is used when implementing plugins.</db:para>
         <db:para>Example:</db:para>
         <db:programlisting>
class BasicToolsPlugin : public QObject,
                         public BrushInterface,
                         public ShapeInterface,
                         public FilterInterface
{
    Q_OBJECT
    Q_PLUGIN_METADATA(IID "org.qt-project.Qt.Examples.PlugAndPaint.BrushInterface" FILE "basictools.json")
    Q_INTERFACES(BrushInterface ShapeInterface FilterInterface)

public:
    
};</db:programlisting>
         <db:para>See the <db:link xlink:href="qtwidgets-tools-plugandpaint-plugins-basictools-example.html" xrefstyle="page" annotations="tools/plugandpaint/plugins/basictools">Plug &amp; Paint Basic Tools</db:link> example for details.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qtplugin.html#Q_DECLARE_INTERFACE" xrefstyle="function" annotations="Q_DECLARE_INTERFACE()">Q_DECLARE_INTERFACE()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:code><db:link xlink:href="qtplugin.html#Q_PLUGIN_METADATA" xrefstyle="function" annotations="Q_PLUGIN_METADATA()">Q_PLUGIN_METADATA()</db:link></db:code>
               </db:member>
               <db:member>
                  <db:link xlink:href="plugins-howto.html" xrefstyle="page" annotations="How to Create Qt Plugins">How to Create Qt Plugins</db:link>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>Q_INVOKABLE</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_INVOKABLE</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Apply this macro to declarations of member functions to allow them to be invoked via the meta-object system. The macro is written before the return type, as shown in the following example:</db:para>
         <db:programlisting>
class Window : public QWidget
{
    Q_OBJECT

public:
    Window();
    void normalMethod();
    Q_INVOKABLE void invokableMethod();
};
</db:programlisting>
         <db:para>The <db:code>invokableMethod()</db:code> function is marked up using , causing it to be registered with the meta-object system and enabling it to be invoked using <db:code><db:link xlink:href="qmetaobject.html#invokeMethod" xrefstyle="function" annotations="QMetaObject::invokeMethod()">QMetaObject::invokeMethod()</db:link></db:code>. Since <db:code>normalMethod()</db:code> function is not registered in this way, it cannot be invoked using <db:code><db:link xlink:href="qmetaobject.html#invokeMethod" xrefstyle="function" annotations="QMetaObject::invokeMethod()">QMetaObject::invokeMethod()</db:link></db:code>.</db:para>
      </db:section>
      <db:section>
         <db:title>Q_NAMESPACE</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_NAMESPACE</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>The  macro can be used to add <db:code><db:link xlink:href="qmetaobject.html" xrefstyle="class" annotations="QMetaObject">QMetaObject</db:link></db:code> capabilities to a namespace.</db:para>
         <db:para>Q_NAMESPACEs can have <db:code><db:link xlink:href="qobject.html#Q_CLASSINFO" xrefstyle="function" annotations="Q_CLASSINFO">Q_CLASSINFO</db:link></db:code>, <db:code><db:link xlink:href="qobject.html#Q_ENUM_NS" xrefstyle="function" annotations="Q_ENUM_NS">Q_ENUM_NS</db:link></db:code>, <db:code><db:link xlink:href="qobject.html#Q_FLAG_NS" xrefstyle="function" annotations="Q_FLAG_NS">Q_FLAG_NS</db:link></db:code>, but they cannot have <db:code><db:link xlink:href="qobject.html#Q_ENUM" xrefstyle="function" annotations="Q_ENUM">Q_ENUM</db:link></db:code>, <db:code><db:link xlink:href="qobject.html#Q_FLAG" xrefstyle="function" annotations="Q_FLAG">Q_FLAG</db:link></db:code>, <db:code><db:link xlink:href="qobject.html#Q_PROPERTY" xrefstyle="function" annotations="Q_PROPERTY">Q_PROPERTY</db:link></db:code>, <db:code><db:link xlink:href="qobject.html#Q_INVOKABLE" xrefstyle="function" annotations="Q_INVOKABLE">Q_INVOKABLE</db:link></db:code>, signals nor slots.</db:para>
         <db:para> makes an external variable, <db:code>staticMetaObject</db:code>, available. <db:code>staticMetaObject</db:code> is of type <db:code><db:link xlink:href="qmetaobject.html" xrefstyle="class" annotations="QMetaObject">QMetaObject</db:link></db:code> and provides access to the enums declared with <db:code><db:link xlink:href="qobject.html#Q_ENUM_NS" xrefstyle="function" annotations="Q_ENUM_NS">Q_ENUM_NS</db:link></db:code>/<db:code><db:link xlink:href="qobject.html#Q_FLAG_NS" xrefstyle="function" annotations="Q_FLAG_NS">Q_FLAG_NS</db:link></db:code>.</db:para>
         <db:para>This property was introduced in Qt 5.8.</db:para>
      </db:section>
      <db:section>
         <db:title>Q_OBJECT</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_OBJECT</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>The  macro must appear in the private section of a class definition that declares its own signals and slots or that uses other services provided by Qt's meta-object system.</db:para>
         <db:para>For example:</db:para>
         <db:programlisting>
#include &lt;QObject&gt;
</db:programlisting>
         <db:programlisting>
class Counter : public QObject

{
    Q_OBJECT

public:
    Counter() { m_value = 0; }

    int value() const { return m_value; }

public slots:
    void setValue(int value);

signals:
    void valueChanged(int newValue);

private:
    int m_value;
};
</db:programlisting>
         <db:note>
            <db:para> This macro requires the class to be a subclass of <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code>. Use <db:code><db:link xlink:href="qobject.html#Q_GADGET" xrefstyle="function" annotations="Q_GADGET">Q_GADGET</db:link></db:code> instead of  to enable the meta object system's support for enums in a class that is not a <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code> subclass.</db:para>
         </db:note>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:link xlink:href="metaobjects.html" xrefstyle="page" annotations="Meta-Object System">Meta-Object System</db:link>
               </db:member>
               <db:member>
                  <db:link xlink:href="signalsandslots.html" xrefstyle="page" annotations="Signals and Slots">Signals and Slots</db:link>
               </db:member>
               <db:member>
                  <db:link xlink:href="properties.html" xrefstyle="page" annotations="Qt's Property System">Qt's Property System</db:link>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>Q_PROPERTY( ... )</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_PROPERTY</db:methodname>
            <db:methodparam>
               <db:type> ...</db:type>
               <db:parameter/>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>This macro is used for declaring properties in classes that inherit <db:code><db:link xlink:href="qobject.html" xrefstyle="class" annotations="QObject">QObject</db:link></db:code>. Properties behave like class data members, but they have additional features accessible through the <db:link xlink:href="metaobjects.html" xrefstyle="page" annotations="Meta-Object System">Meta-Object System</db:link>.</db:para>
         <db:programlisting>
Q_PROPERTY(type name
           (READ getFunction [WRITE setFunction] |
            MEMBER memberName [(READ getFunction | WRITE setFunction)])
           [RESET resetFunction]
           [NOTIFY notifySignal]
           [REVISION int]
           [DESIGNABLE bool]
           [SCRIPTABLE bool]
           [STORED bool]
           [USER bool]
           [CONSTANT]
           [FINAL])
</db:programlisting>
         <db:para>The property name and type and the <db:code>READ</db:code> function are required. The type can be any type supported by <db:code><db:link xlink:href="qvariant.html" xrefstyle="class" annotations="QVariant">QVariant</db:link></db:code>, or it can be a user-defined type. The other items are optional, but a <db:code>WRITE</db:code> function is common. The attributes default to true except <db:code>USER</db:code>, which defaults to false.</db:para>
         <db:para>For example:</db:para>
         <db:programlisting>
Q_PROPERTY(QString title READ title WRITE setTitle USER true)
</db:programlisting>
         <db:para>For more details about how to use this macro, and a more detailed example of its use, see the discussion on <db:link xlink:href="properties.html" xrefstyle="page" annotations="Qt's Property System">Qt's Property System</db:link>.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:link xlink:href="properties.html" xrefstyle="page" annotations="Qt's Property System">Qt's Property System</db:link>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>Q_REVISION</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_REVISION</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Apply this macro to declarations of member functions to tag them with a revision number in the meta-object system. The macro is written before the return type, as shown in the following example:</db:para>
         <db:programlisting>
class Window : public QWidget
{
    Q_OBJECT
    Q_PROPERTY(int normalProperty READ normalProperty)
    Q_PROPERTY(int newProperty READ newProperty REVISION 1)

public:
    Window();
    int normalProperty();
    int newProperty();
public slots:
    void normalMethod();
    Q_REVISION(1) void newMethod();
};
</db:programlisting>
         <db:para>This is useful when using the meta-object system to dynamically expose objects to another API, as you can match the version expected by multiple versions of the other API. Consider the following simplified example:</db:para>
         <db:programlisting>
    Window window;
    int expectedRevision = 0;
    const QMetaObject *windowMetaObject = window.metaObject();
    for (int i=0; i &lt; windowMetaObject-&gt;methodCount(); i++)
        if (windowMetaObject-&gt;method(i).revision() &lt;= expectedRevision)
            exposeMethod(windowMetaObject-&gt;method(i));
    for (int i=0; i &lt; windowMetaObject-&gt;propertyCount(); i++)
        if (windowMetaObject-&gt;property(i).revision() &lt;= expectedRevision)
            exposeProperty(windowMetaObject-&gt;property(i));
</db:programlisting>
         <db:para>Using the same Window class as the previous example, the newProperty and newMethod would only be exposed in this code when the expected version is 1 or greater.</db:para>
         <db:para>Since all methods are considered to be in revision 0 if untagged, a tag of (0) is invalid and ignored.</db:para>
         <db:para>This tag is not used by the meta-object system itself. Currently this is only used by the <db:link xlink:href="qtqml-module.html" xrefstyle="module" annotations="QtQml">QtQml</db:link> module.</db:para>
         <db:para>For a more generic string tag, see <db:code><db:link xlink:href="qmetamethod.html#tag" xrefstyle="function" annotations="QMetaMethod::tag()">QMetaMethod::tag()</db:link></db:code>
         </db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qmetamethod.html#revision" xrefstyle="function" annotations="QMetaMethod::revision()">QMetaMethod::revision()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
      </db:section>
      <db:section>
         <db:title>Q_SET_OBJECT_NAME( Object)</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_SET_OBJECT_NAME</db:methodname>
            <db:methodparam>
               <db:type/>
               <db:parameter>Object</db:parameter>
            </db:methodparam>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>This macro assigns <db:code role="argument">Object</db:code> the objectName "Object".</db:para>
         <db:para>It doesn't matter whether <db:code role="argument">Object</db:code> is a pointer or not, the macro figures that out by itself.</db:para>
         <db:para>
            <db:emphasis role="bold">See Also:</db:emphasis>
            <db:simplelist type="vert">
               <db:member>
                  <db:code><db:link xlink:href="qobject.html#objectName-prop" xrefstyle="function" annotations="QObject::objectName()">QObject::objectName()</db:link></db:code>
               </db:member>
            </db:simplelist>
         </db:para>
         <db:para>This property was introduced in Qt 5.0.</db:para>
      </db:section>
      <db:section>
         <db:title>Q_SIGNAL</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_SIGNAL</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>This is an additional macro that allows you to mark a single function as a signal. It can be quite useful, especially when you use a 3rd-party source code parser which doesn't understand a <db:code>signals</db:code> or <db:code>Q_SIGNALS</db:code> groups.</db:para>
         <db:para>Use this macro to replace the <db:code>signals</db:code> keyword in class declarations, when you want to use Qt Signals and Slots with a <db:link xlink:href="signalsandslots.html#3rd-party-signals-and-slots" xrefstyle="page" annotations="3rd Party Signals and Slots">3rd party signal/slot mechanism</db:link>.</db:para>
         <db:para>The macro is normally used when <db:code>no_keywords</db:code> is specified with the <db:code>CONFIG</db:code> variable in the <db:code>.pro</db:code> file, but it can be used even when <db:code>no_keywords</db:code> is <db:emphasis>not</db:emphasis> specified.</db:para>
      </db:section>
      <db:section>
         <db:title>Q_SIGNALS</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_SIGNALS</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Use this macro to replace the <db:code>signals</db:code> keyword in class declarations, when you want to use Qt Signals and Slots with a <db:link xlink:href="signalsandslots.html#3rd-party-signals-and-slots" xrefstyle="page" annotations="3rd Party Signals and Slots">3rd party signal/slot mechanism</db:link>.</db:para>
         <db:para>The macro is normally used when <db:code>no_keywords</db:code> is specified with the <db:code>CONFIG</db:code> variable in the <db:code>.pro</db:code> file, but it can be used even when <db:code>no_keywords</db:code> is <db:emphasis>not</db:emphasis> specified.</db:para>
      </db:section>
      <db:section>
         <db:title>Q_SLOT</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_SLOT</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>This is an additional macro that allows you to mark a single function as a slot. It can be quite useful, especially when you use a 3rd-party source code parser which doesn't understand a <db:code>slots</db:code> or <db:code>Q_SLOTS</db:code> groups.</db:para>
         <db:para>Use this macro to replace the <db:code>slots</db:code> keyword in class declarations, when you want to use Qt Signals and Slots with a <db:link xlink:href="signalsandslots.html#3rd-party-signals-and-slots" xrefstyle="page" annotations="3rd Party Signals and Slots">3rd party signal/slot mechanism</db:link>.</db:para>
         <db:para>The macro is normally used when <db:code>no_keywords</db:code> is specified with the <db:code>CONFIG</db:code> variable in the <db:code>.pro</db:code> file, but it can be used even when <db:code>no_keywords</db:code> is <db:emphasis>not</db:emphasis> specified.</db:para>
      </db:section>
      <db:section>
         <db:title>Q_SLOTS</db:title>
         <db:methodsynopsis>
            <db:methodname>Q_SLOTS</db:methodname>
            <db:void/>
            <db:modifier>public</db:modifier>
         </db:methodsynopsis>
         <db:para>Use this macro to replace the <db:code>slots</db:code> keyword in class declarations, when you want to use Qt Signals and Slots with a <db:link xlink:href="signalsandslots.html#3rd-party-signals-and-slots" xrefstyle="page" annotations="3rd Party Signals and Slots">3rd party signal/slot mechanism</db:link>.</db:para>
         <db:para>The macro is normally used when <db:code>no_keywords</db:code> is specified with the <db:code>CONFIG</db:code> variable in the <db:code>.pro</db:code> file, but it can be used even when <db:code>no_keywords</db:code> is <db:emphasis>not</db:emphasis> specified.</db:para>
      </db:section>
   </db:section>
</db:article>
